<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>JamPlus manual: Jam Language</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7 -->
<div class="contents">
<h1><a class="anchor" name="jam_language">Jam Language </a></h1><h2><a class="anchor" name="cmd_intro">
Introduction</a></h2>
(Note: Much of this documentation is taken verbatim from the jam.html file which ships with the Perforce Jam build.)<h2><a class="anchor" name="usage">
Usage</a></h2>
<pre>
jam [ -a ] [ -g ] [ -n ] [ -q ] [ -T ] [ -v ]
    [ -C <em>workdir</em> ]
    [ -d <em>debug</em> ]
    [ -f <em>jambase</em> ]
    [ -j <em>jobs</em> ]
    [ -o <em>actionsfile</em> ]
    [ -s <em>var</em>=<em>value</em> ]
    [ -t <em>target</em> ]
    [ <em>target</em> ... ]
</pre><p>
<hr>
<h2><a class="anchor" name="options">
Options</a></h2>
If <em>target</em> is provided on the command line, <b>jam</b> builds <em>target;</em> otherwise <b>jam</b> builds the target 'all'.<p>
<b>Jam</b> may be invoked with the following options:<p>
<table width="85%" align="center" border="1" cellpadding="2" cellspacing="3">
<tr>
<td valign="top" width="20%"><code> -a </code> </td><td>Build all targets anyway, even if they are up-to-date.<p>
</td></tr>
<tr>
<td valign="top"><code> -C <em>workdir</em> </code> </td><td>Set the <b>Jam</b> current working directory to <em>workdir</em>.<p>
</td></tr>
<tr>
<td valign="top"><code> -d <em>c</em> </code> </td><td>Turn on display option <em>c</em> and off the default display (summary info and actions):<p>
<dl>
<dt>a </dt>
<dd>Show summary info, actions, quiet actions, and the use of temporary targets </dd>
<dt>c </dt>
<dd>Show the names of files that cause rebuilds, i.e. new sources, missing targets, etc. </dd>
<dt>d </dt>
<dd>Display a dependency graph (in <b>jam</b> syntax). </dd>
<dt>f </dt>
<dd>Display fate changes. </dd>
<dt>g </dt>
<dd>Display a detailed hierarchical dependency graph. </dd>
<dt>m </dt>
<dd>Display the dependency analysis, and target/source timestamps and paths </dd>
<dt>x </dt>
<dd>Show shell arguments </dd>
</dl>
<p>
</td></tr>
<tr>
<td valign="top"><code> -d <em>n</em> </code> </td><td>Enable cumulative debugging levels from 1 to <em>n</em>. Interesting values are:<p>
<dl>
<dt>1 </dt>
<dd>Show actions and summary info (the default) </dd>
<dt>2 </dt>
<dd>Show text of actions </dd>
<dt>3 </dt>
<dd>Show progress of make. Show files when bound </dd>
<dt>4 </dt>
<dd>Show execcmd()'s work </dd>
<dt>5 </dt>
<dd>Show rule invocations and variable expansions </dd>
<dt>6 </dt>
<dd>Show directory/header file/archive scans </dd>
<dt>7 </dt>
<dd>Show variable settings </dd>
<dt>8 </dt>
<dd>Show variable fetches and expansions. Show 'if' calculations. </dd>
<dt>9 </dt>
<dd>Show variable manipulation, scanner tokens. Show memory use. </dd>
</dl>
<p>
</td></tr>
<tr>
<td valign="top"><code> -d +<em>n</em> </code> </td><td>Enable debugging level <em>n</em>.<p>
</td></tr>
<tr>
<td valign="top"><code> -d 0 </code> </td><td>Turn off all debugging levels. Only errors are emitted.<p>
</td></tr>
<tr>
<td valign="top"><code> -f <em>jambase</em></code> </td><td>Read <em>jambase</em> instead of using the built-in Jambase. Multiple -f flags are permitted.<p>
</td></tr>
<tr>
<td valign="top"><code> -g </code> </td><td>Build targets with the newest sources first, rather than in the order of appearance in the Jambase/Jamfiles.<p>
</td></tr>
<tr>
<td valign="top"><code> -j <em>n</em></code> </td><td>Run up to <em>n</em> shell commands concurrently (UNIX and NT only). The default is 1.<p>
</td></tr>
<tr>
<td valign="top"><code> -n</code> </td><td>Don't actually execute the updating actions, but do everything else. This changes the debug level to -dax.<p>
</td></tr>
<tr>
<td valign="top"><code> -o <em>file</em></code> </td><td>Write the updating actions to the specified file instead of running them (or outputting them, as on the Mac).<p>
</td></tr>
<tr>
<td valign="top"><code> -q </code> </td><td>Quit quickly (as if an interrupt was received) as soon as any target build fails.<p>
</td></tr>
<tr>
<td valign="top"><code> -s <em>var</em>=<em>value</em></code> </td><td>Set the variable <em>var</em> to <em>value</em>, overriding both internal variables and variables imported from the environment.<p>
</td></tr>
<tr>
<td valign="top"><code> -t <em>target</em></code> </td><td>Rebuild <em>target</em> and everything that depends on it, even if it is up-to-date.<p>
</td></tr>
<tr>
<td valign="top"><code> -T </code> </td><td>Toggle printing of the target's bound name (full path).<p>
</td></tr>
<tr>
<td valign="top"><code> -v</code> </td><td>Print the version of <b>jam</b> and exit.<p>
</td></tr>
</table>
<p>
<hr>
 <h2><a class="anchor" name="operation_main">
Operation</a></h2>
Jam has four phases of operation: start-up, parsing, binding, and updating.<h3><a class="anchor" name="operation_start-up">
Start-up Phase</a></h3>
Upon start-up, Jam imports environment variable settings into Jam variables. Environment variables are split at blanks with each word becoming an element in the variable's list of values. Environment variables whose names end in <code>PATH</code> are split at $(SPLITPATH) characters (e.g., <code>";"</code> for Windows and <code>":"</code> for Unix).<p>
To set a variable's value on the command line, overriding the variable's environment value, use the <code>-s</code> option. To see variable assignments made during jam's execution, use the <code>-d+7</code> option.<h3><a class="anchor" name="operation_parsing">
Parsing Phase</a></h3>
In the parsing phase, <b>Jam</b> reads and executes the <code>Jambase.jam</code> file. It finds a <code>Jambase.jam</code> file by looking for one in the current working directory and then looking up through 10 parent directories. If one has not been found by this point, the <code>Jambase.jam</code> sitting side-by-side with the <b>Jam</b> executable is read in.<p>
The <code>Jambase</code> file is written in the <b>Jam</b> <a class="el" href="jam_language.html#language_main">Language</a>. The last action of the <code>Jambase</code> is to read (via the "include" rule) a user-provided file called "<code>Jamfile.jam</code>".<p>
Collectively, the purpose of the <code>Jambase</code> and the <code>Jamfile</code> is to name built target and source files, construct the dependency graph among them, and associate build actions with targets. The <code>Jambase</code> defines boilerplate rules and variable assignments, and the <code>Jamfile</code> uses these to specify the actual relationship among the target and source files. See the <a class="el" href="jambase_rules.html">Jambase Rules</a> document for information.<h3><a class="anchor" name="operation_binding">
Binding Phase</a></h3>
<h4><a class="anchor" name="operation_binding_binding">
Binding</a></h4>
After parsing, <b>Jam</b> recursively descends the dependency graph and binds every file target with a location in the filesystem.<h4><a class="anchor" name="operation_binding_targets">
Targets</a></h4>
Any string value in <b>Jam</b> can represent a target, and it does so if the <a class="el" href="jam_language.html#rule_Depends">Depends</a> or <a class="el" href="jam_language.html#rule_Includes">Includes</a> rules make it part of the dependency graph. <em>Build targets</em> are files to be updated. <em>Source targets</em> are the files used in updating build targets. Build targets and source targets are collectively referred to as file targets, and frequently build targets are source targets for other build targets. <em>Pseudotargets</em> are symbols which represent dependencies on other targets, but which are not themselves associated with any real file.<p>
A file target's identifier is generally the file's name, which can be absolutely rooted, relative to the directory of jam's invocation, or simply local (no directory). Most often it is the last case, and the actual file path is bound using the $(BINDING), $(SEARCH), and $(LOCATE) special variables. See <a class="el" href="jam_language.html#language_built_in_variables_binding_search_locate">BINDING, SEARCH, and LOCATE Variables</a> below. A local filename is optionally qualified with "grist," a string value used to assure uniqueness. A file target with an identifier of the form <em>file(member)</em> is a library member (usually an ar(1) archive on UNIX).<p>
The use of $(BINDING), $(SEARCH), and $(LOCATE) allows <b>Jam</b> to separate the the location of files from their names, so that Jamfiles can refer to files locally (i.e. relative to the Jamfile's directory), yet still be usable when <b>Jam</b> is invoked from a distant directory. The use of grist allows files with the same name to be identified uniquely, so that <b>Jam</b> can read a whole directory tree of Jamfiles and not mix up same-named targets.<h4><a class="anchor" name="operation_binding_update_determination">
Update Determination</a></h4>
After binding each target, <b>Jam</b> determines whether the target needs updating, and, if so, marks the target for the updating phase. A target is normally so marked if it is missing, is older than any of its sources, or any of its sources are marked for updating. This behavior can be modified by the application of special built-in rules. See <a class="el" href="jam_language.html#language_built_in_rules_modifying_binding">Modifying Binding</a> below.<h4><a class="anchor" name="operation_binding_header_file_scanning">
Header File Scanning</a></h4>
During the binding phase, <b>Jam</b> also performs "header" file scanning, where it looks inside source files for the implicit dependencies on other files caused by C's #include syntax (or whatever is appropriate for other file formats). This is controlled by the special variables $(HDRSCAN) and $(HDRRULE). The result of the scan is formed into a rule invocation, with the scanned file as the target and the found included file names as the sources. Note that this is the only case where rules are invoked outside the parsing phase. See <a class="el" href="jam_language.html#language_built_in_variables_hdrscan">HDRSCAN and HDRRULE Variables</a> below.<h3><a class="anchor" name="operation_updating">
Updating Phase</a></h3>
After binding, <b>Jam</b> again recursively descends the dependency graph, this time executing the update actions for each target marked for update during the binding phase. If a target's updating actions fail, then all other targets which depend on that target are skipped.<p>
The <code>-j</code> flag instructs jam to build more than one target at a time. If there are multiple actions on a single target, they are run sequentially. The <code>-g</code> flag reorders builds so that targets with newest sources are built first. Normally, they are built in the order of appearance in the Jamfiles.<p>
<hr>
 <h2><a class="anchor" name="language_main">
Language</a></h2>
<h3><a class="anchor" name="language_overview">
Overview</a></h3>
Jam has a interpreted, procedural language with a few select features to effect program construction. Statements in jam are rule (procedure) definitions, rule invocations, updating action definitions, flow-of-control structures, variable assignments, and sundry language support.<h3><a class="anchor" name="language_lexical_features">
Lexical Features</a></h3>
<b>Jam</b> treats its input files as whitespace-separated tokens, with two exceptions: double quotes (") can enclose whitespace to embed it into a token, and everything between the matching curly braces ({}) in the definition of a updating actions is treated as a single string. A backslash (\) can escape a double quote, or any single whitespace character. Both a newline and a tab must be represented physically within quotes. There is no backslash escape for them.<p>
<b>Jam</b> requires whitespace (blanks, tabs, or newlines) to surround all tokens, <b>including the colon (:) and semicolon (;) tokens</b>.<p>
<b>Jam</b> keywords (as mentioned in this document) are reserved and generally must be quoted with double quotes (") to be used as arbitrary tokens, such as variable or target names.<h3><a class="anchor" name="language_datatype">
Datatype</a></h3>
<b>Jam</b>'s only data type is a one-dimensional list of arbitrary strings. They arise as literal (whitespace-separated) tokens in the Jambase or included files, as the result of variable expansion of those tokens, or as the return value from a rule invocation.<h3><a class="anchor" name="language_rules">
Rules</a></h3>
The basic <b>Jam</b> language entity is called a rule. A rule is simply a procedure definition, with a body of <b>Jam</b> statements to be run when the rule is invoked. The syntax of rule invocation make it possible to write Jamfiles that look a bit like Makefiles.<p>
Rules take up to 9 arguments ($(1) through $(9), each a list) and can have a return value (a single list). A rule's return value can be expanded in a list by enclosing the rule invocation with [ and ].<h3><a class="anchor" name="language_updating_actions">
Updating Actions</a></h3>
A rule may have updating actions associated with it, in which case arguments $(1) and $(2) are treated as built targets and sources, respectively. Updating actions are the OS shell commands to execute when updating the built targets of the rule.<p>
When a rule with updating actions is invoked, those actions are added to those associated with its built targets ($(1)) before the rule's procedure is run. Later, to build the targets in the updating phase, the actions are passed to the OS command shell, with $(1) and $(2) replaced by bound versions of the target names. See <a class="el" href="jam_language.html#operation_binding">Binding Phase</a> above.<h3><a class="anchor" name="language_statements">
Statements</a></h3>
<code>Jam</code>'s language has the following statements:<p>
 <blockquote> <p>
<code><em>rulename</em> <em>field1</em> : <em>field2</em> : ... : <em>fieldN</em> ;</code><p>
 <blockquote> <p>
Invoke a rule. A rule is invoked with values in <em>field1</em> through <em>fieldN</em> (9 max). They may be referenced in the procedure's <em>statements</em> as $(1) through $(&lt;9&gt;N). $(&lt;) and $(&gt;) are synonymous with $(1) and $(2).<p>
<em>rulename</em> undergoes <a class="el" href="jam_language.html#language_variable_expansion">Variable Expansion</a>. If the resulting list is more than one value, each rule is invoked with the same arguments, and the result of the invocation is the concatenation of all the results.<p>
 </blockquote> <p>
<code>actions [ <em>modifiers</em> ] <em>rulename</em> { <em>commands</em> }</code><p>
 <blockquote> <p>
Define a rule's updating actions, replacing any previous definition. The first two arguments may be referenced in the action's <em>commands</em> as $(1) and $(2) or $(&lt;) and $(&gt;).<p>
The following action <em>modifiers</em> are understood:<p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><code>actions bind vars</code> (deprecated) </td><td>$(vars) will be replaced with bound values. The preferred way to expand a bound value in JamPlus is to use the <code>:T</code> variable expansion modifier like so: <code>$(vars:T)</code>  </td></tr>
<tr>
<td><code>actions existing</code> </td><td>$(&gt;) includes only source targets currently existing.  </td></tr>
<tr>
<td><code>actions ignore</code> </td><td>The return status of the <em>commands</em> is ignored.  </td></tr>
<tr>
<td><code>actions piecemeal</code> </td><td><em>commands</em> are repeatedly invoked with a subset of $(&gt;) small enough to fit in the command buffer on this OS.  </td></tr>
<tr>
<td><code>actions quietly</code> </td><td>The action is not echoed to the standard output.  </td></tr>
<tr>
<td><code>actions together</code> </td><td>The $(&gt;) from multiple invocations of the same action on the same built target are concatenated together.  </td></tr>
<tr>
<td><code>actions updated</code> </td><td>$(&gt;) includes only source targets themselves marked for updating.  </td></tr>
</table>
<p>
 </blockquote> <p>
<code>break</code><p>
 <blockquote> <p>
Breaks out of the closest enclosing <em>for</em> or <em>while</em> loop.<p>
 </blockquote> <p>
<code>continue</code><p>
 <blockquote> <p>
Jumps to the end of the closest enclosing <em>for</em> or <em>while</em> loop.<p>
 </blockquote> <p>
<code>for <em>var</em> in <em>list</em> { <em>statements</em> }</code><p>
 <blockquote> <p>
Executes <em>statements</em> for each element in <em>list</em>, setting the variable <em>var</em> to the element value.<p>
 </blockquote> <p>
<code>if <em>cond</em> { <em>statements</em> } [ else <em>statement</em> ] </code><p>
 <blockquote> <p>
Does the obvious; the else clause is optional. <em>cond</em> is built of:<p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td width="25%"><code><em>a</code></em>  </td><td>true if any <em>a</em> element is a non-zero-length string  </td></tr>
<tr>
<td><code><em>a</em> = <em>b</code></em>  </td><td>list <em>a</em> matches list <em>b</em> string-for-string  </td></tr>
<tr>
<td><code><em>a</em> != <em>b</code></em>  </td><td>list <em>a</em> does not match list <em>b</em>   </td></tr>
<tr>
<td><code><em>a</em> &lt; <em>b</em> </code> </td><td><em>a[i]</em> string is less than <em>b[i]</em> string, where <em>i</em> is first mismatched element in lists <em>a</em> and <em>b</em>   </td></tr>
<tr>
<td><code><em>a</em> &lt;= <em>b</code></em>  </td><td>every <em>a</em> string is less than or equal to its <em>b</em> counterpart  </td></tr>
<tr>
<td><code><em>a</em> &gt; <em>b</code></em>  </td><td><em>a[i]</em> string is greater than <em>b[i]</em> string, where <em>i</em> is first mismatched element  </td></tr>
<tr>
<td><code><em>a</em> &gt;= <em>b</code></em>  </td><td>every <em>a</em> string is greater than or equal to its <em>b</em> counterpart  </td></tr>
<tr>
<td><code><em>a</em> in <em>b</code></em>  </td><td>true if all elements of <em>a</em> can be found in <em>b</em>, or if <em>a</em> has no elements  </td></tr>
<tr>
<td><code>! <em>cond</code></em>  </td><td>condition not true  </td></tr>
<tr>
<td><code><em>cond</em> &amp;&amp; <em>cond</em> </code> </td><td>logical and  </td></tr>
<tr>
<td><code><em>cond</em> || <em>cond</code></em>  </td><td>logical or  </td></tr>
<tr>
<td><code>( <em>cond</em> )</code> </td><td>precedence grouping </td></tr>
</table>
<p>
 </blockquote> <p>
<code>include file ;</code><p>
 <blockquote> <p>
Causes <b>Jam</b> to read the named file. The file is bound like a regular target (see <a class="el" href="jam_language.html#operation_binding">Binding Phase</a> above) but unlike a regular target, the include file cannot be built. Marking an include file target with the <a class="el" href="jam_language.html#rule_NoCare">rule_NoCare</a> rule makes it optional: if it is missing, it causes no error.<p>
The include file is inserted into the input stream during the parsing phase. The primary input file and all the included file(s) are treated as a single file; that is, <b>Jam</b> infers no scope boundaries from included files.<p>
 </blockquote> <p>
<code>local <em>vars</em> [ = <em>values</em> ] ;</code><p>
 <blockquote> <p>
Creates new <em>vars</em> inside to the enclosing {} block, obscuring any previous values they might have. The previous values for <em>vars</em> are restored when the current block ends. Any rule called or file included will see the local and not the previous value (this is sometimes called Dynamic Scoping). The local statement may appear anywhere, even outside of a block (in which case the previous value is restored when the input ends). The <em>vars</em> are initialized to <em>values</em> if present, or left uninitialized otherwise.<p>
 </blockquote> <p>
<code>on <em>target</em> <em>statement</em> ;</code><p>
 <blockquote> <p>
Run <em>statement</em> under the influence of <em>target</em>'s target-specific variables. These variables become local copies during <em>statement</em>'s run, but they may be updated as target-specific variables using the usual "<em>variable</em> on <em>targets</em> =" syntax.<p>
 </blockquote> <p>
<code>return <em>values</em> ;</code><p>
 <blockquote> <p>
Within a rule body, the return statement sets the return value for an invocation of the rule and terminates the rule's execution.<p>
 </blockquote> <p>
<code>rule <em>rulename</em> [ : <em>vars</em> ] { <em>statements</em> }</code><p>
 <blockquote> <p>
Define a rule's procedure, replacing any previous definition. If <em>vars</em> are provided, they are assigned the values of the parameters ($(1) to $(9)) when <em>statements</em> are executed, as with the <b>local</b> statement.<p>
 </blockquote> <p>
<code> switch <em>value</em> <br>
 {<br>
 case <em>pattern1</em> : <em>statements</em> ;<br>
 case <em>pattern2</em> : <em>statements</em> ;<br>
 ...<br>
 } </code><p>
 <blockquote> <p>
The switch statement executes zero or one of the enclosed <em>statements</em>, depending on which, if any, is the first case whose <em>pattern</em> matches <em>value</em>. The <em>pattern</em> values are not variable-expanded. The <em>pattern</em> values may include the following wildcards:<p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><code>?</code> </td><td>match any single character  </td></tr>
<tr>
<td><code>*</code> </td><td>match zero or more characters  </td></tr>
<tr>
<td><code>[<em>chars</em>]</code> </td><td>match any single character in <em>chars</em>   </td></tr>
<tr>
<td><code>[^<em>chars</em>]</code> </td><td>match any single character not in <em>chars</em>  </td></tr>
<tr>
<td><code>\<em>x</em></code> </td><td>match <em>x</em> (escapes the other wildcards)  </td></tr>
</table>
<p>
 </blockquote> <p>
<code>while <em>cond</em> { <em>statements</em> }</code><p>
 <blockquote> <p>
Repeatedly execute <em>statements</em> while <em>cond</em> remains true upon entry. (See the description of <em>cond</em> expression syntax under if above).<p>
 </blockquote> <p>
 </blockquote> <h3><a class="anchor" name="language_variables">
Variables</a></h3>
<b>Jam</b> variables are lists of zero or more elements, with each element being a string value. An undefined variable is indistinguishable from a variable with an empty list, however, a defined variable may have one more elements which are null strings. All variables are referenced as $(<em>variable</em>).<p>
Variables are either global or target-specific. In the latter case, the variable takes on the given value only during the target's binding, header file scanning, and updating; and during the "on &lt;i&gt;target&lt;/i&gt; &lt;i&gt;statement&lt;/I&gt;" statement.<p>
A variable is defined with:<p>
<table align="center" border="1" cellspacing="3" cellpadding="3">
<tr>
<td><code><em>variable</em> = <em>elements</em> ;</code> </td><td>The = operator replaces any previous elements of <em>variable</em> with <em>elements</em>   </td></tr>
<tr>
<td><code><em>variable</em> += <em>elements</em> ;</code> </td><td>The += operator adds <em>elements</em> to <em>variable</em>'s list of elements  </td></tr>
<tr>
<td><code><em>variable</em> -= <em>elements</em> ;</code> </td><td>The -= operator removes <em>elements</em> from <em>variable</em>'s list of elements  </td></tr>
<tr>
<td><code><em>variable</em> ?= <em>elements</em> ;</code> </td><td>The ?= operator sets <em>variable</em> only if it was previously unset  </td></tr>
<tr>
<td><code><em>variable</em> on <em>targets</em> = <em>elements</em> ;</code> </td><td>The = operator replaces any previous elements of <em>variable</em> with <em>elements</em> directly on <em>targets</em>   </td></tr>
<tr>
<td><code><em>variable</em> on <em>targets</em> += <em>elements</em> ;</code> </td><td>The += operator directly adds <em>elements</em> to <em>targets</em>'s <em>variable</em>'s list of elements  </td></tr>
<tr>
<td><code><em>variable</em> on <em>targets</em> -= <em>elements</em> ;</code> </td><td>The -= operator directly removes <em>elements</em> from <em>targets</em>'s <em>variable</em>'s list of elements  </td></tr>
<tr>
<td><code><em>variable</em> on <em>targets</em> ?= <em>elements</em> ;</code> </td><td>The ?= operator sets <em>variable</em> on <em>targets</em> only if it was previously unset  </td></tr>
</table>
<p>
Variables referenced in updating commands will be replaced with their values; target-specific values take precedence over global values. Variables passed as arguments ($(1) and $(2)) to actions are replaced with their bound values; the "bind" modifier can be used on actions to cause other variables to be replaced with bound values. See <a href="#actionmods">Action Modifiers</a> above.<p>
<b>Jam</b> variables are not re-exported to the environment of the shell that executes the updating actions, but the updating actions can reference <b>Jam</b> variables with $(<em>variable</em>).<h3><a class="anchor" name="language_variable_expansion">
Variable Expansion</a></h3>
During parsing, <b>Jam</b> performs variable expansion on each token that is not a keyword or rule name. Such tokens with embedded variable references are replaced with zero or more tokens. Variable references are of the form $(<em>v</em>) or $(<em>vm</em>), where <em>v</em> is the variable name, and <em>m</em> are optional modifiers.<p>
Variable expansion in a rule's actions is similar to variable expansion in statements, except that the action string is tokenized at whitespace regardless of quoting.<p>
The result of a token after variable expansion is the <em>product</em> of the components of the token, where each component is a literal substring or a list substituting a variable reference. For example:<p>
<table width="75%" align="center" border="1" cellspacing="3" cellpadding="3">
<tr>
<td><code> <br>
$(X) -&gt; a b c <br>
t$(X) -&gt; ta tb tc <br>
$(X)z -&gt; az bz cz <br>
$(X)-$(X) -&gt; a-a a-b a-c b-a b-b b-c c-a c-b c-c </code>  </td></tr>
</table>
<p>
The variable name and modifiers can themselves contain a variable reference, and this partakes of the product as well:<p>
<table width="75%" align="center" border="1" cellspacing="3" cellpadding="3">
<tr>
<td><code> <br>
$(X) -&gt; a b c <br>
$(Y) -&gt; 1 2 <br>
$(Z) -&gt; X Y <br>
$($(Z)) -&gt; a b c 1 2</code><p>
<code> </code>  </td></tr>
</table>
<p>
Because of this product expansion, if any variable reference in a token is undefined, the result of the expansion is an empty list. If any variable element is a null string, the result propagates the non-null elements:<p>
<table width="75%" align="center" border="1" cellspacing="3" cellpadding="3">
<tr>
<td><code> <br>
$(X) -&gt; a "" <br>
$(Y) -&gt; "" 1 <br>
$(Z) -&gt; <br>
*$(X)$(Y)* -&gt; *a* *a1* ** *1* <br>
*$(X)$(Z)* -&gt;</code><p>
<code> </code>  </td></tr>
</table>
<p>
A variable element's string value can be parsed into grist and filename-related components. Modifiers to a variable are used to select elements, select components, and replace components. The modifiers are:<p>
<table width="75%" border="1" align="center" cellspacing="3" cellpadding="3">
<tr>
<td><code> [<em>n</em>] </code> </td><td>Select element number <em>n</em> (starting at 1). If the variable contains fewer than <em>n</em> elements, the result is a zero-element list.  </td></tr>
<tr>
<td><code> [<em>n</em>-<em>m</em>] </code> </td><td>Select elements number <em>n</em> through <em>m</em>.  </td></tr>
<tr>
<td><code> [<em>n</em>-] </code> </td><td>Select elements number <em>n</em> through the last.  </td></tr>
<tr>
<td><code> :B </code> </td><td>Select filename base.  </td></tr>
<tr>
<td><code> :S </code> </td><td>Select (last) filename suffix.  </td></tr>
<tr>
<td><code> :M </code> </td><td>Select archive member name.  </td></tr>
<tr>
<td><code> :D </code> </td><td>Select directory path.  </td></tr>
<tr>
<td><code> :P </code> </td><td>Select parent directory.  </td></tr>
<tr>
<td><code> :G </code> </td><td>Select grist.  </td></tr>
<tr>
<td><code> :U </code> </td><td>Replace lowercase characters with uppercase.  </td></tr>
<tr>
<td><code> :L </code> </td><td>Replace uppercase characters with lowercase.  </td></tr>
<tr>
<td><code> :/ </code> </td><td>Convert all backslashes (\) to forward slashes (/).  </td></tr>
<tr>
<td><code> :\\ </code> </td><td>Convert all forward slashes (/) to backslashes (\).  </td></tr>
<tr>
<td><code> :<em>chars</em> </code> </td><td>Select the components listed in <em>chars</em>.  </td></tr>
<tr>
<td><code> :G=<em>grist</em> </code> </td><td>Replace grist with <em>grist</em>.  </td></tr>
<tr>
<td><code> :D=<em>path</em> </code> </td><td>Replace directory with <em>path</em>.  </td></tr>
<tr>
<td><code> :B=<em>base</em> </code> </td><td>Replace the base part of file name with <em>base</em>.  </td></tr>
<tr>
<td><code> :S=<em>suf</em> </code> </td><td>Replace the suffix of file name with <em>suf</em>.  </td></tr>
<tr>
<td><code> :M=<em>mem</em> </code> </td><td>Replace the archive member name with <em>mem</em>.  </td></tr>
<tr>
<td><code> :R=<em>root</em> </code> </td><td>Prepend <em>root</em> to the whole file name, if not already rooted.  </td></tr>
<tr>
<td><code> :E=<em>value</em> </code> </td><td>Use <em>value</em> instead if the variable is unset.  </td></tr>
<tr>
<td><code> :J=<em>joinval</em> </code> </td><td>Concatentate list elements into single element, separated by <em>joinval</em>.  </td></tr>
</table>
<p>
On VMS, $(var:P) is the parent directory of $(var:D); on Unix and NT, $(var:P) and $(var:D) are the same.<h3><a class="anchor" name="language_built_in_rules">
Built-in Rules</a></h3>
Jam has twelve built-in rules, all of which are pure procedure rules without updating actions. They are in three groups: the first builds the dependency graph; the second modifies it; and the third are just utility rules.<h4><a class="anchor" name="language_built_in_rules_dependency_building">
Dependency Building</a></h4>
<table width="75%" align="center" border="1" cellspacing="3" cellpadding="3">
<tr>
<td><dl>
</dl>
rule_Depends </td></tr>
</table>
<p>
<code> Depends <em>targets1</em> : <em>targets2</em> ; </code> Builds a direct dependency: makes each of <em>targets1</em> depend on each of <em>targets2</em>. Generally, <em>targets1</em> will be rebuilt if <em>targets2</em> are themselves rebuilt are or are newer than <em>targets1</em>.<p>
<a class="anchor" name="rule_Includes"></a> <p>
<code>Includes <em>targets1</em> : <em>targets2</em> ;</code> Builds a sibling dependency: makes any target that depends on any of <em>targets1</em> also depend on each of <em>targets2</em>. This reflects the dependencies that arise when one source file includes another: the object built from the source file depends both on the original and included source file, but the two sources files don't depend on each other. For example:<p>
<code> Depends foo.o : foo.c ; <br>
Includes foo.c : foo.h ; </code><p>
"foo.o" depends on "foo.c" and "foo.h" in this example.<h4><a class="anchor" name="language_built_in_rules_modifying_binding">
Modifying Binding</a></h4>
The six rules ALWAYS, LEAVES, NOCARE, NOTFILE, NOUPDATE, and TEMPORARY modify the dependency graph so that <b>jam</b> treats the targets differently during its target binding phase. See <a href="#binding">Binding</a> above. Normally, <b>jam</b> updates a target if it is missing, if its filesystem modification time is older than any of its dependencies (recursively), or if any of its dependencies are being updated. This basic behavior can be changed by invoking the following rules:<p>
<table width="75%" align="center" border="1" cellspacing="3" cellpadding="3">
<tr>
<td><dl>
<dt><code> ALWAYS <em>targets</em> ; </code>  </dt>
<dd>Causes <em>targets</em> to be rebuilt regardless of whether they are up-to-date (they must still be in the dependency graph). This is used for the clean and uninstall targets, as they have no dependencies and would otherwise appear never to need building. It is best applied to targets that are also NOTFILE targets, but it can also be used to force a real file to be updated as well.<p>
</dd>
<dt><code> LEAVES <em>targets</em> ; </code>  </dt>
<dd>Makes each of <em>targets</em> depend only on its leaf sources, and not on any intermediate targets. This makes it immune to its dependencies being updated, as the "leaf" dependencies are those without their own dependencies and without updating actions. This allows a target to be updated only if original source files change.<p>
<a class="anchor" name="rule_NoCare"></a> </dd>
<dt><code> NOCARE <em>targets</em> ; </code>  </dt>
<dd>Causes <b>jam</b> to ignore <em>targets</em> that neither can be found nor have updating actions to build them. Normally for such targets <b>jam</b> issues a warning and then skips other targets that depend on these missing targets. The HdrRule in Jambase uses NOCARE on the header file names found during header file scanning, to let <b>jam</b> know that the included files may not exist. For example, if a include is within an ifdef, the included file may not actually be around.<p>
</dd>
<dt><code> NOTFILE <em>targets</em> ; </code>  </dt>
<dd>Marks <em>targets</em> as pseudotargets and not real files. No timestamp is checked, and so the actions on such a target are only executed if the target's dependencies are updated, or if the target is also marked with ALWAYS. The default <b>jam</b> target "all" is a pseudotarget. In Jambase, NOTFILE is used to define several addition convenient pseudotargets.<p>
</dd>
<dt><code> NOUPDATE <em>targets</em> ; </code>  </dt>
<dd>Causes the timestamps on <em>targets</em> to be ignored. This has two effects: first, once the target has been created it will never be updated; second, manually updating target will not cause other targets to be updated. In Jambase, for example, this rule is applied to directories by the MkDir rule, because MkDir only cares that the target directory exists, not when it has last been updated.<p>
</dd>
<dt><code> TEMPORARY <em>targets</em> ; </code>  </dt>
<dd>Marks <em>targets</em> as temporary, allowing them to be removed after other targets that depend upon them have been updated. If a TEMPORARY target is missing, <b>jam</b> uses the timestamp of the target's parent. Jambase uses TEMPORARY to mark object files that are archived in a library after they are built, so that they can be deleted after they are archived.<p>
</dd>
</dl>
</td></tr>
</table>
<h4><a class="anchor" name="language_built_in_rules_utility_rules">
Utility Rules</a></h4>
The remaining rules are utility rules.<p>
<table width="75%" align="center" border="1" cellspacing="3" cellpadding="3">
<tr>
<td><dl>
<dt><code> Echo <em>args</em> ; </code>  </dt>
<dd>Prints out the message <em>args</em> to stdout.<p>
</dd>
<dt><code> Exit <em>args</em> ; </code>  </dt>
<dd>Blurts out the message <em>args</em> to stdout and then exits with a failure status.<p>
</dd>
<dt><code> Glob <em>directories</em> : <em>patterns</em> ; </code>  </dt>
<dd>Scans <em>directories</em> for files matching <em>patterns</em>, returning the list of matching files (with directory prepended). <em>patterns</em> uses the same syntax as in the <b>switch</b> statement. Only useful within the <code>[ ]</code> construct, to change the result into a list.<p>
</dd>
<dt><code> Match <em>regexps</em> : <em>list</em> ; </code>  </dt>
<dd>Matches the <b>egrep</b>(1) style regular expressions <em>regexps</em> against the strings in <em>list</em>. The result is the concatenation of matching <code>()</code> subexpressions for each string in <em>list</em>, and for each regular expression in <em>regexps</em>. Only useful within the <code>[ ]</code> construct, to change the result into a list.<p>
</dd>
</dl>
<p>
</td></tr>
</table>
<h3><a class="anchor" name="language_built_in_variables">
Built-in Variables</a></h3>
This section discusses variables that have special meaning to <b>jam</b>.<h4><a class="anchor" name="language_built_in_variables_binding_search_locate">
BINDING, SEARCH, and LOCATE Variables</a></h4>
These two variables control the binding of file target names to locations in the file system. Generally, $(SEARCH) is used to find existing sources while $(LOCATE) is used to fix the location for built targets.<p>
Rooted (absolute path) file targets are bound as is. Unrooted file target names are also normally bound as is, and thus relative to the current directory, but the settings of $(LOCATE) and $(SEARCH) alter this:<p>
<ul>
<li>
If $(LOCATE) is set then the target is bound relative to the first directory in . Only the first element is used for binding. </li>
<li>
If $(SEARCH) is set then the target is bound to the first directory in $(SEARCH) where the target file already exists. </li>
<li>
If the $(SEARCH) search fails, the target is bound relative to the current directory anyhow. </li>
</ul>
<p>
Both $(SEARCH) and $(LOCATE) should be set target-specific and not globally. If they were set globally, <b>jam</b> would use the same paths for all file binding, which is not likely to produce sane results. When writing your own rules, especially ones not built upon those in Jambase, you may need to set $(SEARCH) or $(LOCATE) directly. Almost all of the rules defined in Jambase set $(SEARCH) and $(LOCATE) to sensible values for sources they are looking for and targets they create, respectively.<h4><a class="anchor" name="language_built_in_variables_hdrscan">
HDRSCAN and HDRRULE Variables</a></h4>
These two variables control header file scanning. $(HDRSCAN) is an <b>egrep</b>(1) pattern, with ()'s surrounding the file name, used to find file inclusion statements in source files. Jambase uses $(HDRPATTERN) as the pattern for $(HDRSCAN). $(HDRRULE) is the name of a rule to invoke with the results of the scan: the scanned file is the target, the found files are the sources. $(HDRRULE) is run under the influence of the scanned file's target-specific variables.<p>
Both $(HDRSCAN) and $(HDRRULE) must be set for header file scanning to take place, and they should be set target-specific and not globally. If they were set globally, all files, including executables and libraries, would be scanned for header file include statements.<p>
The scanning for header file inclusions is not exact, but it is at least dynamic, so there is no need to run something like <b>makedepend</b>(GNU) to create a static dependency file. The scanning mechanism errs on the side of inclusion (i.e., it is more likely to return filenames that are not actually used by the compiler than to miss include files) because it can't tell if #include lines are inside #ifdefs or other conditional logic. In Jambase, HdrRule applies the NOCARE rule to each header file found during scanning so that if the file isn't present yet doesn't cause the compilation to fail, <b>jam</b> won't care.<p>
Also, scanning for regular expressions only works where the included file name is literally in the source file. It can't handle languages that allow including files using variable names (as the Jam language itself does).<h4><a class="anchor" name="language_built_in_variables_platform">
Platform Identifier Variables</a></h4>
A number of Jam built-in variables can be used to identify runtime platform:<p>
<table width="75%" align="center" border="1" cellspacing="3" cellpadding="3">
<tr>
<td>OS</td><td>OS identifier string </td></tr>
<tr>
<td>OSPLAT</td><td>Underlying architecture, when applicable </td></tr>
<tr>
<td>MAC</td><td>true on MAC platform </td></tr>
<tr>
<td>NT</td><td>true on NT platform </td></tr>
<tr>
<td>OS2</td><td>true on OS2 platform </td></tr>
<tr>
<td>UNIX</td><td>true on Unix platforms </td></tr>
<tr>
<td>VMS</td><td>true on VMS platform </td></tr>
</table>
<h4><a class="anchor" name="language_built_in_variables_jam_version">
Jam Version Variables</a></h4>
<table width="75%" align="center" border="1" cellspacing="3" cellpadding="3">
<tr>
<td>JAMDATE</td><td>Time and date at <b>jam</b> start-up. </td></tr>
<tr>
<td>JAMUNAME</td><td>Ouput of <b>uname</b>(1) command (Unix only) </td></tr>
<tr>
<td>JAMVERSION</td><td><b>jam</b> version, as reported by jam -v. </td></tr>
</table>
<h4><a class="anchor" name="language_built_in_variables_jamshell">
JAMSHELL Variable</a></h4>
When <b>jam</b> executes a rule's action block, it forks and execs a shell, passing the action block as an argument to the shell. The invocation of the shell can be controlled by $(JAMSHELL). The default on Unix is, for example:<p>
<code>JAMSHELL = /bin/sh -c % ;</code><p>
The % is replaced with the text of the action block.<p>
<b>Jam</b> does not directly support building in parallel across multiple hosts, since that is heavily dependent on the local environment. To build in parallel across multiple hosts, you need to write your own shell that provides access to the multiple hosts. You then reset  to reference it.<p>
Just as <b>jam</b> expands a % to be the text of the rule's action block, it expands a ! to be the multi-process slot number. The slot number varies between 1 and the number of concurrent jobs permitted by the -j flag given on the command line. Armed with this, it is possible to write a multiple host shell. For example:<p>
<table width="75%" align="center" border="1" cellspacing="3" cellpadding="3">
<tr>
<td><code></code><p>
<code> <br>
#!/bin/sh <br>
 <br>
# This sample JAMSHELL uses the SunOS on(1) command to execute a <br>
# command string with an identical environment on another host. <br>
 <br>
# Set JAMSHELL = jamshell ! % <br>
# <br>
# where jamshell is the name of this shell file. <br>
# <br>
# This version handles up to -j6; after that they get executed <br>
# locally. <br>
 <br>
case $1 in <br>
1|4) on winken sh -c "$2";; <br>
2|5) on blinken sh -c "$2";; <br>
3|6) on nod sh -c "$2";; <br>
*) eval "$2";; <br>
esac</code><p>
<code></code></td></tr>
</table>
<h2><a class="anchor" name="diagnostics">
Diagnostics</a></h2>
In addition to generic error messages, <b>jam</b> may emit one of the following:<p>
<table width="75%" align="center" border="1" cellspacing="3" cellpadding="3">
<tr>
<td><dl>
<dt><code> warning: unknown rule X </code> </dt>
<dd><p>
A rule was invoked that has not been defined with an "actions" or "rule" statement.<p>
</dd>
<dt><code> using N temp target(s) </code> </dt>
<dd><p>
Targets marked as being temporary (but nonetheless present) have been found.<p>
</dd>
<dt><code> updating N target(s) </code> </dt>
<dd><p>
Targets are out-of-date and will be updated.<p>
</dd>
<dt><code> can't find N target(s) </code> </dt>
<dd><p>
Source files can't be found and there are no actions to create them.<p>
</dd>
<dt><code> can't make N target(s) </code> </dt>
<dd><p>
Due to sources not being found, other targets cannot be made.<p>
</dd>
<dt><code> warning: X depends on itself </code> </dt>
<dd><p>
A target depends on itself either directly or through its sources.<p>
</dd>
<dt><code> don't know how to make X </code> </dt>
<dd><p>
A target is not present and no actions have been defined to create it.<p>
</dd>
<dt><code> X skipped for lack of Y </code> </dt>
<dd><p>
A source failed to build, and thus a target cannot be built.<p>
</dd>
<dt><code> warning: using independent target X </code> </dt>
<dd><p>
A target that is not a dependency of any other target is being referenced with $(&lt;) or $(&gt;).<p>
</dd>
<dt><code> X removed </code> </dt>
<dd><p>
<b>Jam</b> removed a partially built target after being interrupted.<p>
</dd>
</dl>
</td></tr>
</table>
<h2><a class="anchor" name="bugs">
Bugs, Limitations</a></h2>
The -j flag can cause <b>jam</b> to get confused when single actions update more than one target at a time. <b>jam</b> may proceed as if the targets were built even though they are still under construction.<p>
For parallel building to be successful, the dependencies among files must be properly spelled out, as targets tend to get built in a quickest-first ordering. Also, beware of un-parallelizable commands that drop fixed-named files into the current directory, like <b>yacc</b>(1) does.<p>
With the -j flag, errors from failed commands can get staggeringly mixed up.<p>
A poorly set  is likely to result in silent failure.<h2><a class="anchor" name="author">
Author</a></h2>
Jam's author is Christopher Seiwald (<a href="mailto:seiwald@perforce.com">seiwald@perforce.com</a>). Documentation is provided by <a href="http://www.perforce.com">Perforce Software, Inc.</a><p>
JamPlus's primary author is Joshua Jensen (<a href="mailto:jjensen@workspacewhiz.com">jjensen@workspacewhiz.com</a>). </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Oct 17 02:40:08 2008 for JamPlus manual by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7 </small></address>
</body>
</html>

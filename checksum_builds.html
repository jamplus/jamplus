<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Building with Checksums</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Building with Checksums </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="checksum_builds_overview"></a>
Overview</h1>
<p>Stock Jam is able to determine builds very efficiently by using just the timestamps from files. Upon first access of a file in a given directory, Jam retrieves the timestamp for that file and all other files in the directory. When the timestamp of the source file is newer than that of its built destination target, such as when updating a <code>.cpp</code> file and consequently making the executable now be older, Jam will build the target. If no change is made to a file but the timestamp is updated, a build is correctly (or incorrectly, depending on your view) initiated.</p>
<p>JamPlus adds optional support for using the checksum of a file to determine the need to build. It does so by tracking the timestamp of a file and its associated checksum inside of a file called <code>.jamchecksums</code>. Having checksum support enabled slows down the initial execution of Jam as checksums are gathered, but on subsequent executions where source files aren't changing often, the checksums are looked up from the <code>.jamchecksums</code> database instead of being calculated each time.</p>
<p>Please note that the checksum support is derived from the same system that drives the <a class="el" href="file_cache.html">File Cache</a>, so many of the same concepts apply.</p>
<h1><a class="anchor" id="checksum_builds_usage"></a>
Usage</h1>
<p>Given that checksums are optional and disabled by default, support can be enabled by setting <code>JAM_CHECKSUMS</code> to <code>1</code> at the beginning of any Jamfiles.</p>
<div class="fragment"><div class="line">JAM_CHECKSUMS = 1 ;</div></div><!-- fragment --><p>Without further configuration, the Jam checksums support should work out-of-box. Sometimes, though, additional hints may be needed to compensate for correct but undesirable behaviors.</p>
<p>As with the <a class="el" href="file_cache.html">File Cache</a> facility, checksums require deep calculations through the dependency graph in order to guarantee a correct build. This is a good thing in most circumstances, but there can be some build 'anomalies' that may make it necessary for you to adjust how deep the calculations go or what is considered for the <b>buildmd5sum</b> calculation.</p>
<p>For example, consider a build where the destination target depends on a tool executable. If the source target file changes, the destination target rebuilds. If the tool executable changes, the destination target also rebuilds.</p>
<ul>
<li><code>destination.file</code><ul>
<li>depends on <code>tool.exe</code><ul>
<li>depends on <code>main.cpp</code></li>
</ul>
</li>
<li>depends on <code>source.file</code></li>
</ul>
</li>
</ul>
<p>For the following discussion, assume the tool's author merely adds comments to the <code>main.cpp</code> file that makes up the tool executable's source code with absolute no functionality change.</p>
<p>Using GCC on Linux, it is very likely this scenario will generate the exact same executable. However, <code>destination.file</code> will still rebuild. That is because the <b>buildmd5sum</b> is calculated against <code>tool.exe</code> (which didn't change) and <code>main.cpp</code> (which did change). The extra comment in <code>main.cpp</code> will force Jam to believe the dependencies were updated, and <code>destination.file</code> will build.</p>
<p>Fortunately, there is an easy workaround to this in the form of a 'hint' rule. We merely have to apply the rule <a class="el" href="builtin_rules.html#rule_ForceContentsOnly">rule ForceContentsOnly targets ;</a> to <code>tool.exe</code>, and the <b>buildmd5sum</b> traversal will stop there, never considering <code>main.cpp</code>. This is such a big deal that the rules <a class="el" href="module_c.html#rule_C_Application">rule C.Application TARGET : SOURCES [ : OPTIONS ]</a> and <a class="el" href="module_c.html#rule_C_Library">rule C.Library TARGET : SOURCES [ : OPTIONS ]</a> do it by default.</p>
<p>Unfortunately, using Microsoft's Visual C++, any simple comment change in <code>main.cpp</code> will result in an ever changing <code>tool.exe</code>. When relinking an executable with Microsoft's Visual C++, it is impossible to get a reproducible build; the executable will be different every single time. This means that some documentation-happy programmer may cause massive rebuilds of content for every single bit of commentary he/she adds.</p>
<p>There are a few ways to work around this, but we'll only cover the one specifically used as a hint to the checksum system here.</p>
<p>By using <a class="el" href="builtin_rules.html#rule_IgnoreContents">rule IgnoreContents targets ;</a> on <code>tool.exe</code>, the <b>buildmd5sum</b> traversal will just simply not sum in the contents of <code>tool.exe</code>. The <code>destination.file</code> target's dependency on <code>tool.exe</code> will act only as a dependency that causes <code>tool.exe</code> to build. For <code>destination.file</code> itself, no build will occur when <code>tool.exe</code> changes.</p>
<p>That is bad, of course, and the advised workaround is to use <a class="el" href="builtin_rules.html#rule_UseCommandLine">rule UseCommandLine TARGETS : COMMANDLINE;</a> in addition to <a class="el" href="builtin_rules.html#rule_IgnoreContents">rule IgnoreContents targets ;</a>. When <code>tool.exe</code> receives a change that actually matters, bump a version string supplied to <code>UseCommandLine</code> like this:</p>
<div class="fragment"><div class="line">IgnoreContents tool.exe ;</div><div class="line">UseCommandLine destination.file : v2 ;  # This was previously v1.</div></div><!-- fragment --><p>Using <code>UseCommandLine</code> is often a better method anyway than a direct dependency on the executable. While the direct dependency may be 'most' correct, it may also be overzealous especially in a situation where <code>tool.exe</code> handles more than one type of content, and the change to <code>tool.exe</code> was made for a different file type altogether. In that case, different <code>UseCommandLine</code> statements can be used to better direct what should be built.</p>
<p>Note that using <code>IgnoreContents</code> in this manner is pretty much analogous to using <a class="el" href="builtin_rules.html#rule_Needs">rule Needs <em>targets1</em> : <em>targets2</em> [ : <em>target3</em> ... <em>targets9</em> ] ;</a>. </p>
</div></div><!-- contents -->
</body>
</html>

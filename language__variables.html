<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>JamPlus manual: Variables</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="contents">


<h1><a class="anchor" id="language_variables">Variables </a></h1><h2><a class="anchor" id="language_variable_basics">
Basics</a></h2>
<p><b>Jam</b> variables are lists of zero or more elements, with each element being a string value. An undefined variable is indistinguishable from a variable with an empty list, however, a defined variable may have one more elements which are null strings. All variables are referenced as $(<em>variable</em>).</p>
<p>Variables are either global or target-specific. In the latter case, the variable takes on the given value only during the target's binding, header file scanning, and updating; and during the "on &lt;i&gt;target&lt;/i&gt; &lt;i&gt;statement&lt;/I&gt;" statement.</p>
<p>A variable is defined with:</p>
<table  align="center">
<tr>
<td><code><em>variable</em> = <em>elements</em> ;</code> </td><td>The = operator replaces any previous elements of <em>variable</em> with <em>elements</em>   </td></tr>
<tr>
<td><code><em>variable</em> += <em>elements</em> ;</code> </td><td>The += operator adds <em>elements</em> to <em>variable</em>'s list of elements  </td></tr>
<tr>
<td><code><em>variable</em> -= <em>elements</em> ;</code> </td><td>The -= operator removes <em>elements</em> from <em>variable</em>'s list of elements  </td></tr>
<tr>
<td><code><em>variable</em> ?= <em>elements</em> ;</code> </td><td>The ?= operator sets <em>variable</em> only if it was previously unset  </td></tr>
<tr>
<td><code><em>variable</em> on <em>targets</em> = <em>elements</em> ;</code> </td><td>The = operator replaces any previous elements of <em>variable</em> with <em>elements</em> directly on <em>targets</em>   </td></tr>
<tr>
<td><code><em>variable</em> on <em>targets</em> += <em>elements</em> ;</code> </td><td>The += operator directly adds <em>elements</em> to <em>targets</em>'s <em>variable</em>'s list of elements  </td></tr>
<tr>
<td><code><em>variable</em> on <em>targets</em> -= <em>elements</em> ;</code> </td><td>The -= operator directly removes <em>elements</em> from <em>targets</em>'s <em>variable</em>'s list of elements  </td></tr>
<tr>
<td><code><em>variable</em> on <em>targets</em> ?= <em>elements</em> ;</code> </td><td>The ?= operator sets <em>variable</em> on <em>targets</em> only if it was previously unset  </td></tr>
</table>
<p>Variables referenced in updating commands will be replaced with their values; target-specific values take precedence over global values. Variables passed as arguments ($(1) and $(2)) to actions are replaced with their bound values; the "bind" modifier can be used on actions to cause other variables to be replaced with bound values. See <a href="#actionmods">Action Modifiers</a> above.</p>
<p><b>Jam</b> variables are not re-exported to the environment of the shell that executes the updating actions, but the updating actions can reference <b>Jam</b> variables with $(<em>variable</em>).</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    # If myvar hasn&#39;t been assigned yet, assign the string list ab and cd.</span>
<span class="preprocessor"></span>    myvar ?= ab cd ;

<span class="preprocessor">    # Replace myvar&#39;s contents with ef and gh.</span>
<span class="preprocessor"></span>    myvar = ef gh ;

<span class="preprocessor">    # Add some additional elements to myvar.</span>
<span class="preprocessor"></span>    myvar += ij kl ;        # myvar = ef gh ij kl

<span class="preprocessor">    # Remove some elements from myvar.</span>
<span class="preprocessor"></span>    myvar -= gh kl ;        # myvar = ef ij

<span class="preprocessor">    # sometarget.myvar = zx cv</span>
<span class="preprocessor"></span>    myvar on sometarget = zx cv ;

<span class="preprocessor">    # This prints zx cv.</span>
<span class="preprocessor"></span>    on sometarget Echo $(myvar) ;

<span class="preprocessor">    # This prints ef ij, because myvar doesn&#39;t exist on anothertarget, and so it</span>
<span class="preprocessor"></span><span class="preprocessor">    # falls through to the global myvar.</span>
<span class="preprocessor">    on anothertarget Echo $(myvar) ;</span>
</pre></div><h2><a class="anchor" id="language_variable_expansion">
Variable Expansion</a></h2>
<p>During parsing, <b>Jam</b> performs variable expansion on each token that is not a keyword or rule name. Such tokens with embedded variable references are replaced with zero or more tokens. Variable references are of the form $(<em>variable</em>) or $(<em>variable:modifiers</em>), where <em>variable</em> is the variable name, and <em>modifiers</em> are optional modifiers.</p>
<p>A literal expansion is in the form @(<em>literal</em>) or @(<em>literal:modifiers</em>). Instead of expanding a variable's contents, as with a $(<em>variable</em>) expansion, the direct contents of <em>literal</em> are used. All other behavior is the same.</p>
<p>Variable expansion in a rule's actions is similar to variable expansion in statements, except that the action string is tokenized at whitespace regardless of quoting.</p>
<p>The result of a token after variable expansion is the <em>product</em> of the components of the token, where each component is a literal substring or a list substituting a variable reference. For example:</p>
<table  width="75%" align="center">
<tr>
<td><p class="starttd"><code> <br/>
$(X) -&gt; a b c <br/>
t$(X) -&gt; ta tb tc <br/>
$(X)z -&gt; az bz cz <br/>
$(X)-$(X) -&gt; a-a a-b a-c b-a b-b b-c c-a c-b c-c</code></p>
<p class="endtd"><code> </code>  </p>
</td></tr>
</table>
<p>The variable name and modifiers can themselves contain a variable reference, and this partakes of the product as well:</p>
<table  width="75%" align="center">
<tr>
<td><p class="starttd"><code> <br/>
$(X) -&gt; a b c <br/>
$(Y) -&gt; 1 2 <br/>
$(Z) -&gt; X Y <br/>
$($(Z)) -&gt; a b c 1 2</code></p>
<p class="endtd"><code> </code>  </p>
</td></tr>
</table>
<p>Because of this product expansion, if any variable reference in a token is undefined, the result of the expansion is an empty list. If any variable element is a null string, the result propagates the non-null elements:</p>
<table  width="75%" align="center">
<tr>
<td><p class="starttd"><code> <br/>
$(X) -&gt; a "" <br/>
$(Y) -&gt; "" 1 <br/>
$(Z) -&gt; <br/>
*$(X)$(Y)* -&gt; *a* *a1* ** *1* <br/>
*$(X)$(Z)* -&gt;</code></p>
<p class="endtd"><code> </code>  </p>
</td></tr>
</table>
<p><a class="anchor" id="variable_expansion_c"></a></p>
<p>A variable element's string value can be parsed into grist and filename-related components. Modifiers to a variable are used to select elements, select components, and replace components. Modifiers are applied in the order of the table below:</p>
<table  width="75%" border="1" align="center">
<tr>
<td><code> [<em>n</em>] </code> </td><td>Select element number <em>n</em> (starting at 1). If the variable contains fewer than <em>n</em> elements, the result is a zero-element list.  </td></tr>
<tr>
<td><code> [<em>n</em>-<em>m</em>] </code> </td><td>Select elements number <em>n</em> through <em>m</em>.  </td></tr>
<tr>
<td><code> [<em>n</em>-] </code> </td><td>Select elements number <em>n</em> through the last.  </td></tr>
<tr>
<td><code> :E=<em>value</em> </code> </td><td>Use <em>value</em> instead if the variable is unset. Note that <code>:E=</code> by itself doesn't mean anything.  </td></tr>
<tr>
<td><code> :A </code> </td><td>Expand a variable expansion within a string. When a string has been read from an external source and contains a variable in <code></code> or <code>@(var)</code> syntax, the <code>:A</code> modifier can be used to expand it as if it had been inline in the Jam script.  </td></tr>
<tr>
<td><code> :W[=<em>remove_path</em>] </code> </td><td>Populate the list with directory contents matching the string. If specified, <em>remove_path</em> is removed from the beginning of each found file.  </td></tr>
<tr>
<td><code> :T </code> </td><td>Expand the bound name of the target. Just as when expanding within an action, the BINDING is applied first. If LOCATE is set, it is used for the path. If not, SEARCH is used to look up the file.  </td></tr>
<tr>
<td><code> :C </code> </td><td>EsCapes the string as if it were a file path. On Windows, if the path has spaces, it is quoted. On other platforms, spaces, parentheses, and a few other special characters are escaped with a backslash.  </td></tr>
<tr>
<td><code> :B </code> </td><td>Select filename base.  </td></tr>
<tr>
<td><code> :B=<em>base</em> </code> </td><td>Replace the base part of file name with <em>base</em>.  </td></tr>
<tr>
<td><code> :S </code> </td><td>Select (last) filename suffix.  </td></tr>
<tr>
<td><code> :S=<em>suf</em> </code> </td><td>Replace the suffix of file name with <em>suf</em>.  </td></tr>
<tr>
<td><code> :M </code> </td><td>Select archive member name.  </td></tr>
<tr>
<td><code> :M=<em>mem</em> </code> </td><td>Replace the archive member name with <em>mem</em>.  </td></tr>
<tr>
<td><code> :D </code> </td><td>Select directory path.  </td></tr>
<tr>
<td><code> :D=<em>path</em> </code> </td><td>Replace directory with <em>path</em>.  </td></tr>
<tr>
<td><code> :P </code> </td><td>Select parent directory. On VMS, $(var:P) is the parent directory of $(var:D); on Unix and NT, $(var:P) and $(var:D) are the same.  </td></tr>
<tr>
<td><code> :G </code> </td><td>Select grist.  </td></tr>
<tr>
<td><code> :G=<em>grist</em> </code> </td><td>Replace grist with <em>grist</em>.  </td></tr>
<tr>
<td><code> :R=<em>root</em> </code> </td><td>Prepend <em>root</em> to the whole file name, if not already rooted.  </td></tr>
<tr>
<td><code> :U </code> </td><td>Replace lowercase characters with uppercase.  </td></tr>
<tr>
<td><code> :L </code> </td><td>Replace uppercase characters with lowercase.  </td></tr>
<tr>
<td><code> :/ </code> </td><td>Convert all backslashes (\) to forward slashes (/).  </td></tr>
<tr>
<td><code> :\\ </code> </td><td>Convert all forward slashes (/) to backslashes (\).  </td></tr>
<tr>
<td><code> :<em>chars</em> </code> </td><td>Select the components listed in <em>chars</em>.  </td></tr>
<tr>
<td><code> :J=<em>joinval</em> </code> </td><td>Concatenate list elements into single element, separated by <em>joinval</em>.  </td></tr>
<tr>
<td><code> :I=<em>regex</em> </code> </td><td>Include all list items matching <em>regex</em>. Remove everything else. More than one set of <code>:I</code> or <code>:X</code> modifiers may appear in a given expansion, and they are applied in order.  </td></tr>
<tr>
<td><code> :X=<em>regex</em> </code> </td><td>Exclude all list items matching <em>regex</em>. Keep everything else. More than one set of <code>:I</code> or <code>:X</code> modifiers may appear in a given expansion, and they are applied in order.  </td></tr>
</table>
<h2><a class="anchor" id="patterns_and_wildcards">
Patterns and Wildcards</a></h2>
<p>When using the <code>:W</code> modifier, the following file globbing syntax is available.</p>
<table  border="1" width="75%" align="center">
<tr>
<td width="150"><b>Wildcard</b> </td><td width="450"><b>Description</b>  </td></tr>
<tr>
<td><code>?</code> </td><td><p class="starttd">Matches any single character of the file name or directory name. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>*</code> </td><td>Matches 0 or more characters of the file name or directory name.  </td></tr>
<tr>
<td><p class="starttd"><code>/</code> at end of pattern</p>
<p class="endtd"></p>
</td><td>Any pattern with a closing slash will start a directory search, instead of the default file search.  </td></tr>
<tr>
<td><code>**</code> </td><td>Search files recursively.  </td></tr>
</table>
<p>Some examples follow:</p>
<table  border="1" width="75%" align="center">
<tr>
<td width="150"><b>Example Pattern</b> </td><td width="450"><p class="starttd"><b>Description</b> </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>File.txt</code> </td><td>Matches a file or directory called <em>File.txt</em>.  </td></tr>
<tr>
<td><p class="starttd"><code>File*.txt</code></p>
<p class="endtd"></p>
</td><td>Matches any file or directory starting with File and ending with a .txt extension.  </td></tr>
<tr>
<td><code>File?.txt</code> </td><td>Matches any file or directory starting with File and containing one more character.  </td></tr>
<tr>
<td><code>F??e*.txt</code> </td><td>Matches a file or directory starting with F, followed by any two characters, followed by e, then any number of characters up to the extension .txt.  </td></tr>
<tr>
<td><code>File*</code> </td><td><p class="starttd">Matches a file or directory starting with File and ending with or without an extension. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>*</code> </td><td>Matches all files (non-recursive).  </td></tr>
<tr>
<td><code>*/</code> </td><td><p class="starttd">Matches all directories (non-recursive).</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>A*/</code> </td><td>Matches any directory starting with A (non-recursive).  </td></tr>
<tr>
<td><p class="starttd"><code>**/*</code></p>
<p class="endtd"></p>
</td><td>Matches all files (recursive).  </td></tr>
<tr>
<td><code>**</code> </td><td>Shortened form of above. Matches all files (recursive). Internally, expands to **/*  </td></tr>
<tr>
<td><code>**/</code> </td><td>Matches all directories (recursive).  </td></tr>
<tr>
<td><code>**{filename chars}</code> </td><td><p class="starttd">Matches {filename chars} recursively. Internally, expands to **/*{filename chars}. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>{dirname chars}**</code> </td><td>Expands to {dirname chars}*/**.  </td></tr>
<tr>
<td><code>{dirname chars}**{filename chars}</code> </td><td><p class="starttd">Expands to {dirname chars}*/**/*{filename chars}.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>**.h</code> </td><td>Matches all *.h files recursively. Expands to **/*.h.  </td></tr>
<tr>
<td><p class="starttd"><code>**resource.h</code></p>
<p class="endtd"></p>
</td><td>Matches all *resource.h files recursively. Expands to **/*resource.h.  </td></tr>
<tr>
<td><code>BK**</code> </td><td>Matches all files in any directory starting with BK, recursively. Expands to BK*/**.  </td></tr>
<tr>
<td><code>BK**.h</code> </td><td>Matches all *.h files in any directory starting with BK, recursively. Expands to BK*/**/*.h.  </td></tr>
<tr>
<td><code>c:/Src/**/*.h</code> </td><td>Matches all *.h files recursively, starting at c:/Src/.  </td></tr>
<tr>
<td><code>c:/Src/**/*Grid/</code> </td><td>Recursively matches all directories under c:/Src/ that end with Grid.  </td></tr>
<tr>
<td><code>c:/Src/**/*Grid*/</code> </td><td>Recursively matches all directories under c:/Src/ that contain Grid.  </td></tr>
<tr>
<td><p class="starttd"><code>c:/Src/**/*Grid*/**/ABC/**/Readme.txt</code></p>
<p class="endtd"></p>
</td><td>Recursively matches all directories under c:/Src/ that contain Grid. From the found directory, recursively matches directories until ABC/ is found. From there, the file <em>Readme.txt</em> is searched for recursively.   </td></tr>
</table>
<p>Finally, a couple flags are available. Flags are appended at the end of the pattern line. Each flag begins with an @ character. Spaces should not be inserted between flags unless they are intended as part of the string literal.</p>
<table  border="1" width="75%" align="center">
<tr>
<td width="150"><b>Flags and Other Expansions</b> </td><td width="450"><b>Description</b>  </td></tr>
<tr>
<td><code>@-pattern</code> </td><td><p class="starttd">Adds <code>pattern</code> to the ignore list. Any file matching a pattern in the ignore list is discounted from the search. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>@=pattern</code> </td><td>Adds <code>pattern</code> to the exclusive file list. Any file not matching a pattern in the exclusive file list is automatically removed from the search.  </td></tr>
<tr>
<td>More than two periods for going up parent directories. </td><td>Similar to 4DOS, each period exceeding two periods goes up one additional parent directory. So, a 4 period path expands to <code>../../../.</code>  </td></tr>
</table>
<p>And a few examples:</p>
<table  border="1" width="75%" align="center">
<tr>
<td width="150"><b>Example Pattern</b> </td><td width="450"><b>Description</b>  </td></tr>
<tr>
<td><code>Src/**\/@-.git/@-.svn/</code> </td><td>Recursively lists all directories under Src/, but directories called .git/ and .svn/ are filtered.  </td></tr>
<tr>
<td><code>Src/**@=*.lua@=README</code> </td><td>Recursively lists all files under Src/ which match *.lua or README. All other files are ignored.  </td></tr>
<tr>
<td><code>Src/**\/@-.git/@-.svn/@=*.lua@=README</code> </td><td>Recursively lists all files under Src/ which match *.lua or README. The versions of those files that may exist in .git/ or .svn/ are ignored.  </td></tr>
</table>
<h2><a class="anchor" id="variable_expansion_examples">
Variable Expansion Examples</a></h2>
<div class="fragment"><pre class="fragment">    var = ab cd ef gh ij kl ;

    Echo $(var) ;                     # ab cd ef gh ij kl
    Echo $(var[0]) ;                  # ab
    Echo $(var[2]) ;                  # cd
    Echo $(var[6]) ;                  # kl
    Echo $(var[7]) ;                  #

    Echo $(var[1-]) ;                 # ab cd ef gh ij kl
    Echo $(var[2-]) ;                 # cd ef gh ij kl
    Echo $(var[6-]) ;                 # kl
    Echo $(var[7-]) ;                 #

    Echo $(var[1-7]) ;                # ab cd ef gh ij kl
    Echo $(var[2-6]) ;                # cd ef gh ij kl
    Echo $(var[3-5]) ;                # ef gh ij
    Echo $(var[6-4]) ;                # kl

<span class="preprocessor">    #------------------------------------------------------------------------------</span>
<span class="preprocessor"></span>    Echo $(VAR:E=**empty**) ;         # empty

    EMPTY_TEXT = some empty text ;
    Echo $(VAR:E=$(EMPTY_TEXT)) ;     # some empty text

<span class="preprocessor">    #------------------------------------------------------------------------------</span>
<span class="preprocessor"></span>    list = list of characters to put stuff in between ;
    local var1 = $ ;
    local var2 = (list) ;
    local var1_var2 = $(var1)$(var2) ;
    Echo $(var1_var2) ;               # $(list)
    Echo $(var1_var2:A) ;             # list of characters to put stuff in between
    Echo @($(var1)$(var2):A) ;        # list of characters to put stuff in between

<span class="preprocessor">    #------------------------------------------------------------------------------</span>
<span class="preprocessor"></span>    FILE = somefile.txt ;
    Echo $(FILE:T) ;                  # somefile.txt

    LOCATE on $(FILE) = /somewhere/on/the/hard/drive ;
    Echo $(FILE:T) ;                  # /somewhere/on/the/hard/drive/somefile.txt

    BINDING on $(FILE) = newname.txt ;
    Echo $(FILE:T) ;                  # /somewhere/on/the/hard/drive/newname.txt

    BINDING on $(FILE) = ;
    SEARCH on $(FILE) = data ;
    LOCATE on $(FILE) = /somewhere/on/the/hard/drive ;
    Echo $(FILE:T) ;                  # /somewhere/on/the/hard/drive/somefile.txt

    LOCATE on $(FILE) = ;
    Echo $(FILE:T) ;                  # data/somefile.txt

<span class="preprocessor">    #------------------------------------------------------------------------------</span>
<span class="preprocessor"></span>    FILENAME = &lt;thegrist&gt;c:/some/directory/filename.txt ;
    Echo $(FILENAME:B) ;              # filename
    Echo $(FILENAME:B=anothername) ;  # &lt;thegrist&gt;c:/some/directory/anothername.txt
    Echo $(FILENAME:S) ;              # .txt
    Echo $(FILENAME:S=.dat) ;         # &lt;thegrist&gt;c:/some/directory/filename.dat
    Echo $(FILENAME:BS) ;             # filename.txt
    Echo $(FILENAME:B=anothername:S=.dat) ;  # &lt;thegrist&gt;c:/some/directory/anothername.dat
    Echo $(FILENAME:D) ;              # c:/some/directory
    Echo $(FILENAME:D=/usr/bin) ;     # &lt;thegrist&gt;/usr/bin/filename.txt
    Echo $(FILENAME:P) ;              # &lt;thegrist&gt;c:/some/directory
    Echo @($(FILENAME:P):P) ;         # &lt;thegrist&gt;c:/some

    Echo $(FILENAME:G) ;              # &lt;thegrist&gt;
    Echo $(FILENAME:G=anothergrist) ; # &lt;anothergrist&gt;c:/some/directory/filename.txt

    NEW_ROOT = d:/root/directory ;
    Echo $(FILENAME:R=<span class="stringliteral">&quot;d:/root/directory&quot;</span>) ; # &lt;thegrist&gt;c:/some/directory/filename.txt
    Echo @(filename.txt:R=$(NEW_ROOT)) ;     # d:/root/directory/filename.txt

    Echo @(lowercase_now_uppercase:U) ;      # LOWERCASE_NOW_UPPERCASE
    Echo @(UPPERCASE_NOW_LOWERCASE:L) ;      # uppercase_now_lowercase ;

    Echo @(backslash\\path\\:/) ;            # backslash/path/
    Echo $(FILENAME:\\) ;                    # &lt;thegrist&gt;c:\\some\\directory\\filename.txt

    Echo $(FILENAME:DBS) ;                   # c:/some/directory/filename.txt

    VAR = /home/stuff/file.txt ;
    Echo $(VAR:DB:U) ;                       # /HOME/STUFF/FILE

<span class="preprocessor">    #------------------------------------------------------------------------------</span>
<span class="preprocessor"></span><span class="preprocessor">    # Assuming ../sharedlib/app has the files Jamfile.jam and main.c:</span>
<span class="preprocessor"></span>    Echo @(../sharedlib/app<span class="comment">/*:WBS) ;         # Jamfile.jam main.c</span>
<span class="comment">    Echo @(@(../sharedlib/app/*:W):BS) ;     # Jamfile.jam main.c</span>
<span class="comment"></span>
<span class="comment">    Echo @(../sharedlib/app</span><span class="comment">/**:WB=more\\dir\\file:\\) ;</span>
<span class="comment">                                            # ..\\sharedlib\\app\\more\\dir\\file.jam</span>
<span class="comment">                                            # ..\\sharedlib\\app\\more\\dir\\file.c</span>
<span class="comment"></span>
<span class="comment">    Echo @(../sharedlib/app</span><span class="comment">/**:W=../sharedlib/:B=more\\dir\\file:\\) ;</span>
<span class="comment">                                            # app\\more\\dir\\file.jam</span>
<span class="comment">                                            # app\\more\\dir\\file.c</span>
<span class="comment"></span>
<span class="comment"></span>
<span class="comment">    #------------------------------------------------------------------------------</span>
<span class="comment">    top = AppRoot ;</span>
<span class="comment">    jamfile = Jamfile.jam ;</span>
<span class="comment">    Echo included_$(top:J=_)_$(jamfile) ;    # included_AppRoot_Jamfile.jam</span>
<span class="comment"></span>
<span class="comment">    #------------------------------------------------------------------------------</span>
<span class="comment">    top = AppRoot With Directories ;</span>
<span class="comment">    jamfile = SomeFile.jam ;</span>
<span class="comment">    Echo included_$(top:J=_)_$(jamfile) ;    # included_AppRoot_With_Directories_SomeFile.jam</span>
<span class="comment"></span>
<span class="comment">    #------------------------------------------------------------------------------</span>
<span class="comment">    Echo $(list:J=!) ;                # list!of!characters!to!put!stuff!in!between</span>
<span class="comment"></span>
<span class="comment">    #------------------------------------------------------------------------------</span>
<span class="comment">    FILES = file1.c file2.c file3.c file1.h file2.h file3.h file1.obj file2.obj file3.obj ;</span>
<span class="comment">    Echo $(FILES:I=\\.c$) ;           # file1.c file2.c file3.c</span>
<span class="comment"></span>
<span class="comment">    Echo $(FILES:I=\\.c$:I=\\.obj:X=&quot;^file1&quot;) ;</span>
<span class="comment">                                    # file2.c file3.c file2.obj file3.obj</span>
<span class="comment"></span>
<span class="comment">    Echo $(FILES:I=\\.c$:I=\\.obj:X=&quot;^file1&quot;:X=\\.c$:I=\\.c$) ;</span>
<span class="comment">                                    # file1.c file2.c file3.c file2.obj file3.obj</span>
<span class="comment"></span>
<span class="comment">    Echo $(FILES:I=\\.c$:I=\\.obj:X=&quot;^file1&quot;:X=\\.c$) ;</span>
<span class="comment">                                    # file2.obj file3.obj</span>
<span class="comment"></span>
<span class="comment">    Echo $(FILES:X=&quot;^file1&quot;:X=\\.obj$:I=\\.h$) ;</span>
<span class="comment">                                    # file1.h file2.h file3.h</span>
</pre></div> </div>
</body>
</html>

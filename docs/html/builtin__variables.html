<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>JamPlus manual: Built-in Variables</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="contents">


<h1><a class="anchor" id="builtin_variables">Built-in Variables </a></h1><h2><a class="anchor" id="builtin_variables_intro">
Introduction</a></h2>
<p>This section discusses variables that have special meaning to <b>Jam</b>.</p>
<h2><a class="anchor" id="built_in_variables_binding_binding_search_locate">
BINDING, SEARCH, and LOCATE Variables</a></h2>
<p>These variables control the binding of file target names to locations in the file system. Generally, $(SEARCH) is used to find existing sources while $(LOCATE) is used to fix the location for built targets.</p>
<p>Rooted (absolute path) file targets are bound as is. Unrooted file target names are also normally bound as is, and thus relative to the current directory, but the settings of $(LOCATE) and $(SEARCH) alter this:</p>
<ul>
<li>
If $(LOCATE) is set then the target is bound relative to the first directory in . Only the first element is used for binding. </li>
<li>
If $(SEARCH) is set then the target is bound to the first directory in $(SEARCH) where the target file already exists. </li>
<li>
If the $(SEARCH) search fails, the target is bound relative to the current directory anyhow. </li>
</ul>
<p>Both $(SEARCH) and $(LOCATE) should be set target-specific and not globally. If they were set globally, <b>jam</b> would use the same paths for all file binding, which is not likely to produce sane results. When writing your own rules, especially ones not built upon those in Jambase, you may need to set $(SEARCH) or $(LOCATE) directly. Almost all of the rules defined in Jambase set $(SEARCH) and $(LOCATE) to sensible values for sources they are looking for and targets they create, respectively.</p>
<h2><a class="anchor" id="built_in_variables_hdrscan">
Header Scanning Variables</a></h2>
<p>The <code>HDRSCAN</code> and <code>HDRPATTERN</code> variables control the default header file scanning. HDRSCAN is an <b>egrep</b>(1) pattern, with ()'s surrounding the file name, used to find file inclusion statements in source files. Jambase uses <code>$(HDRPATTERN)</code> as the pattern for <code>HDRSCAN</code>. <code>HDRRULE</code> is the name of a rule to invoke with the results of the scan: the scanned file is the target, the found files are the sources, the bound name of the target is in the third argument. <code>HDRRULE</code> is run under the influence of the scanned file's target-specific variables. It defaults to the Jambase <code>HdrRule</code>.</p>
<p>Both <code>HDRSCAN</code> and <code>HDRRULE</code> must be set for header file scanning to take place, and they should be set target-specific and not globally. If they were set globally, all files, including executables and libraries, would be scanned for header file include statements.</p>
<p>The scanning for header file inclusions is not exact, but it is at least dynamic, so there is no need to run something like <b>makedepend</b>(GNU) to create a static dependency file. The scanning mechanism errs on the side of inclusion (i.e., it is more likely to return filenames that are not actually used by the compiler than to miss include files) because it can't tell if #include lines are inside #ifdefs or other conditional logic. In Jambase, HdrRule applies the <a class="el" href="builtin__rules.html#rule_NoCare">NoCare</a> rule to each header file found during scanning so that if the file isn't present yet doesn't cause the compilation to fail, <b>Jam</b> won't care.</p>
<p>Also, scanning for regular expressions only works where the included file name is literally in the source file. It can't handle languages that allow including files using variable names (as the Jam language itself does).</p>
<p>On Windows, header filenames are, by default, converted to lowercase. This can be prevented by setting a target's <code>HDRDOWNSHIFT</code> variable to <code>false</code>.</p>
<h3><a class="anchor" id="built_in_variables_hdrfilter">
Filtering Unwanted Dependencies</a></h3>
<p>When <code>HDRFILTER</code> is set on a target, the rule bearing the name specified in the contents of <code>HDRFILTER</code> is executed with the following signature.</p>
<div class="fragment"><pre class="fragment">    rule DoHeaderFilter TARGET_NAME : DEPENDENCIES : TARGET_BOUNDNAME
    {
<span class="preprocessor">        # Filter any unwanted dependencies.</span>
<span class="preprocessor"></span>        DEPENDENCIES -= bob fred ;
        <span class="keywordflow">return</span> $(DEPENDENCIES) ;
    }
</pre></div><p><code>HDRFILTER</code> can also be used to translate dependency names:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    # Reading our special file format, DEPENDENCIES may come in as $(environment_variable)/filename.</span>
<span class="preprocessor"></span><span class="preprocessor">    # Translate it.</span>
<span class="preprocessor"></span>    rule DoHeaderFilter TARGET_NAME : DEPENDENCIES : TARGET_BOUNDNAME
    {
<span class="preprocessor">        # Filter any unwanted dependencies.</span>
<span class="preprocessor"></span>        DEPENDENCIES = $(DEPENDENCIES:A) ;
        <span class="keywordflow">return</span> $(DEPENDENCIES) ;
    }
</pre></div><h3><a class="anchor" id="built_in_variables_hdrpipe">
Shelling Processes for Dependencies</a></h3>
<p>When <code>HDRPIPE</code> is set on a target, during the dependency scan for headers, the process command line specified by <code>HDRPIPE</code> is run. Any dependencies written by the process to stdout are run through the normal <code>HDRSCAN</code> regular expression mechanism.</p>
<p>If <code>HDRPIPEFILE</code> is set on the target, the filename specified by <code>HDRPIPEFILE</code> is opened and parsed for dependencies after the <code>HDRPIPE</code> process exits.</p>
<h2><a class="anchor" id="built_in_variables_semaphore">
Semaphores</a></h2>
<p>At times, it is necessary to synchronize access in a multiprocessor build. The <code>SEMAPHORE</code> variable, when set on a target to be built, does just that. When the given <code>SEMAPHORE</code> value is in use by another target, any targets with the same <code>SEMAPHORE</code> will block until the currently building target is finished and releases the <code>SEMAPHORE</code> lock.</p>
<p>Example: The Visual C++ compiler accesses the same .pdb and .idb files. To prevent that, a <code>SEMAPHORE</code> is used:</p>
<div class="fragment"><pre class="fragment">    SEMAPHORE on $(objects) = $(LOCATE_TARGET)/$(_VCPDB).pdb ;
</pre></div><h2><a class="anchor" id="built_in_variables_platform">
Platform Identifier Variables</a></h2>
<p>A number of Jam built-in variables can be used to identify runtime platform:</p>
<table  width="75%" align="center">
<tr>
<td>OS</td><td>OS identifier string </td></tr>
<tr>
<td>OSPLAT</td><td>Underlying architecture, when applicable </td></tr>
<tr>
<td>MAC</td><td>true on MAC platform </td></tr>
<tr>
<td>NT</td><td>true on NT platform </td></tr>
<tr>
<td>OS2</td><td>true on OS2 platform </td></tr>
<tr>
<td>UNIX</td><td>true on Unix platforms </td></tr>
<tr>
<td>VMS</td><td>true on VMS platform </td></tr>
</table>
<h2><a class="anchor" id="language_built_in_variables_version">
Jam Version Variables</a></h2>
<table  width="75%" align="center">
<tr>
<td>JAMDATE</td><td>Time and date at <b>jam</b> start-up. </td></tr>
<tr>
<td>JAMUNAME</td><td>Ouput of <b>uname</b>(1) command (Unix only) </td></tr>
<tr>
<td>JAMVERSION</td><td><b>jam</b> version, as reported by jam -v. </td></tr>
</table>
<h2><a class="anchor" id="language_built_in_variables_misc">
Miscellaneous Variables</a></h2>
<table  width="75%" align="center">
<tr>
<td>CWD</td><td>The current working directory. </td></tr>
<tr>
<td>JAM_COMMAND_LINE_TARGETS</td><td>The list of all targets passed into Jam on the command line. If no targets were passed, <code>JAM_COMMAND_LINE_TARGETS</code> defaults to <b>all</b>. </td></tr>
<tr>
<td>JAM_PROCESS_PATH</td><td>The path where the Jam executable resides. </td></tr>
<tr>
<td>PATHDELIM_OLDSTYLE</td><td>In JamPlus, the default path separator is a forward slash. If <code>PATHDELIM_OLDSTYLE</code> is set to 1, the default path separator is OS-specific, and the behavior mirrors the original Perforce Jam. </td></tr>
</table>
<h2><a class="anchor" id="built_in_variables_jamshell">
JAMSHELL Variable</a></h2>
<p>When <b>jam</b> executes a rule's action block, it forks and execs a shell, passing the action block as an argument to the shell. The invocation of the shell can be controlled by $(JAMSHELL). The default on Unix is, for example:</p>
<p><code>JAMSHELL = /bin/sh -c % ;</code></p>
<p>The % is replaced with the text of the action block.</p>
<p><b>Jam</b> does not directly support building in parallel across multiple hosts, since that is heavily dependent on the local environment. To build in parallel across multiple hosts, you need to write your own shell that provides access to the multiple hosts. You then reset  to reference it.</p>
<p>Just as <b>jam</b> expands a % to be the text of the rule's action block, it expands a ! to be the multi-process slot number. The slot number varies between 1 and the number of concurrent jobs permitted by the -j flag given on the command line. Armed with this, it is possible to write a multiple host shell. For example:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #!/bin/sh</span>
<span class="preprocessor"></span>
<span class="preprocessor">    # This sample JAMSHELL uses the SunOS on(1) command to execute a</span>
<span class="preprocessor"></span><span class="preprocessor">    # command string with an identical environment on another host.</span>
<span class="preprocessor"></span>
<span class="preprocessor">    # Set JAMSHELL = jamshell ! %</span>
<span class="preprocessor"></span><span class="preprocessor">    #</span>
<span class="preprocessor"></span><span class="preprocessor">    # where jamshell is the name of this shell file.</span>
<span class="preprocessor"></span><span class="preprocessor">    #</span>
<span class="preprocessor"></span><span class="preprocessor">    # This version handles up to -j6; after that they get executed</span>
<span class="preprocessor"></span><span class="preprocessor">    # locally.</span>
<span class="preprocessor"></span>
    <span class="keywordflow">case</span> $1 in
    1|4) on winken sh -c <span class="stringliteral">&quot;$2&quot;</span>;;
    2|5) on blinken sh -c <span class="stringliteral">&quot;$2&quot;</span>;;
    3|6) on nod sh -c <span class="stringliteral">&quot;$2&quot;</span>;;
    *)   eval <span class="stringliteral">&quot;$2&quot;</span>;;
    esac
</pre></div><hr/>
 </div>
</body>
</html>

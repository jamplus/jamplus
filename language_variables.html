<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Variables</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.8.9.1 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Variables </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="language_variable_basics"></a>
Basics</h1>
<p><b>Jam</b> variables are lists of zero or more elements, with each element being a string value. An undefined variable is indistinguishable from a variable with an empty list, however, a defined variable may have one more elements which are null strings. All variables are referenced as $(<em>variable</em>).</p>
<p>Variables are either global or target-specific. In the latter case, the variable takes on the given value only during the target's binding, header file scanning, and updating; and during the "on &lt;i&gt;target&lt;/i&gt; &lt;i&gt;statement&lt;/I&gt;" statement.</p>
<p>A variable is defined with:</p>
<table  align="center">
<tr>
<td><code><em>variable</em> = <em>elements</em> ;</code> </td><td>The = operator replaces any previous elements of <em>variable</em> with <em>elements</em>   </td></tr>
<tr>
<td><code><em>variable</em> += <em>elements</em> ;</code> </td><td>The += operator adds <em>elements</em> to <em>variable</em>'s list of elements  </td></tr>
<tr>
<td><code><em>variable</em> -= <em>elements</em> ;</code> </td><td>The -= operator removes <em>elements</em> from <em>variable</em>'s list of elements  </td></tr>
<tr>
<td><code><em>variable</em> ?= <em>elements</em> ;</code> </td><td>The ?= operator sets <em>variable</em> only if it was previously unset  </td></tr>
<tr>
<td><code><em>variable</em> on <em>targets</em> = <em>elements</em> ;</code> </td><td>The = operator replaces any previous elements of <em>variable</em> with <em>elements</em> directly on <em>targets</em>   </td></tr>
<tr>
<td><code><em>variable</em> on <em>targets</em> += <em>elements</em> ;</code> </td><td>The += operator directly adds <em>elements</em> to <em>targets</em>'s <em>variable</em>'s list of elements  </td></tr>
<tr>
<td><code><em>variable</em> on <em>targets</em> -= <em>elements</em> ;</code> </td><td>The -= operator directly removes <em>elements</em> from <em>targets</em>'s <em>variable</em>'s list of elements  </td></tr>
<tr>
<td><code><em>variable</em> on <em>targets</em> ?= <em>elements</em> ;</code> </td><td>The ?= operator sets <em>variable</em> on <em>targets</em> only if it was previously unset  </td></tr>
</table>
<p>Variables referenced in updating commands will be replaced with their values; target-specific values take precedence over global values. Variables passed as arguments ($(1) and $(2)) to actions are replaced with their bound values; the "bind" modifier can be used on actions to cause other variables to be replaced with bound values. See <a href="#actionmods">Action Modifiers</a> above.</p>
<p><b>Jam</b> variables are not re-exported to the environment of the shell that executes the updating actions, but the updating actions can reference <b>Jam</b> variables with $(<em>variable</em>).</p>
<div class="fragment"><div class="line"><span class="preprocessor"># If myvar hasn&#39;t been assigned yet, assign the string list ab and cd.</span></div>
<div class="line">myvar ?= ab cd ;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor"># Replace myvar&#39;s contents with ef and gh.</span></div>
<div class="line">myvar = ef gh ;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor"># Add some additional elements to myvar.</span></div>
<div class="line">myvar += ij kl ;        # myvar = ef gh ij kl</div>
<div class="line"></div>
<div class="line"><span class="preprocessor"># Remove some elements from myvar.</span></div>
<div class="line">myvar -= gh kl ;        # myvar = ef ij</div>
<div class="line"></div>
<div class="line"><span class="preprocessor"># sometarget.myvar = zx cv</span></div>
<div class="line">myvar on sometarget = zx cv ;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor"># This prints zx cv.</span></div>
<div class="line">on sometarget Echo $(myvar) ;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor"># This prints ef ij, because myvar doesn&#39;t exist on anothertarget, and so it</span></div>
<div class="line"><span class="preprocessor"># falls through to the global myvar.</span></div>
<div class="line"><span class="preprocessor">on anothertarget Echo $(myvar) ;</span></div>
</div><!-- fragment --><h1><a class="anchor" id="language_variable_expansion"></a>
Variable Expansion</h1>
<p>During parsing, <b>Jam</b> performs variable expansion on each token that is not a keyword or rule name. Such tokens with embedded variable references are replaced with zero or more tokens. Variable references are of the form $(<em>variable</em>) or $(<em>variable:modifiers</em>), where <em>variable</em> is the variable name, and <em>modifiers</em> are optional modifiers.</p>
<p>A literal expansion is in the form @(<em>literal</em>) or @(<em>literal:modifiers</em>) or alternatively as $@(<em>literal</em>) or $@(<em>literal:modifiers</em>). Instead of expanding a variable's contents, as with a $(<em>variable</em>) expansion, the direct contents of <em>literal</em> are used. All other behavior is the same.</p>
<p>Variable expansion in a rule's actions is similar to variable expansion in statements, except that the action string is tokenized at whitespace regardless of quoting.</p>
<p>The result of a token after variable expansion is the <em>product</em> of the components of the token, where each component is a literal substring or a list substituting a variable reference. For example:</p>
<table  width="75%" align="center">
<tr>
<td><p class="starttd"><code> <br />
$(X) -&gt; a b c <br />
t$(X) -&gt; ta tb tc <br />
$(X)z -&gt; az bz cz <br />
$(X)-$(X) -&gt; a-a a-b a-c b-a b-b b-c c-a c-b c-c</code></p>
<p class="endtd"><code> </code>  </p>
</td></tr>
</table>
<p>The variable name and modifiers can themselves contain a variable reference, and this partakes of the product as well:</p>
<table  width="75%" align="center">
<tr>
<td><p class="starttd"><code> <br />
$(X) -&gt; a b c <br />
$(Y) -&gt; 1 2 <br />
$(Z) -&gt; X Y <br />
$($(Z)) -&gt; a b c 1 2</code></p>
<p class="endtd"><code> </code>  </p>
</td></tr>
</table>
<p>Because of this product expansion, if any variable reference in a token is undefined, the result of the expansion is an empty list. If any variable element is a null string, the result propagates the non-null elements:</p>
<table  width="75%" align="center">
<tr>
<td><p class="starttd"><code> <br />
$(X) -&gt; a "" <br />
$(Y) -&gt; "" 1 <br />
$(Z) -&gt; <br />
*$(X)$(Y)* -&gt; <em>a</em> <em>a1</em> ** <em>1</em> <br />
*$(X)$(Z)* -&gt;</code></p>
<p class="endtd"><code> </code>  </p>
</td></tr>
</table>
<p><a class="anchor" id="variable_expansion_c"></a> A variable element's string value can be parsed into grist and filename-related components. Modifiers to a variable are used to select elements, select components, and replace components. Modifiers are applied in the order of the table below:</p>
<table  width="75%" border="1" align="center">
<tr>
<td><code> [<em>n</em>] </code> </td><td>Select element number <em>n</em> (starting at 1). If the variable contains fewer than <em>n</em> elements, the result is a zero-element list.  </td></tr>
<tr>
<td><code> [<em>n</em>-<em>m</em>] </code> </td><td>Select elements number <em>n</em> through <em>m</em>.  </td></tr>
<tr>
<td><code> [<em>n</em>-] </code> </td><td>Select elements number <em>n</em> through the last.  </td></tr>
<tr>
<td><code> :E=<em>value</em> </code> </td><td>Use <em>value</em> instead if the variable is unset. Note that <code>:E=</code> by itself doesn't mean anything.  </td></tr>
<tr>
<td><code> :A </code> </td><td>Expand a variable expansion within a string. When a string has been read from an external source and contains a variable in <code></code> or <code>@(var)</code> syntax, the <code>:A</code> modifier can be used to expand it as if it had been inline in the Jam script.  </td></tr>
<tr>
<td><code> :W[=<em>remove_path</em>] </code> </td><td>Populate the list with directory contents matching the string. If specified, <em>remove_path</em> is removed from the beginning of each found file.  </td></tr>
<tr>
<td><code> :T </code> </td><td>Expand the bound name of the target. Just as when expanding within an action, the BINDING is applied first. If LOCATE is set, it is used for the path. If not, SEARCH is used to look up the file.  </td></tr>
<tr>
<td><code> :C </code> </td><td>EsCapes the string as if it were a file path. On Windows, if the path has spaces, it is quoted. On other platforms, spaces, parentheses, and a few other special characters are escaped with a backslash.  </td></tr>
<tr>
<td><code> :B </code> </td><td>Select filename base.  </td></tr>
<tr>
<td><code> :B=<em>base</em> </code> </td><td>Replace the base part of file name with <em>base</em>.  </td></tr>
<tr>
<td><code> :S </code> </td><td>Select (last) filename suffix.  </td></tr>
<tr>
<td><code> :S=<em>suf</em> </code> </td><td>Replace the suffix of file name with <em>suf</em>.  </td></tr>
<tr>
<td><code> :M </code> </td><td>Select archive member name.  </td></tr>
<tr>
<td><code> :M=<em>mem</em> </code> </td><td>Replace the archive member name with <em>mem</em>.  </td></tr>
<tr>
<td><code> :D </code> </td><td>Select directory path.  </td></tr>
<tr>
<td><code> :D=<em>path</em> </code> </td><td>Replace directory with <em>path</em>.  </td></tr>
<tr>
<td><code> :P </code> </td><td>Select parent directory. On VMS, $(var:P) is the parent directory of $(var:D); on Unix and NT, $(var:P) and $(var:D) are the same.  </td></tr>
<tr>
<td><code> :G </code> </td><td>Select grist.  </td></tr>
<tr>
<td><code> :G=<em>grist</em> </code> </td><td>Replace grist with <em>grist</em>.  </td></tr>
<tr>
<td><code> :R=<em>root</em> </code> </td><td>Prepend <em>root</em> to the whole file name, if not already rooted.  </td></tr>
<tr>
<td><code> :U </code> </td><td>Replace lowercase characters with uppercase.  </td></tr>
<tr>
<td><code> :L </code> </td><td>Replace uppercase characters with lowercase.  </td></tr>
<tr>
<td><code> :/ </code> </td><td>Convert all backslashes (\) to forward slashes (/).  </td></tr>
<tr>
<td><code> :\\ </code> </td><td>Convert all forward slashes (/) to backslashes (\).  </td></tr>
<tr>
<td><code> :<em>chars</em> </code> </td><td>Select the components listed in <em>chars</em>.  </td></tr>
<tr>
<td><code> :J=<em>joinval</em> </code> </td><td>Concatenate list elements into single element, separated by <em>joinval</em>.  </td></tr>
<tr>
<td><code> :I=<em>regex</em> </code> </td><td>Include all list items matching <em>regex</em>. Remove everything else. More than one set of <code>:I</code> or <code>:X</code> modifiers may appear in a given expansion, and they are applied in order.  </td></tr>
<tr>
<td><code> :X=<em>regex</em> </code> </td><td>Exclude all list items matching <em>regex</em>. Keep everything else. More than one set of <code>:I</code> or <code>:X</code> modifiers may appear in a given expansion, and they are applied in order.  </td></tr>
</table>
<h1><a class="anchor" id="patterns_and_wildcards"></a>
Patterns and Wildcards</h1>
<p>When using the <code>:W</code> modifier, the following file globbing syntax is available.</p>
<table  border="1" width="75%" align="center">
<tr>
<td width="150"><b>Wildcard</b> </td><td width="450"><b>Description</b>  </td></tr>
<tr>
<td><code>?</code> </td><td><p class="starttd">Matches any single character of the file name or directory name. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>*</code> </td><td>Matches 0 or more characters of the file name or directory name.  </td></tr>
<tr>
<td><p class="starttd"><code>/</code> at end of pattern</p>
<p class="endtd"></p>
</td><td>Any pattern with a closing slash will start a directory search, instead of the default file search.  </td></tr>
<tr>
<td><code>**</code> </td><td>Search files recursively.  </td></tr>
</table>
<p>Some examples follow:</p>
<table  border="1" width="75%" align="center">
<tr>
<td width="150"><b>Example Pattern</b> </td><td width="450"><p class="starttd"><b>Description</b> </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>File.txt</code> </td><td>Matches a file or directory called <em>File.txt</em>.  </td></tr>
<tr>
<td><p class="starttd"><code>File*.txt</code></p>
<p class="endtd"></p>
</td><td>Matches any file or directory starting with File and ending with a .txt extension.  </td></tr>
<tr>
<td><code>File?.txt</code> </td><td>Matches any file or directory starting with File and containing one more character.  </td></tr>
<tr>
<td><code>F??e*.txt</code> </td><td>Matches a file or directory starting with F, followed by any two characters, followed by e, then any number of characters up to the extension .txt.  </td></tr>
<tr>
<td><code>File*</code> </td><td><p class="starttd">Matches a file or directory starting with File and ending with or without an extension. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>*</code> </td><td>Matches all files (non-recursive).  </td></tr>
<tr>
<td><code>* </code></td></tr>
</table>
</div></div><!-- contents -->
</body>
</html>

# The majority of the Android toolchain in android-shared.jam was provided
# by Steven Craft via a forum posting at http://jamplus.org/boards/1/topics/403.
#
# It has been updated from the original posting to work against the JamPlus
# toolchain support. Some functionality has been renamed.

rule C.Toolchain.clang.android-shared {
}

ANDROID.USE_GRADLE ?= 1 ;

if $(NT) {

actions C.android.clang.Link {
    PATH=$(C.LINK[1]:D);$(EXTRA_LINK_PATH);%PATH%
    $(C.LINK:C) $(LINKFLAGS) -o $(<[1]:C) @^^^($(>:J=$(NEWLINE))) $(NEEDLIBS:TC) $(LINKLIBS:TC)
}

} else {

actions C.android.clang.Link {
    PATH=$(C.LINK[1]:D):$(EXTRA_LINK_PATH):%PATH%
    "$(C.LINK)" -o $(<[1]:C) $(>:C) $(NEEDLIBS:TC) $(LINKLIBS:TC) $(LINKFLAGS)
}

} # if $(NT)


rule android.NDK.FindHighestVersion NDK_ROOT : NDK_VERSION {
    local dirs = [ Glob $(NDK_ROOT) : */ ] ;
    local highestMajor = 0 ;
    local highestMinor = 0 ;
    local highestBuild = 0 ;
    local dir ;
    for dir in @($(dirs:P):D=) {
        local ndk-build = [ Glob $(NDK_ROOT)/$(dir) : ndk-build ndk-build.cmd ] ;
        if $(ndk-build) {
            local version = [ Match ([0-9]*)\.([0-9]*)\.([0-9]*) : $(dir) ] ;
            if [ Math $(version[1]) ">" $(highestMajor) ] = 1 {
                highestMajor = $(version[1]) ;
                highestMinor = $(version[2]) ;
                highestBuild = $(version[3]) ;
            } else if [ Math $(version[1]) "=" $(highestMajor) ] = 1 {
                if [ Math $(version[2]) ">" $(highestMinor) ] = 1 {
                    highestMinor = $(version[2]) ;
                    highestBuild = $(version[3]) ;
                } else if [ Math $(version[2]) "=" $(highestMinor) ] = 1 {
                    if [ Math $(version[3]) ">" $(highestBuild) ] = 1 {
                        highestBuild = $(version[3]) ;
                    }
                }
            }
        }
    }

    if $(highestMajor) = 0  &&  $(highestMinor) = 0  &&  $(highestBuild) = 0 {
        return ;
    }

    return $(highestMajor).$(highestMinor).$(highestBuild) ;
}


rule android.SDK SDK_VERSION : NDK_VERSION : ARCHITECTURE {
    ARCHITECTURE ?= $(C.ARCHITECTURE:E=armv7-a) ;
    C.ARCHITECTURE ?= $(ARCHITECTURE) ;
    SDK_VERSION ?= 30 ;
    NDK_VERSION ?= 30 ;

    if $(OS) in MACOSX {
        local ndkRoot = $(NDKROOT:J=" ") ;
        ndkRoot ?= $(NDKROOT:Z=$(C.COMPILER_SUITE_SYMBOL)) ;
        if ! $(ndkRoot) {
            local androidStudioNDK = $(HOME)/Library/Android/sdk/ndk ;
            local androidStudioHighestVersion = [ android.NDK.FindHighestVersion $(androidStudioNDK) ] ;
            if $(androidStudioHighestVersion) {
                ndkRoot = $(androidStudioNDK)/$(androidStudioHighestVersion) ;
                NDK_VERSION_COMPLETE on $(C.COMPILER_SUITE_SYMBOL) = $(androidStudioHighestVersion) ;
            } else {
                local PATHS =
                    $(HOME)/Library/Android/
                    $(HOME)/
                ;

                local PATH_SUFFIXES =
                    android-ndk
                    android-ndk-r21d
                    android-ndk-r18b
                    android-ndk-r14b
                    android-ndk-r12b
                ;

                local ndk-build = [ Glob $(PATHS)$(PATH_SUFFIXES) : ndk-build ] ;
                if $(ndk-build) {
                    ndkRoot = [ Match (.+)/ : $(ndk-build[1]) ] ;
                } else {
                    ndkRoot = _ ;
                }
            }
        }

        NDKROOT on $(C.COMPILER_SUITE_SYMBOL) = $(ndkRoot) ;

        if $(ndkRoot) = _ {
            Exit Android NDK could not found, and NDKROOT is not set. ;
        }

        NDKROOT = $(ndkRoot) ;
    } else if $(OS) = NT {
        local ndkRoot = $(NDKROOT:J=" ") ;
        ndkRoot ?= $(NDKROOT:Z=$(C.COMPILER_SUITE_SYMBOL)) ;
        if ! $(ndkRoot) {
            local androidStudioNDK = $(LOCALAPPDATA)/Android/sdk/ndk ;
            local androidStudioHighestVersion = [ android.NDK.FindHighestVersion $(androidStudioNDK) ] ;
            if $(androidStudioHighestVersion) {
                ndkRoot = $(androidStudioNDK)/$(androidStudioHighestVersion) ;
                NDK_VERSION_COMPLETE on $(C.COMPILER_SUITE_SYMBOL) = $(androidStudioHighestVersion) ;
            } else {
                local PATHS =
                    $(LOCALAPPDATA)/Android/sdk/ndk
                    $(NVPACK_ROOT)
                    $(ProgramFiles(x86):J=$(SPACE))/Android/
                    c:/
                ;

                local PATH_SUFFIXES =
                    android-ndk
                    android-ndk-r21d
                    android-ndk-r18b
                    android-ndk-r14b
                    android-ndk-r12b
                    android-ndk-r10e
                ;

                local ndk-build = [ Glob $(PATHS)$(PATH_SUFFIXES) : ndk-build.cmd ndk-build ] ;
                if $(ndk-build) {
                    ndkRoot = [ Match (.+)/ : $(ndk-build[1]) ] ;
                } else {
                    ndkRoot = _ ;
                }
            }
        }

        NDKROOT on $(C.COMPILER_SUITE_SYMBOL) = $(ndkRoot) ;

        if $(ndkRoot) = _ {
            Exit Android NDK could not found, and NDKROOT is not set. ;
        }

        NDKROOT = $(ndkRoot) ;
    }

    switch $(OS) {
        case NT :       NDK_HOST    = "windows-x86_64" ;
        case CYGWIN :   NDK_HOST    = "windows" ;
        case MACOSX :   NDK_HOST    = "darwin-x86_64" ;
        case LINUX :    NDK_HOST    = "darwin-x86_64" ;
        case * :
            Exit *** Error \: Unable to detect host platform for NDK based on '$(OS)' ;
    }

    NDK_TOOLCHAIN_ROOT = $(NDKROOT)/toolchains/llvm/prebuilt/$(NDK_HOST) ; #$(NDK_DIRECTORY_PREFIX:E=$(NDK_COMPILER_PREFIX))$(NDK_COMPILER_VERSION)/prebuilt/$(NDK_HOST) ;
    local sysroot = $(NDK_TOOLCHAIN_ROOT)/sysroot ;

    local NDK_DIRECTORY_PREFIX ;
    local NDK_COMPILER_PREFIX ;
    local cflags ;
    local linkflags ;
    local NDK_SYSROOT_LIB ;
    switch $(C.ARCHITECTURE) {
        case arm :
            NDK_COMPILER_PREFIX = arm-linux-androideabi- ;
            cflags += -march=armv5te -mtune=xscale -msoft-float ;
            cflags += -ffunction-sections -funwind-tables -fstack-protector -no-canonical-prefixes -mthumb ;
            linkflags += -no-canonical-prefixes ;
            linkflags += -mthumb ;
        case armv7-a :
            NDK_COMPILER_PREFIX = armv7a-linux-androideabi$(NDK_VERSION)- ;
            #cflags += -isystem $(NDKROOT)/sysroot/usr/include/arm-linux-androideabi ;
            cflags += -target armv7-linux-androideabi$(NDK_VERSION) ;
            cflags += -march=armv7-a -mfpu=neon -mfloat-abi=softfp ;
            cflags += -ffunction-sections -funwind-tables -fstack-protector -no-canonical-prefixes -marm ;
            linkflags += -no-canonical-prefixes ;
            linkflags += -target armv7-linux-androideabi$(NDK_VERSION) ;
            linkflags += -march=armv7-a -Wl,--fix-cortex-a8 ;
            linkflags += -mthumb ;
            NDK_SYSROOT_LIB = $(sysroot)/usr/lib/arm-linux-androideabi ;
        case x86 :
            NDK_DIRECTORY_PREFIX = x86- ;
            NDK_COMPILER_PREFIX = i686-linux-android- ;
            # Fill in cflags
            # Fill in linkflags
        case mips :
            NDK_COMPILER_PREFIX = mipsel-linux-android- ;
            # Fill in cflags
            # Fill in linkflags
        case arm64 :
            NDK_COMPILER_PREFIX = aarch64-linux-android$(NDK_VERSION)- ;
            #cflags += -isystem $(NDKROOT)/sysroot/usr/include/aarch64-linux-android ;
            cflags += -target aarch64-linux-android$(NDK_VERSION) ;
            cflags += -march=armv8-a ;
            cflags += -ffunction-sections -funwind-tables -fstack-protector -no-canonical-prefixes ;
            linkflags += -no-canonical-prefixes ;
            linkflags += -target aarch64-linux-android$(NDK_VERSION) ;
            linkflags += -march=armv8-a ;
            linkflags += -mthumb ;
            NDK_SYSROOT_LIB = $(sysroot)/usr/lib/aarch64-linux-android ;
            # Fill in cflags
            # Fill in linkflags
        case x86-64 :
            NDK_COMPILER_PREFIX = x86_64- ;
            # Fill in cflags
            # Fill in linkflags
        case mips64 :
            NDK_COMPILER_PREFIX = mips64el-linux-android- ;
            # Fill in cflags
            # Fill in linkflags
        case * :
            Exit *** Error \: Unknown architecture for NDK\: $(C.ARCHITECTURE) ;
    }

    #cflags += -D__ANDROID_API__=$(NDK_VERSION) ;
    cflags += -fPIC ;
    cflags += -fvisibility=hidden ;
    cflags += -fsigned-char ;

    ARCHITECTURE_CFLAGS on $(C.COMPILER_SUITE_SYMBOL) = $(cflags) ;
    ARCHITECTURE_LINKFLAGS on $(C.COMPILER_SUITE_SYMBOL) = $(linkflags) ;

    local NDK_COMPILER_VERSION ;
    switch $(C.COMPILER) {
        case gcc :
            NDK_COMPILER_VERSION = $(C.COMPILER_VERSION:E=4.9) ;
            NDK_TOOLCHAIN_ROOT = $(NDKROOT)/toolchains/$(NDK_DIRECTORY_PREFIX:E=$(NDK_COMPILER_PREFIX))$(NDK_COMPILER_VERSION)/prebuilt/$(NDK_HOST) ;
        case clang :
            NDK_COMPILER_VERSION = $(C.COMPILER_VERSION:E=4.9) ;
            local lastDirectory = [ Subst $(NDK_COMPILER_PREFIX) : -$ ] ;
            EXTRA_LINK_PATH on $(C.COMPILER_SUITE_SYMBOL) = $(NDK_TOOLCHAIN_ROOT)/$(lastDirectory)/bin ;
            #Echo C.AR on $(C.COMPILER_SUITE_SYMBOL)          \= $(NDK_TOOLCHAIN_ROOT)/bin/$(NDK_COMPILER_PREFIX)ar ruc ;
            #C.AR on $(C.COMPILER_SUITE_SYMBOL)          = $(NDK_TOOLCHAIN_ROOT)/bin/$(NDK_COMPILER_PREFIX)ar ruc ;
            #C.IncludeDirectories * : $(NDKROOT)/sources/cxx-stl/llvm-libc++/include ;
            C.C++Flags * : -stdlib=libc++ ;
            switch $(C.ARCHITECTURE) {
                case armv7-a :
                    #C.IncludeDirectories * : $(NDKROOT)/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include ;
                    C.LinkDirectories * : $(NDK_TOOLCHAIN_ROOT)/$(lastDirectory)/lib/armv7-a ;
                    C.LinkDirectories * : $(NDKROOT)/sources/cxx-stl/llvm-libc++/libs/armeabi-v7a ;

                case arm64 :
                    #C.IncludeDirectories * : $(NDKROOT)/sources/cxx-stl/gnu-libstdc++/4.9/libs/arm64-v8a/include ;
                    #C.LinkDirectories * : $(NDK_TOOLCHAIN_ROOT)/$(lastDirectory)/lib64 ;
                    #C.LinkDirectories * : $(NDKROOT)/sources/cxx-stl/llvm-libc++/libs/arm64-v8a ;
            }
            NDK_COMPILER_PREFIX = "" ;
            NDK_COMPILER_VERSION ?= llvm ;
        case * :
            Exit *** Error \: Unknown compiler for NDK\: $(C.COMPILER) ;
    }
    NDK_COMPILER_VERSION on $(C.COMPILER_SUITE_SYMBOL) = $(NDK_COMPILER_VERSION) ;

    NDK_TOOLCHAIN_ROOT on $(C.COMPILER_SUITE_SYMBOL) = $(NDK_TOOLCHAIN_ROOT) ;

    NDK_SYSROOT_LIBPATHS on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(NDK_SYSROOT_LIB) $(NDK_SYSROOT_LIB)/$(NDK_VERSION) ;

    #C.AR on $(C.COMPILER_SUITE_SYMBOL)          ?= $(NDK_TOOLCHAIN_ROOT)/bin/$(NDK_COMPILER_PREFIX)ar ruc ;
    C.AR on $(C.COMPILER_SUITE_SYMBOL)          = $(NDK_TOOLCHAIN_ROOT)/bin/llvm-ar ruc ;
    C.CC on $(C.COMPILER_SUITE_SYMBOL)          = $(NDK_TOOLCHAIN_ROOT)/bin/$(NDK_COMPILER_PREFIX)clang ;
    C.C++ on $(C.COMPILER_SUITE_SYMBOL)         = $(NDK_TOOLCHAIN_ROOT)/bin/$(NDK_COMPILER_PREFIX)clang++ ;
    C.LINK on $(C.COMPILER_SUITE_SYMBOL)        = $(NDK_TOOLCHAIN_ROOT)/bin/$(NDK_COMPILER_PREFIX)clang++ ;
    C.RANLIB on $(C.COMPILER_SUITE_SYMBOL)      = ;
    C.STRIP on $(C.COMPILER_SUITE_SYMBOL)       = $(NDK_TOOLCHAIN_ROOT)/bin/llvm-strip ;

    # Set up the SDK side of things.
    if $(OS) in MACOSX {
        #JAVA.HOME on $(C.COMPILER_SUITE_SYMBOL) = /usr/bin ;
        JAVA.JAVA on $(C.COMPILER_SUITE_SYMBOL) = java ;
        JAVA.JAVAC on $(C.COMPILER_SUITE_SYMBOL) = javac ;
        JAVA.JAR on $(C.COMPILER_SUITE_SYMBOL) = jar ;
        JAVA.JARSIGNER on $(C.COMPILER_SUITE_SYMBOL) = jarsigner ;
        #local javaHome = "/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home" ;
        #JAVA.HOME on $(C.COMPILER_SUITE_SYMBOL) = $(javaHome) ;
        #JAVA.JAVA on $(C.COMPILER_SUITE_SYMBOL) = $(javaHome)/bin/java ;
        #JAVA.JAVAC on $(C.COMPILER_SUITE_SYMBOL) = $(javaHome)/bin/javac ;
        #JAVA.JAR on $(C.COMPILER_SUITE_SYMBOL) = $(javaHome)/bin/jar ;
        #JAVA.JARSIGNER on $(C.COMPILER_SUITE_SYMBOL) = $(javaHome)/bin/jarsigner ;
    } else if $(OS) = NT {
        # Java home
        local ProgramFilesCombined = $(ProgramFiles:J=" ":/) ;
        local javaHome = [ W32_GETREG HKEY_LOCAL_MACHINE SOFTWARE JavaSoft "Java Development Kit" 1.8 "JavaHome" ] ;
        javaHome ?= "$(ProgramFilesCombined)/Android/Android Studio/jbr" ;

        JAVA.HOME on $(C.COMPILER_SUITE_SYMBOL) = $(javaHome) ;
        JAVA.JAVA on $(C.COMPILER_SUITE_SYMBOL) = $(javaHome)/bin/java.exe ;
        JAVA.JAVAC on $(C.COMPILER_SUITE_SYMBOL) = $(javaHome)/bin/javac.exe ;
        JAVA.JAR on $(C.COMPILER_SUITE_SYMBOL) = $(javaHome)/bin/jar.exe ;
        JAVA.JARSIGNER on $(C.COMPILER_SUITE_SYMBOL) = $(javaHome)/bin/jarsigner.exe ;
    }

    local sdkRoot = $(ANDROID_SDK_ROOT) ;
    if $(OS) = NT {
        sdkRoot ?= $(LOCALAPPDATA:/)/Android/sdk ;
        sdkRoot ?= $(NVPACK_ROOT:/)/android-sdk-windows ;
        sdkRoot ?= $(ProgramFiles(x86):J=" ")/Android/android-sdk ;
    } else if $(OS) = MACOSX {
        sdkRoot ?= $(HOME:/)/Library/Android/sdk ;
        sdkRoot ?= $(NVPACK_ROOT:/)/android-sdk-macosx ;
        sdkRoot ?= $(HOME)/android-sdk-macosx ;
    }
    sdkRoot = $(sdkRoot:J=" ") ;
    ANDROID.SDK_ROOT on $(C.COMPILER_SUITE_SYMBOL) = $(sdkRoot) ;

    ANDROID.SDK_VERSION on $(C.COMPILER_SUITE_SYMBOL) = $(SDK_VERSION) ;

    local sdkPlatform = $(ANDROID_SDK_PLATFORM) ;
    sdkPlatform ?= android-$(SDK_VERSION) ;
    ANDROID.SDK_PLATFORM on $(C.COMPILER_SUITE_SYMBOL) = $(sdkPlatform) ;

    ANDROID.ADB on $(C.COMPILER_SUITE_SYMBOL) = $(sdkRoot)/platform-tools/adb ;

    local buildToolsDir = [ Glob $(sdkRoot)/build-tools : $(SDK_VERSION).* ] ;
    if ! $(buildToolsDir) {
        buildToolsDir = $(sdkRoot)/build-tools/30.0.1 ;
    }
    if $(buildToolsDir[1]) {
        ANDROID.ZIPALIGN on $(C.COMPILER_SUITE_SYMBOL) = $(buildToolsDir)/zipalign ;
        ANDROID.AAPT on $(C.COMPILER_SUITE_SYMBOL) = $(buildToolsDir)/aapt ;
        ANDROID.AIDL on $(C.COMPILER_SUITE_SYMBOL) = $(buildToolsDir)/aidl ;
        ANDROID.DX on $(C.COMPILER_SUITE_SYMBOL) = $(buildToolsDir)/dx ;
    }

    ANDROID.BUNDLETOOL.JAR on $(C.COMPILER_SUITE_SYMBOL) = $(sdkRoot)/tools/bundletool.jar ;

    ANDROID.ANDROID.JAR on $(C.COMPILER_SUITE_SYMBOL) = $(sdkRoot)/platforms/$(sdkPlatform)/android.jar ;

    ANDROID.FRAMEWORK.AIDL on $(C.COMPILER_SUITE_SYMBOL) = $(sdkRoot)/platforms/$(sdkPlatform)/framework.aidl ;

    local libVersion = "" ;
    libVersion = -$(SDK_VERSION).0.0-dev ;
    libVersion = -26.0.0-dev ;

    ANDROID.COMMON.JAR on $(C.COMPILER_SUITE_SYMBOL) = $(sdkRoot)/tools/lib/common$(libVersion).jar ;
    ANDROID.SDK-COMMON.JAR on $(C.COMPILER_SUITE_SYMBOL) = $(sdkRoot)/tools/lib/sdk-common$(libVersion).jar ;
    ANDROID.SDKLIB.JAR on $(C.COMPILER_SUITE_SYMBOL) = $(sdkRoot)/tools/lib/sdklib$(libVersion).jar ;
    ANDROID.MANIFEST-MERGER.JAR on $(C.COMPILER_SUITE_SYMBOL) = $(sdkRoot)/tools/lib/manifest-merger$(libVersion).jar ;
    if $(NT) {
        ANDROID.PATHSEPARATOR on $(C.COMPILER_SUITE_SYMBOL) = ";" ;
    } else {
        ANDROID.PATHSEPARATOR on $(C.COMPILER_SUITE_SYMBOL) = ":" ;
    }

    C.ARCHITECTURE on $(C.ACTIVE_TOOLCHAIN_*) = $(ARCHITECTURE) ;
    SYSROOT on $(C.ACTIVE_TOOLCHAIN_*) = $(sysroot) ;
}


rule android.ApplicationId TARGET : APPLICATION_ID {
    TARGET = [ ActiveTarget $(TARGET) ] ;

    ANDROID.APPLICATION_ID on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(APPLICATION_ID) ;
}


rule android.SDKCompileVersion TARGET : SDK_COMPILE_VERSION {
    TARGET = [ ActiveTarget $(TARGET) ] ;

    ANDROID.SDK_COMPILE_VERSION on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(SDK_COMPILE_VERSION) ;
}


rule android.SDKMinimumVersion TARGET : SDK_MINIMUM_VERSION {
    TARGET = [ ActiveTarget $(TARGET) ] ;

    ANDROID.SDK_MINIMUM_VERSION on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(SDK_MINIMUM_VERSION) ;
}


rule android.SDKTargetVersion TARGET : SDK_TARGET_VERSION {
    TARGET = [ ActiveTarget $(TARGET) ] ;

    ANDROID.SDK_TARGET_VERSION on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(SDK_TARGET_VERSION) ;
}


rule android.ProductVersion TARGET : VERSION_NAME : VERSION_CODE {
    TARGET = [ ActiveTarget $(TARGET) ] ;

    ANDROID.VERSION_NAME on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(VERSION_NAME) ;
    ANDROID.VERSION_CODE on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(VERSION_CODE) ;
}


rule C.android._MultiCppCompile_SetupFlags {
    local extraflags ;

    local sysroot = $(SYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;
    #extraflags += "--sysroot $(sysroot:C)" ;
    #extraflags += "-isystem @($(NDKROOT)/sysroot/usr/include:C)" ;
    local developerRoot = $(NDKROOT)/platforms ;
    extraflags += $(ARCHITECTURE_CFLAGS:Z=$(C.COMPILER_SUITE_SYMBOL)) ;

    _flags = $(_flags[1-4]) $(extraflags) $(_flags[5-]) ;

    C.clang._MultiCppCompile_SetupFlags ;
}


rule C.android._ApplicationFromObjects_LinkFlags {
    linkRule = C.android.clang.Link ;

    local sysroot = $(SYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;
    #linkFlags += "--sysroot $(sysroot:C)" ;
    linkFlags += $(ARCHITECTURE_LINKFLAGS:Z=$(C.COMPILER_SUITE_SYMBOL)) ;
}


rule C.android._SharedLibraryFromObjects_LinkFlags {
    linkRule = C.android.clang.Link ;

    linkFlags += -Wl,-soname,$(_t[1]:TCBS) ;
    linkFlags += -shared ;

    local sysroot = $(SYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;
    #linkFlags += "--sysroot $(sysroot:C)" ;
    linkFlags += $(ARCHITECTURE_LINKFLAGS:Z=$(C.COMPILER_SUITE_SYMBOL)) ;
    linkFlags += -Wl,--no-undefined -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now ;
    linkFlags += -fPIC ;

    #_flags = $(_flags[1-4]) $(extraflags) $(_flags[5-]) ;
}


#######################################################################################

C.android.IGNORE_ASSETS_LIST = "\"!.svn:!.git:!.ds_store:!*.scc:.*:<dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~:!*.class:!*.java:!*.apk:!*.jar:!*.bat\"" ;

# Java -> Class
actions response android._JavaC {
    $(JAVA.JAVAC:TC) -source 1.8 -target 1.8 $(JFLAGS) @@($(2:TC)) -d $(OUTPUT_FOLDER)
}


# Resources -> Java
actions android._ResourceCompiler {
    $(ANDROID.AAPT:TC) package --ignore-assets $(C.android.IGNORE_ASSETS_LIST) $(EXTRA_PACKAGES) -m --non-constant-id --auto-add-overlay --output-text-symbols $(RESOURCE_TEXT_SYMBOLS_DIR:TC) -M $(MANIFEST:TC) -J $(RESOURCE_TEXT_SYMBOLS_DIR:TC) $(RESOURCES) $(ASSETS) -I $(ANDROID.ANDROID.JAR:TC)
}


# Manifest Merger
actions android._ManifestMerger {
    $(JAVA.JAVA:TC) -cp "$(ANDROID.COMMON.JAR:T)$(ANDROID.PATHSEPARATOR)$(ANDROID.MANIFEST-MERGER.JAR)$(ANDROID.PATHSEPARATOR)$(ANDROID.SDK-COMMON.JAR:T)$(ANDROID.PATHSEPARATOR)$(ANDROID.SDKLIB.JAR:T)" com.android.manifmerger.Merger --out $(1:C) --main $(2[1]:C) --libs $(2[2-]:CJ=$(ANDROID.PATHSEPARATOR))
}


# Aidl -> Java
actions android._CompileAidl {
    $(ANDROID.AIDL:TC) "-p$(ANDROID.FRAMEWORK.AIDL)" $(2:TC) $(1:TC)
}


# Class/Jar -> Dex
if $(OS) = NT {

actions android._DXBundle {
    set JAVA_HOME=$(JAVA.HOME)
    set PATH=%ANDROID_SDK_ROOT%\platform-tools;%PATH%
    $(ANDROID.DX:TC) --dex --output=$(1:TC) --positions=lines $(2:TC)
}

} else {

actions android._DXBundle {
    $(ANDROID.DX:TC) --dex --output=$(1:TC) --positions=lines $(2:TC)
}

}



# Dex/Resources -> Apk
actions android._APKPackage {
    $(ANDROID.AAPT:TC) package --ignore-assets $(C.android.IGNORE_ASSETS_LIST) --auto-add-overlay -f -M $(MANIFEST:TC) $(RESOURCES) $(ASSETS) $(UNCOMPRESSED_ASSET_EXTENSIONS) -I $(ANDROID.ANDROID.JAR:TC) $(NEEDJARS_COMMAND_LINE) -F $(1:TC) $(INPUT_DIRECTORY)
}


# Apk -> Signed APK
actions android._SignApk {
    $(JAVA.JARSIGNER:TC) -keystore $(KEYSTORE_PATH:TC) -storepass $(KEYSTORE_PASSWORD) -signedjar $(1:TC) $(2:TC) $(KEYSTORE_KEY_ALIAS)
}


# Signed APK -> Signed Zip Aligned APK.
actions android._ZipAlign {
    $(ANDROID.ZIPALIGN:TC) -f 4 $(2) $(1)
}


# aab -> Signed aab
actions android._SignAab {
    $(JAVA.JARSIGNER:TC) -verbose -sigalg SHA256withRSA -digestalg SHA-256 -keystore $(KEYSTORE_PATH:TC) -storepass $(KEYSTORE_PASSWORD) -keypass $(KEYSTORE_KEY_PASSWORD) $(1:TC) $(KEYSTORE_KEY_ALIAS)
}


# Install the signed APK to the device
actions screenoutput android._Install {
    $(ANDROID.ADB:TC) install -r $(2:TC)
}


# Uninstall the package from the device
actions screenoutput android._Uninstall {
    $(ANDROID.ADB:TC) uninstall $(PACKAGE)
}


# Class -> Jar
if $(OS) = NT {
    actions android._Jar {
        cd /d $(OUTPUT_FOLDER:TC)
        $(JAVA.JAR:TC) cf $(1:TC) -C $(OUTPUT_FOLDER:TC) @($(RELATIVE_CLASSES:R=$(OUTPUT_FOLDER:T)):W=$(OUTPUT_FOLDER:T)/)
    }
} else {
    actions android._Jar {
        cd $(OUTPUT_FOLDER:TC)
        $(JAVA.JAR:TC) cf $(1:TC) -C $(OUTPUT_FOLDER:TC) @($(RELATIVE_CLASSES:R=$(OUTPUT_FOLDER:T)):W=$(OUTPUT_FOLDER:T)/)
    }
}


#######################################################################################

if ! $(TARGETINFO_LOCATE) {

# Recursive glob (through all directories) looking for the given patterns.
rule android._GlobRecursive DIRECTORIES : PATTERNS {
    local _dirPattern  = */ ;
    local _filePattern = $(PATTERNS)[^/] ;

    local _dirs  = [ Glob $(DIRECTORIES) : $(_dirPattern) ] ;

    local _files = [ Glob $(DIRECTORIES) : $(_filePattern) ] ;

    if $(_dirs) {
        _files += [ android._GlobRecursive $(_dirs) : $(PATTERNS) ] ;
    }

    return $(_files) ;
}

# Internal function called by C.android.StripCommonPath.
rule android._StripCommonPathInternal VAR : COMMON {
    local _v = [ Split $($(VAR)) : / ] ;
    local _c = [ Split $($(COMMON)) : / ] ;

    if $(_v[1]) && $(_v[1]) = $(_c[1]) {
        $(VAR) = $(_v[2-]:J=/) ;
        $(COMMON) = $(_c[2-]:J=/) ;

        android._StripCommonPathInternal $(VAR) : $(COMMON) ;
    }

    return $($(VAR)) ;
}

# Strips the common path away from var, e.g. if var is c:\test\fish and common in c:\test then the 
# returned result will be fish.
rule android._StripCommonPath VAR : COMMON {
    local _var = $(VAR) ;
    local _common = $(COMMON) ;

    return [ android._StripCommonPathInternal _var : _common ] ;
}


# Reads the package XML entry from the AndroidManifest.xml.
rule android._ReadPackageFromAndroidManifest FILENAME {
    return [ LuaString "
            local xmlize = require 'xmlize'

            local file = io.open([[$(FILENAME)]], 'rb')
            if file then
                local buffer = file:read('*a')
                file:close()

                local xml = xmlize.luaize(buffer)
                if xml  and  xml.manifest  and  xml.manifest[1]  and  xml.manifest[1]['@'] then
                    return xml.manifest[1]['@'].package
                end
            end
    " ] ;
}


# Replaces dot separated package with forward slash separated path.
rule android._PackageToDirectory DIRECTORY {
    return [ Subst $(DIRECTORY) : %. : / ] ;
}


# Header scanner rule for Java, takes incoming package names, e.g. com.pawprintgames.pigame.pigameonline and fixes
# up dependencies to actual files, e.g. <!somedir!>com/pawprintgames/pigame/pigameonline.java
rule android._JavaHdrRule SOURCE : HEADERS {
    # Get all JARs (not prebuilt) that this target relies on.
    local needJars = $(JAVA.NEEDJARS:Z=$(HDRGRIST)) ;

    # Get source path for this module.
    local sourcePaths = $(JAVA.SOURCEPATHS:Z=$(HDRGRIST)) ;

    # Add on source path for all JARs (not prebuilt) that this target rlies on.
    local _needJar ;
    for _needJar in $(needJars:GB) {
        sourcePaths += $(JAVA.SOURCEPATHS:Z=$(_needJar:G=$(C.ACTIVE_TOOLCHAIN_GRIST))) ;
    }

    # Go through each package.
    local _fixed ;
    local header ;
    for header in $(HEADERS) {
        # If this is a wildcard packge i.e. import com.mycompany.mygame.*
        if $(header:S) = .* {
            # Convert the com.mycompany.mygame bit into com/mycompany/mygame
            local _f = [ android._PackageToDirectory $(header:S=) ] ;

            # Go through each source path available to this target.
            local _sourcePath ;
            for _sourcePath in $(sourcePaths) {
                # Glob for all Java files in given source path.
                local _listing = [ Glob $(_sourcePath)/$(_f) : *.java ] ;

                # If we found one or more files.
                if $(_listing) {
                    # Set up an includes dependency between source and all found files and then continue to next header.
                    # Echo Dependency $(SOURCE) -> $(_listing) ;
                    Echo TODO!!!!!!!! ;
                    Includes $(SOURCE) : $(_listing) ;
                    continue ;
                }
            }
        } else {
            # Not a wild card, just add the fixed up package name to our list that we batch process below.
            _fixed += [ android._PackageToDirectory $(header) ] ;
        }
    }

    # Add .java to each of our fixed up entries (e.g. com/mycompany/mygame/mygameonline becomes com/mycompany/mygame/mygameonline.java).
    _fixed = @($(_fixed).java:G=$(HDRGRIST:E)) ;

    # Set search path to all source paths available to this module.
    SEARCH on $(_fixed) += $(sourcePaths) ;

    # Set up an includes dependency between source and fixed up headers.
    Includes $(SOURCE) : $(_fixed) ;

    # Indicate we do not care if the fixed up header does not exist (could be a system header).
    NoCare $(_fixed) ;
}


#######################################################################################

LuaString "
local miniz = require 'miniz'
local ospath = require 'ospath'
local filefind = require 'filefind'

function MirrorExtractZip(zipFilename, outputDirectory)
    local outputDirectoryEntries = {}
    for entry in filefind.glob(ospath.join(outputDirectory, '**@*')) do
        outputDirectoryEntries[entry.filename] = entry.write_time
    end

    --print(zipFilename)
    local archive = miniz.zip_read_file(zipFilename)
    for index = 1, archive:get_num_files() do
        local entry = archive:stat(index)
        local entryFilename = entry.filename
        if entry.filename:sub(-1) ~= '/' then
            local fullOutputFilename = ospath.join(outputDirectory, entry.filename)
            if outputDirectoryEntries[fullOutputFilename] ~= entry.time then
                --print('Extracting ' .. entry.filename)
                ospath.mkdir(fullOutputFilename)
                archive:extract_to_file(entry.filename, fullOutputFilename)
                ospath.touch(fullOutputFilename, entry.time)
            end
            outputDirectoryEntries[fullOutputFilename] = nil
            local components = {}
            for component in fullOutputFilename:gmatch('[^/]+') do
                components[#components + 1] = component
                outputDirectoryEntries[table.concat(components, '/') .. '/'] = nil
            end
        end
    end
    archive:close()

    for filename in pairs(outputDirectoryEntries) do
        --print('Removing ' .. filename)
        ospath.remove(filename)
    end
end


function UnpackAar(aarFilename, outputDirectory)
    MirrorExtractZip(aarFilename, outputDirectory)
end

" ;


#######################################################################################

# Create library from given sources.
rule android.Library TARGET : SOURCES : OPTIONS {
    TARGET = [ C.ActiveTarget $(TARGET) ] ;

    if $(ANDROID.USE_GRADLE) = 1 {
        # Lib path
        JAVA.LIBPATH on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(SUBDIR) ;

        # Source path
        local sourcePaths = $(JAVA.SOURCEPATHS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
        sourcePaths ?= $(SUBDIR) ;
        JAVA.SOURCEPATHS on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(sourcePaths) ;

        # Manifest.
        local manifest = $(ANDROID.MANIFEST:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
        manifest ?= @(AndroidManifest.xml:R=$(SUBDIR:E="")) ;
        ANDROID.MANIFEST on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(manifest) ;

        # Package
        local package = $(ANDROID.PACKAGE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
        if ! $(package) {
            package = [ android._ReadPackageFromAndroidManifest $(manifest) ] ;
            ANDROID.PACKAGE on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(package) ;
        }


        # Verify the assets directory is actually there.
        local assets = $(ANDROID.ASSETS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
        assets ?= @(assets:R=$(SUBDIR:E="")) ;
        #assets = [ Glob $(assets:TP) : $(assets:BS)/ ] ;
        ANDROID.ASSETS on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(assets) ;

        # Resources
        local resources = $(ANDROID.RESOURCES:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
        resources ?= @(res:R=$(SUBDIR:E="")) ;
        resources = [ Glob $(resources:TP) : $(resources:BS)/ ] ;
        ANDROID.RESOURCES on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(resources) ;

        return ;
    }

    # Shove this in a special output directory. That way, we can collect any of the
    # generated files from javac, since javac doesn't tell us what it is going to
    # output.
    local outputClassesDirectory = $(LOCATE_TARGET)/classes ;

    # JARs that we depend on.
    local needJars = $(JAVA.NEEDJARS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;

    # Collect all of the available jar directories.
    local _jarDirectories =
        $(JAVA.JARDIRECTORIES:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))
        $(JAVA.JARDIRECTORIES:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

    local _needJar ;
    for _needJar in $(needJars:GB) {
        _jarDirectories += $(JAVA.JARDIRECTORIES:Z=$(_needJar:G=$(C.ACTIVE_TOOLCHAIN_GRIST))) ;
    }

    # Prebuilt JAR files.
    local linkLibs = $(JAVA.PREBUILTJARS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
    for _needJar in $(needJars:GB) {
        linkLibs += $(JAVA.PREBUILTJARS:Z=$(_needJar:G=$(C.ACTIVE_TOOLCHAIN_GRIST))) ;
    }
    SEARCH on $(linkLibs) += $(_jarDirectories) ;

    # Prebuilt AAR files.
    local LOCATE_AAR_ROOT = $(LOCATE_TARGET)/aar ;
    local prebuiltAars = $(JAVA.PREBUILTAARS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
    SEARCH on $(prebuiltAars) += $(SUBDIR)/libs ;

    local unpackedAars ;

    local prebuiltAar ;
    for prebuiltAar in $(prebuiltAars) {
        local outputLocation = $(LOCATE_AAR_ROOT)/__$(prebuiltAar:BS)__ ;
        local outputAar = $(prebuiltAar:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)|aar|temp) ;
        unpackedAars += $(outputAar) ;
        LOCATE on $(outputAar) = $(outputLocation) ;
        JAVA.PREBUILTAAR on $(outputAar) = $(prebuiltAar) ;
        LuaString "UnpackAar([[$(prebuiltAar:T)]], [[$(outputLocation)]])" ;

        if [ Glob $(outputLocation) : classes.jar ] {
            local classes.jar = @(classes.jar:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)|aar|$(prebuiltAar:G=)) ;
            SEARCH on $(classes.jar) = $(outputLocation) ;
            linkLibs += $(classes.jar) ;
        }

    }
    JAVA.UNPACKEDAARS on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(unpackedAars) ;

    # Lib path
    JAVA.LIBPATH on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(SUBDIR) ;

    # Source path
    local sourcePaths = $(JAVA.SOURCEPATHS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
    sourcePaths ?= $(SUBDIR) ;
    JAVA.SOURCEPATHS on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(sourcePaths) ;

    # Manifest.
    local manifest = $(ANDROID.MANIFEST:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
    manifest ?= @(AndroidManifest.xml:R=$(SUBDIR:E="")) ;
    ANDROID.MANIFEST on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(manifest) ;

    # Package
    local package = $(ANDROID.PACKAGE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
    if ! $(package) {
        package = [ android._ReadPackageFromAndroidManifest $(manifest) ] ;
        ANDROID.PACKAGE on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(package) ;
    }


    # Verify the assets directory is actually there.
    local assets = $(ANDROID.ASSETS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
    assets ?= @(assets:R=$(SUBDIR:E="")) ;
    #assets = [ Glob $(assets:TP) : $(assets:BS)/ ] ;
    ANDROID.ASSETS on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(assets) ;

    # Resources
    local resources = $(ANDROID.RESOURCES:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
    resources ?= @(res:R=$(SUBDIR:E="")) ;
    resources = [ Glob $(resources:TP) : $(resources:BS)/ ] ;
    ANDROID.RESOURCES on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(resources) ;

    # Resource java file (generated).
    local _packageRFile = [ android._PackageToDirectory $(package) ] ;
    local resourceJavaFile = $(_packageRFile) ;

    _packageRFile = @($(_packageRFile)/R.class:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
    MakeLocate $(_packageRFile) : $(outputClassesDirectory) ;

    resourceJavaFile = @($(resourceJavaFile)/R.java:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
    local resourceTextFile = [ C.GristFiles $(TARGET) : R.txt ] ;
    local resourceOutputFiles = $(resourceJavaFile) $(resourceTextFile) ;

    # Can only have one Java resources class per APK, so generate resources from all libraries (and application) using the --extra-packages
    # switch, which means it'll generate a R.Java for each library.
    local _needJarResourceDirs = $(resources) ;
    if $(needJars) {
        local _needJarPackages ;
        local _needJar ;
        for _needJar in $(needJars:GB) {
            _needJarPackages += $(ANDROID.PACKAGE:Z=$(_needJar:G=$(C.ACTIVE_TOOLCHAIN_GRIST))) ;
        }

        local extraResourceFilenames = [ android._PackageToDirectory $(_needJarPackages) ] ;
        extraResourceFilenames = @($(extraResourceFilenames)/R.java:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
        MakeLocate $(extraResourceFilenames) : $(LOCATE_TARGET) ;
        resourceOutputFiles += $(extraResourceFilenames) ;

        local _colon = \: ;
        _needJarPackages = $(_needJarPackages:J=$(_colon)) ;
        EXTRA_PACKAGES on $(resourceOutputFiles) = --extra-packages $(_needJarPackages) ;

        # Resource directories for needed JARs.
        for _needJar in $(needJars:GB) {
            _needJarResourceDirs += $(JAVA.RESOURCES:Z=$(_needJar:G=$(C.ACTIVE_TOOLCHAIN_GRIST))) ;
        }
    }

    local aar ;
    for aar in $(unpackedAars) {
        local resLocation = $(LOCATE:Z=$(aar))/res ;
        resLocation = [ Glob $(resLocation:TP) : $(resLocation:BS)/ ] ;
        if $(resLocation) {
            _needJarResourceDirs += $(resLocation) ;
        }
    }

    if $(resources) {
        MakeLocate $(resourceOutputFiles) : $(LOCATE_TARGET) ;

        # Resource text symbols (generated) go into this directory.
        local _commonStripped = ;
        if $(SEARCH_SOURCE) = $(sourcePaths) {
            _commonStripped = "" ;
        } else {
            _commonStripped = [ android._StripCommonPath $(sourcePaths) : $(SEARCH_SOURCE) ] ;
        }
        RESOURCE_TEXT_SYMBOLS_DIR on $(resourceOutputFiles) = $(LOCATE_TARGET) ;

        # The generated Java file is dependent on all the resource files found in the provided resource directories.
        local _resourceFiles = [ android._GlobRecursive $(resources) : *.* ] ;
        Depends $(resourceOutputFiles) : $(_resourceFiles) ;

        # Store the resources directory onto the target so it can be accessed by the action.
        local _dashS = "-S " ;
        RESOURCES on $(resourceOutputFiles) = $(_dashS)$(_needJarResourceDirs:TC/) ;
        local _dashA = "-A " ;
        ASSETS on $(resourceOutputFiles) = $(_dashA)$(assets:TC/) ;

        # All the resource files we found from our glob are part of the command line.
        UseCommandLine $(resourceOutputFiles) : $(_resourceFiles) $(C.android.IGNORE_ASSETS_LIST) ;

        # Assign dependencies on the AndroidManifest.xml
        MANIFEST on $(resourceOutputFiles) = $(manifest) ;
        Depends $(resourceOutputFiles) : $(manifest) ;

        # Call the resource compiler action.
        SOURCES += $(resourceJavaFile) ;
        android._ResourceCompiler $(resourceOutputFiles) : $(resources) : $(C.COMPILER_SUITE_SYMBOL) ;
    }

    # List of AIDL compiled files.
    local _aidlCompiledFiles = ;

    # AIDL compiler.
    local _source ;
    for _source in $(SOURCES:I=.aidl) {
        _source = [ C.GristFiles $(TARGET) : $(_source) ] ;
        SEARCH on $(_source) = $(sourcePaths) ;

        # Compiled Java file.
        local _compiled = $(_source:S=.java) ;

        # Locate compiled files in build directory, allowing for nested paths.
        MakeLocate $(_compiled) : $(_compiled:DR=$(LOCATE_TARGET)) ;
        BINDING on $(_compiled) = $(_compiled:BS) ;

        _aidlCompiledFiles += $(_compiled) ;

        # Action.
        android._CompileAidl $(_compiled) : $(_source) : $(C.COMPILER_SUITE_SYMBOL) ;

        # Dependency.
        Depends $(_compiled) : $(_source) ;
    }

    local _javaFiles = $(SOURCES:I=.java) ;
    local newsrcs ;
    local _src ;

    for _src in $(_javaFiles) {
        local _gristedSrc = $(_src:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
        if $(ANDROID.EXCLUDED_FROM_BUILD:Z=$(_gristedSrc)) = true {
            continue ;
        }
        newsrcs += $(_src) ;
    }
    _javaFiles = $(newsrcs) ;

    local _sources = [ C.GristFiles $(TARGET) : $(_javaFiles) ] ;
    if $(_sources[1]) {
        #SEARCH on $(_sources) = $(SEARCH_SOURCE)/$(_commonStripped) ;
        SEARCH on $(_sources) = $(sourcePaths) ;

        # Class files.
        local _classes = [ C.GristFiles $(TARGET) : $(_javaFiles:S=.class) ] ;
        local _class ;
        for _class in $(_classes) {
            MakeLocate $(_class) : $(_class:DR=$(outputClassesDirectory)) ;
            BINDING on $(_class) = $(_class:BS) ;
        }

        # If we are building the application JAR...
        if application in $(OPTIONS) {
            # If we have library JARs that we have built...
            if $(isthisneeded) && $(needJars) {
                # Put R.class files for each of our libraries inside, too.
                local _needJar ;
                for _needJar in $(needJars:GB) {
                    # Get package name for library.
                    local _needJarPackage = $(ANDROID.PACKAGE:Z=$(_needJar:G=$(C.ACTIVE_TOOLCHAIN_GRIST))) ;

                    # Convert package name into a relative directory.
                    local _needJarPackageDirectory = [ android._PackageToDirectory $(_needJarPackage) ] ;

                    # Add library R.Java to sources.
                    local _r = [ C.GristFiles $(TARGET) : $(_needJarPackageDirectory)/R.java ] ;
                    MakeLocate $(_r) : $(_r:DR=$(LOCATE_TARGET)) ;
                    BINDING on $(_r) = $(_r:BS) ;
                    _sources += $(_r) ;

                    # Add library R.class to classes.
                    local _c = [ C.GristFiles $(TARGET) : $(_needJarPackageDirectory)/R.class ] ;
                    MakeLocate $(_c) : $(_c:DR=$(outputClassesDirectory)) ;
                    BINDING on $(_c) = $(_c:BS) ;
                    _classes += $(_c) ;
                }
            }
        }

        # The classes depend on the source Java files, the processed resource/AIDL files and any JAR files from other libraries we are compiling.
        Depends $(_classes) : $(_sources) $(resourceOutputFiles) $(_aidlCompiledFiles) ;

        # Flags.
        local nativeListDelimiter ;
        if $(OS) in MACOSX {
            nativeListDelimiter = \: ;
        } else {
            nativeListDelimiter = \; ;
        }

        local _classPath = $(SEARCH_SOURCE) $(linkLibs:TC/) $(outputClassesDirectory) ;
        _classPath =
                $(needJars:TC/)
                $(linkLibs:TC/)
                $(ANDROID.ANDROID.JAR:C/:Z=$(C.COMPILER_SUITE_SYMBOL))
        ;
        JFLAGS on $(_classes) += -classpath $(_classPath:J=$(nativeListDelimiter)) ;

        local _sourcePaths =
                $(sourcePaths:TC/)
                $(LOCATE_TARGET)
        ;
        JFLAGS on $(_classes) += -sourcepath $(_sourcePaths:J=$(nativeListDelimiter)) ;

        # Determine all of the built .jar files.
        local builtJars ;
        local _jar ;
        for _jar in $(needJars) {
            if $(BUILT:Z=$(_jar)) {
                builtJars += $(_jar) ;
            }
        }

        Depends $(_classes) : $(linkLibs) $(builtJars) ;

        if $(CONFIG) in debug release {
            JFLAGS on $(_classes) += -g ;
        } else {
            JFLAGS on $(_classes) += -g:none ;
        }

        # Set up the 'header' scanning rule.
        HDRRULE on $(_sources) = android._JavaHdrRule ;

        # Start of line, possible white space, 'import', possible white space, ANYTHING, possible whitespace, ';'
        HDRSCAN on $(_sources) = "^[     ]*import[     ]*(.*)[     ]*;" ;
        HDRGRIST on $(_sources) = $(C.ACTIVE_TOOLCHAIN_TARGET_GRIST) ;

        # Output of the compiler goes into the target directory, the compiler will create the output directory tree that
        # matches the output filenames we have set up in our dependency tree.
        OUTPUT_FOLDER on $(_classes) = $(outputClassesDirectory) ;

        # Action.
        android._JavaC $(_classes) : $(_sources) : $(C.COMPILER_SUITE_SYMBOL) ;

        # JAR file.
        local _jar = [ C.GristFiles $(TARGET) : $(TARGET).jar ] ;
        MakeLocate $(_jar) : $(LOCATE_TARGET) ;
        Depends $(C.ACTIVE_TOOLCHAIN_TARGET) : $(_jar) ;

        # Need access to root output folder as JAR tool will package up based on a this directory.
        OUTPUT_FOLDER on $(_jar) = $(outputClassesDirectory) ;

        # Need the relative class paths in order to archive.
        local relativeClasses ;
        local relativeClassWildcard ;
        for relativeClassWildcard in $(SOURCES:D)/*.class {  # */
            if ! $(relativeClassWildcard) in $(relativeClasses) {
                relativeClasses += $(relativeClassWildcard) ;
            }
        }
        RELATIVE_CLASSES on $(_jar) = $(relativeClasses) ;
        if application in $(OPTIONS) {
            # JAR file depends on classes (including R.class for libraries) and packaged R.class file.
            Depends $(_jar) : $(_classes) $(_packageRFile) ;
            UseCommandLine $(_jar) : $(_classes) $(_packageRFile) ;

            # Also need to package up R.class for each of our libraries...
            if $(needJars) {
                local _needJar ;
                for _needJar in $(needJars:GB) {
                    # Get package name for library.
                    local _needJarPackage = $(PACKAGE:Z=$(_needJar:G=$(C.ACTIVE_TOOLCHAIN_GRIST))) ;

                    # Convert package name into a relative directory.
                    local _needJarPackageDirectory = [ android._PackageToDirectory $(_needJarPackage) ] ;

                    RELATIVE_CLASSES on $(_jar) += $(_needJarPackageDirectory)/R*.class ;
                }
            }
        } else {
            # JAR file depends on classes.
            Depends $(_jar) : $(_classes) ;
            UseCommandLine $(_jar) : $(_classes) ;
        }

        # Action to make JAR file.
        android._Jar $(_jar) : $(_sources) : $(C.COMPILER_SUITE_SYMBOL) ;
        Clean $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(_jar) ;

        BUILT on $(_jar) = 1 ;
    }

    # Find all .class files for clean rule.
    local _classFiles = [ android._GlobRecursive $(outputClassesDirectory) : * ] ;
    _classFiles = $(_classFiles:I=.class) ;

    # Hook up the project specific clean for this TARGET.
    Depends clean : clean:$(TARGET) : $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) ;
    NotFile clean:$(TARGET) $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) ;
    Always clean:$(TARGET) $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) ;
    Clean $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(_jar) $(_classes) $(resourceOutputFiles) $(_classFiles) $(_packageRFile) $(resourceOutputFiles) $(_aidlCompiledFiles) ;
}


# Create application from given sources.
rule android.Application TARGET : SOURCES : OPTIONS {
    TARGET = [ C.ActiveTarget $(TARGET) ] ;

    # Build library out of the sources.
    android.Library $(TARGET) : $(SOURCES) : $(OPTIONS) application ;
}


if $(OS) = NT {

actions android._GradleInit {
    set JAVA_HOME=$(JAVA.HOME:C)
    cd "$(1:D\\)"
    call c:\gradle\bin\gradle.bat init --type basic --dsl groovy --project-name app --incubating
}


actions screenoutput android._Gradle {
    set JAVA_HOME=$(JAVA.HOME:C)
    set ANDROID_SDK_ROOT=$(ANDROID.SDK_ROOT)
    set ANDROID_NDK_ROOT=$(NDKROOT)
    set PATH=%ANDROID_SDK_ROOT%\platform-tools;%PATH%
    cd "$(2[1]:D\\)"
    call c:\gradle\bin\gradle.bat $(GRADLE_COMMAND)
}

actions screenoutput android._bundletool_build-apks {
    del $(1:C\\)
    set JAVA_HOME=$(JAVA.HOME:C)
    set ANDROID_SDK_ROOT=$(ANDROID.SDK_ROOT)
    set ANDROID_NDK_ROOT=$(NDKROOT)
    set PATH=%ANDROID_SDK_ROOT%\platform-tools;%PATH%
    cd "$(2[1]:D\\)"
    java -jar %ANDROID_SDK_ROOT%/tools/bundletool.jar build-apks --bundle $(2:C) --output $(1:C) --local-testing
}

actions screenoutput android._bundletool_install-apks {
    set JAVA_HOME=$(JAVA.HOME:C)
    set ANDROID_SDK_ROOT=$(ANDROID.SDK_ROOT)
    set ANDROID_NDK_ROOT=$(NDKROOT)
    set PATH=%ANDROID_SDK_ROOT%\platform-tools;%PATH%
    cd "$(2[1]:D\\)"
    java -jar %ANDROID_SDK_ROOT%/tools/bundletool.jar install-apks --apks $(2:C)
}

} else {

    #export JAVA_HOME=$(JAVA.HOME:C)
actions android._GradleInit {
    cd $(1:DC)
    gradle init --type basic --dsl groovy --project-name app
}


    #export JAVA_HOME=$(JAVA.HOME:C)
    #export PATH=$JAVA_HOME/bin:$ANDROID_SDK_ROOT/platform-tools:$PATH
actions screenoutput android._Gradle {
    export ANDROID_SDK_ROOT=$(ANDROID.SDK_ROOT)
    export ANDROID_NDK_ROOT=$(NDKROOT)
    export PATH=$ANDROID_SDK_ROOT/platform-tools:$PATH
    cd $(2[1]:DC)
    ./gradlew $(GRADLE_COMMAND)
}

actions screenoutput android._bundletool_build-apks {
    export ANDROID_SDK_ROOT=$(ANDROID.SDK_ROOT)
    export ANDROID_NDK_ROOT=$(NDKROOT)
    export PATH=$ANDROID_SDK_ROOT/platform-tools:$PATH
    cd $(2[1]:DC)
    java -jar %ANDROID_SDK_ROOT%/tools/bundletool.jar build-apks --bundle $(2:C) --output $(1:C) --local-testing
}

actions screenoutput android._bundletool_build-apks {
    export ANDROID_SDK_ROOT=$(ANDROID.SDK_ROOT)
    export ANDROID_NDK_ROOT=$(NDKROOT)
    export PATH=$ANDROID_SDK_ROOT/platform-tools:$PATH
    cd $(2[1]:DC)
    java -jar %ANDROID_SDK_ROOT%/tools/bundletool.jar install-apks --apks $(2:C)
}

}


# Create the APK for an Android application.
rule android.Package TARGET : TOOLCHAINS : OPTIONS {
    # Activate the requested target.
    TARGET = [ C.ActiveTarget $(TARGET) ] ;

    # Get a list of all of the architectures to be supported.
    #
    # This is way slower than it could be, because it requires activating the toolchain to
    # read out the needed information. There needs to be a way to access data directly from
    # the toolchain.
    #
    # For now, though, this is sufficient.
    TOOLCHAINS ?= $(C.ACTIVE_TOOLCHAIN) ;

    local saveActiveToolchainSpec = $(C.ACTIVE_TOOLCHAIN_SPEC) ;
    local architectures ;
    local toolchain ;
    for toolchain in $(TOOLCHAINS) {
        C.Toolchain $(toolchain) ;
        if ! $(C.ARCHITECTURE) in $(architectures) {
            architectures += $(C.ARCHITECTURE) ;
        }
    }
    C.Toolchain $(saveActiveToolchainSpec) ;
    C.ActiveTarget $(TARGET) ;

    ANDROID.VERSION_NAME on $(C.ACTIVE_TOOLCHAIN_TARGET) ?= 1.0 ;
    ANDROID.VERSION_CODE on $(C.ACTIVE_TOOLCHAIN_TARGET) ?= 1 ;

    if $(ANDROID.USE_GRADLE) = 1 {
        local packageOutputPath = $(ANDROID.PACKAGE_OUTPUT_PATH:Z=$(C.ACTIVE_TOOLCHAIN_TARGET):E=$(ALL_LOCATE_TARGET)/../package) ;

        local GRADLE_OUTPUT_DIRECTORY = @($(ALL_LOCATE_TARGET)/gradle:R=) ;
        GRADLE_OUTPUT_DIRECTORY on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(GRADLE_OUTPUT_DIRECTORY) ;
        local grist = $(C.ACTIVE_TOOLCHAIN_GRIST)|gradle ;
        local gradleTarget = $(TARGET:G=$(grist)) ;
        NotFile $(gradleTarget) ;
        GRADLE_TARGET on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(gradleTarget) ;

        CleanTree $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(GRADLE_OUTPUT_DIRECTORY) ;

        # gradlew
        local gradlew ;
        if $(OS) = NT {
            gradlew = @(gradlew.bat:G=$(grist)) ;
        } else {
            gradlew = @(gradlew:G=$(grist)) ;
        }
        MakeLocate $(gradlew) : $(GRADLE_OUTPUT_DIRECTORY) ;
        Depends $(gradleTarget) : $(gradlew) ;
        android._GradleInit $(gradlew) : : $(C.COMPILER_SUITE_SYMBOL) ;

        if $(OS) = NT {
            # env.bat
            local envgradlew.bat = @(envgradlew.bat:G=$(grist)) ;
            MakeLocate $(envgradlew.bat) : $(GRADLE_OUTPUT_DIRECTORY) ;
            CONTENTS on $(envgradlew.bat) = "@setlocal
@set JAVA_HOME=$(JAVA.HOME:Z=$(C.COMPILER_SUITE_SYMBOL))
@set ANDROID_SDK_ROOT=$(ANDROID.SDK_ROOT:Z=$(C.COMPILER_SUITE_SYMBOL))
@set ANDROID_NDK_ROOT=$(NDKROOT:Z=$(C.COMPILER_SUITE_SYMBOL))
@set PATH=%ANDROID_SDK_ROOT%\platform-tools;%PATH%
@call %~dp0gradlew.bat %*
" ;
            UseCommandLine $(envgradlew.bat) : $(CONTENTS:Z=$(envgradlew.bat)) ;
            WriteFile $(envgradlew.bat) ;
            Depends $(gradleTarget) : $(envgradlew.bat) : $(gradlew) ;
        }

        #
        local jniLibsDirectory = $(GRADLE_OUTPUT_DIRECTORY)/jniLibs ;

        # Native libs.
        local nativeLibs =
            $(ANDROID.NATIVELIBS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))
            $(ANDROID.NATIVELIBS:Z=$(C.ACTIVE_TOOLCHAIN_*))
        ;

        local hasNativeLibs ;
        local toolchain ;
        for toolchain in $(TOOLCHAINS) {
            local linkTargets = [ C.GetLinkTargets $(nativeLibs) : $(toolchain) ] ;

            local linkTarget ;
            for linkTarget in $(linkTargets) {
                if $(linkTarget:S) != .so {
                    continue ;
                }

                hasNativeLibs = true ;

                # Copy .so into output directory.
                local _outputSo = $(linkTarget:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
                local _binding = $(linkTarget:TBS) ;
                switch $(C.ARCHITECTURE:Z=$(linkTarget)) {
                    case arm :
                        _outputSo = $(_outputSo)|arm ;
                        BINDING on $(_outputSo) = $(_binding) ;
                        MakeLocate $(_outputSo) : $(jniLibsDirectory)/$(C.CONFIG)/armeabi ;
                    case armv7-a :
                        _outputSo = $(_outputSo)|armv7-a ;
                        BINDING on $(_outputSo) = $(_binding) ;
                        MakeLocate $(_outputSo) : $(jniLibsDirectory)/$(C.CONFIG)/armeabi-v7a ;
                    case arm64 :
                        _outputSo = $(_outputSo)|arm64-v8a ;
                        BINDING on $(_outputSo) = $(_binding) ;
                        MakeLocate $(_outputSo) : $(jniLibsDirectory)/$(C.CONFIG)/arm64-v8a ;
                    case x86 :
                        _outputSo = $(_outputSo)|x86 ;
                        BINDING on $(_outputSo) = $(_binding) ;
                        MakeLocate $(_outputSo) : $(jniLibsDirectory)/$(C.CONFIG)/x86 ;
                }

                # Output file depends on input stripped SO file.
                #Depends $(_outputSo) : $(linkTarget) ;

                CopyFile $(gradleTarget) : $(_outputSo) : $(linkTarget) ;
                UseCommandLine $(_outputSo) : $(source:T) ;
                Clean $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(_outputSo) ;
            }
        }

        local globalNativePrebuiltLibs =
            $(ANDROID.NATIVEPREBUILTLIBS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))
            $(ANDROID.NATIVEPREBUILTLIBS:Z=$(C.ACTIVE_TOOLCHAIN_*))
        ;

        local globalNativePrebuiltLibraryDirectories =
            $(ANDROID.NATIVEPREBUILTLIBRARYDIRECTORIES:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))
            $(ANDROID.NATIVEPREBUILTLIBRARYDIRECTORIES:Z=$(C.ACTIVE_TOOLCHAIN_*))
        ;

        local toolchain ;
        for toolchain in $(TOOLCHAINS) {
            local toolChainTarget = $(TARGET:G=$(toolchain)) ;
            local toolChain_* = @(C.*:G=$(toolchain)) ;

            # Native prebuilt libraries.
            local nativePrebuiltLibs = $(ANDROID.NATIVEPREBUILTLIBS:Z=$(toolchainTarget)) ;
            nativePrebuiltLibs += $(globalNativePrebuiltLibs) ;

            local nativePrebuiltLibraryDirectories =
                $(ANDROID.NATIVEPREBUILTLIBRARYDIRECTORIES:Z=$(toolChainTarget))
                $(ANDROID.NATIVEPREBUILTLIBRARYDIRECTORIES:Z=$(toolChain_*)) ;

            local ndkSysRootLibPaths = $(NDK_SYSROOT_LIBPATHS:Z=$(toolChain_*)) ;

            local nativePrebuiltLib ;
            for nativePrebuiltLib in $(nativePrebuiltLibs) {
                # Get final filenames.
                local nativeLibraryFullName = lib$(nativePrebuiltLib).so ;

                local architecture ;
                local found ;
                for keyValue in $(TOOLCHAIN_SPEC_OPTIONS:Z=$(toolchain)) {
                    local info = [ Split $(keyValue) : "=" ] ;
                    if $(info[1]) = C.ARCHITECTURE {
                        architecture = $(info[2]) ;
                        break ;
                    }
                }

                # Copy it into output directory.
                #for architecture in $(architectures) {
                {
                    local target = $(nativeLibraryFullName:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)|$(architecture)) ;
                    local source = $(nativeLibraryFullName:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)|$(architecture)|source) ;

                    switch $(architecture) {
                        case arm :
                            SEARCH on $(source) +=
                                $(nativePrebuiltLibraryDirectories)/armeabi
                                $(nativePrebuiltLibraryDirectories)/armeabi-v7a
                                $(ndkSysRootLibPaths)
                            ;
                            MakeLocate $(target) : $(jniLibsDirectory)/$(C.CONFIG)/armeabi ;
                        case armv7-a :
                            SEARCH on $(source) +=
                                $(nativePrebuiltLibraryDirectories)/armeabi-v7a
                                $(ndkSysRootLibPaths)
                            ;
                            MakeLocate $(target) : $(jniLibsDirectory)/$(C.CONFIG)/armeabi-v7a ;
                        case arm64 :
                            SEARCH on $(source) +=
                                $(nativePrebuiltLibraryDirectories)/arm64-v8a
                                $(ndkSysRootLibPaths)
                            ;
                            MakeLocate $(target) : $(jniLibsDirectory)/$(C.CONFIG)/arm64-v8a ;
                        case x86 :
                            SEARCH on $(source) +=
                                $(nativePrebuiltLibraryDirectories)/x86
                                $(ndkSysRootLibPaths)
                            ;
                            MakeLocate $(target) : $(jniLibsDirectory)/$(C.CONFIG)/x86 ;
                    }

                    CopyFile $(gradleTarget) : $(target) : $(source) ;
                    UseCommandLine $(target) : $(source:T) ;
                    Clean $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(target) ;
                }
            }
        }

        local _keyStorePath =
            $(ANDROID.KEYSTORE_PATH:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))
            $(ANDROID.KEYSTORE_PATH:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;
        local _keyStorePassword =
            $(ANDROID.KEYSTORE_PASSWORD:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))
            $(ANDROID.KEYSTORE_PASSWORD:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;
        local _keyStoreKeyAlias =
            $(ANDROID.KEYSTORE_KEY_ALIAS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))
            $(ANDROID.KEYSTORE_KEY_ALIAS:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;
        local _keyStoreKeyPassword =
            $(ANDROID.KEYSTORE_KEY_PASSWORD:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))
            $(ANDROID.KEYSTORE_KEY_PASSWORD:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

        if ! $(_keyStorePath) || ! $(_keyStorePassword) || ! $(_keyStoreKeyAlias) || ! $(_keyStoreKeyPassword) {
            Exit *** error \: Must call android.Sign and specify keystore path, keystore password, key alias, and key password ;
        }

        #########################################################################################
        # build.gradle
        #########################################################################################
        {
            local contents ;
            contents += "// Top-level build file where you can add configuration options common to all sub-projects/modules.

plugins {
    id 'com.android.application' version '8.1.0' apply false
}
" ;
            #contents += $(ANDROID.GRADLE_ALLPROJECTS_REPOSITORIES:Z=$(C.COMPILER_SUITE_SYMBOL):E=) ;
            #contents += "    }
#}
#
            contents += "
task clean(type: Delete) {
    delete rootProject.buildDir
}
" ;
            local root-build.gradle = @(build.gradle:G=$(grist)) ;
            MakeLocate $(root-build.gradle) : $(GRADLE_OUTPUT_DIRECTORY) ;
            CONTENTS on $(root-build.gradle) = $(contents) ;
            UseCommandLine $(root-build.gradle) : $(CONTENTS:Z=$(root-build.gradle)) ;
            WriteFile $(root-build.gradle) ;
            Depends $(gradleTarget) : $(root-build.gradle) : $(gradlew) ;
        }

        #########################################################################################
        # gradle.properties
        #########################################################################################
        {
            local root-gradle.properties = @(gradle.properties:G=$(grist)) ;
            MakeLocate $(root-gradle.properties) : $(GRADLE_OUTPUT_DIRECTORY) ;
            CONTENTS on $(root-gradle.properties) = $(ANDROID.GRADLE_PROPERTIES:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
            UseCommandLine $(root-gradle.properties) : $(CONTENTS:Z=$(root-gradle.properties)) ;
            WriteFile $(root-gradle.properties) ;
            Depends $(gradleTarget) : $(root-gradle.properties) : $(gradlew) ;
        }

        #########################################################################################
        # local.properties
        #########################################################################################
        {
            local root-local.properties = @(local.properties:G=$(grist)) ;
            MakeLocate $(root-local.properties) : $(GRADLE_OUTPUT_DIRECTORY) ;
            CONTENTS on $(root-local.properties) = "sdk.dir=$(ANDROID.SDK_ROOT:Z=$(C.COMPILER_SUITE_SYMBOL))$(NEWLINE)$(ANDROID.GRADLE_LOCAL_PROPERTIES:Z=$(C.ACTIVE_TOOLCHAIN_TARGET):E="")" ;
            UseCommandLine $(root-local.properties) : $(CONTENTS:Z=$(root-local.properties)) ;
            WriteFile $(root-local.properties) ;
            Depends $(gradleTarget) : $(root-local.properties) : $(gradlew) ;
        }

        #########################################################################################
        # settings.gradle
        #########################################################################################
        {
            local contents = "pluginManagement {
    repositories {
        gradlePluginPortal()
        google()
        mavenCentral()
    }
}
" ;

            local versionCatalogFile = $(ANDROID.GRADLE_VERSION_CATALOG_FILE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
            if $(versionCatalogFile) {
                versionCatalogFile = [ MakeRelativePath $(versionCatalogFile:T) : $(GRADLE_OUTPUT_DIRECTORY) ] ;
                contents += "
dependencyResolutionManagement {
    versionCatalogs {
        libs {
            from(files(\"$(versionCatalogFile)\"))
        }
    }
}
" ;
            }

contents += "
rootProject.name = 'app'
include ':app'
" ;
            if $(ANDROID.ASSET_PACKS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) {
                local packName ;
                for packName in $(ANDROID.ASSET_PACKS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) {
                    contents += "include ':$(packName)'$(NEWLINE)" ;
                }
            }

            local root-settings.gradle = @(settings.gradle:G=$(grist)) ;
            MakeLocate $(root-settings.gradle) : $(GRADLE_OUTPUT_DIRECTORY) ;
            CONTENTS on $(root-settings.gradle) = $(contents) ;
            UseCommandLine $(root-settings.gradle) : $(CONTENTS:Z=$(root-settings.gradle)) ;
            WriteFile $(root-settings.gradle) ;
            Depends $(gradleTarget) : $(root-settings.gradle) : $(gradlew) ;
        }

        #########################################################################################
        # app/build.gradle
        {
            local gradleAppOutputDirectory = $(GRADLE_OUTPUT_DIRECTORY)/app ;

            local _relativeKeyStorePath = [ MakeRelativePath $(_keyStorePath:T) : $(gradleAppOutputDirectory) ] ;

            # Resources
            local sdkVersion = $(ANDROID.SDK_TARGET_VERSION:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
            if ! $(sdkVersion) {
                sdkVersion = $(sdkMinimumVersion) ;
                if ! $(sdkVersion) {
                    sdkVersion = $(ANDROID.SDK_VERSION:Z=$(C.COMPILER_SUITE_SYMBOL)) ;
                }
            }
            local sdkMinimumVersion = $(ANDROID.SDK_MINIMUM_VERSION:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
            local sdkCompileVersion = $(ANDROID.SDK_COMPILE_VERSION:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
            if ! $(sdkCompileVersion) {
                local firstToolchainCompilerSuiteSymbol = [ C._retrieveCompilerSuiteSymbol $(TOOLCHAINS[1]) ] ;
                sdkCompileVersion = $(ANDROID.SDK_VERSION:Z=$(firstToolchainCompilerSuiteSymbol)) ;
            }
            local versionName = $(ANDROID.VERSION_NAME:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
            local versionCode = $(ANDROID.VERSION_CODE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;

            local abiFilters ;
            local architecture ;
            for architecture in $(architectures) {
                switch $(architecture) {
                    case arm :
                        Exit * Fix me ;
                    case armv7-a :
                        abiFilters += 'armeabi-v7a' ;
                    case arm64 :
                        abiFilters += 'arm64-v8a' ;
                    case x86 :
                        abiFilters += 'x86' ;
                }
            }

            local androidManifest = [ MakeRelativePath $(ANDROID.MANIFEST:Z=$(C.ACTIVE_TOOLCHAIN_TARGET):T) : $(gradleAppOutputDirectory) ] ;
            local applicationId = $(ANDROID.APPLICATION_ID:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
            applicationId ?= $(ANDROID.PACKAGE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;

            local contents = "" ;
            contents += "plugins {
    id 'com.android.application'
}

apply from: 'buildHelpers.gradle'

android {
    namespace '$(applicationId)'
    compileSdkVersion $(sdkCompileVersion:E=$(sdkVersion))
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    defaultConfig {
        minSdkVersion $(sdkMinimumVersion:E=$(sdkVersion))
        targetSdkVersion $(sdkVersion)
" ;
            local ndkVersionComplete = $(NDK_VERSION_COMPLETE:Z=$(C.COMPILER_SUITE_SYMBOL)) ;
            if $(ndkVersionComplete) {
                contents += "        ndkVersion '$(ndkVersionComplete)'$(NEWLINE)" ;
            }
            if $(versionCode) {
                contents += "        versionCode $(versionCode)$(NEWLINE)" ;
            }
            if $(versionName) {
                contents += "        versionName '$(versionName)'$(NEWLINE)" ;
            }
            contents += "        ndk {
            abiFilters $(abiFilters:J=,)
        }
    }
    signingConfigs {
        release {
            storeFile file('$(_relativeKeyStorePath)')
            storePassword '$(_keyStorePassword)'
            keyAlias '$(_keyStoreKeyAlias)'
            keyPassword '$(_keyStoreKeyPassword)'
        }
    }
" ;
            contents += "
    buildTypes {
        release {
            //debuggable true
            minifyEnabled $(ANDROID.MINIFY:Z=$(C.ACTIVE_TOOLCHAIN_TARGET):E=false)
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release
        }
        debug {
            debuggable true
        }
    }
" ;
            contents += "
    sourceSets.main {
        manifest.srcFile '$(androidManifest)'
        java.srcDirs += [
" ;

            local sourcePaths = $(JAVA.SOURCEPATHS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
            sourcePaths ?= $(SUBDIR) ;
            sourcePaths = [ MakeRelativePath $(sourcePaths) : $(gradleAppOutputDirectory) ] ;

            local assetsPaths = [ MakeRelativePath $(ANDROID.ASSETS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) : $(gradleAppOutputDirectory) ] ;

            contents += "            '$(sourcePaths)',$(NEWLINE)" ;
            contents += "        ]
        aidl.srcDirs += [
" ;
            contents += "            '$(sourcePaths)',$(NEWLINE)" ;
            contents += "        ]
        assets.srcDirs += [
" ;
            contents += "            '$(assetsPaths)',$(NEWLINE)" ;
            contents += "        ]$(NEWLINE)" ;

            local resourcesPaths = [ MakeRelativePath $(ANDROID.RESOURCES:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) : $(gradleAppOutputDirectory) ] ;
            contents += "        res.srcDirs += [$(NEWLINE)" ;
            contents += "            '$(resourcesPaths)',$(NEWLINE)" ;
            contents += "        ]
    }
" ;

    if $(hasNativeLibs) {
        local configs = debug release ;
        local config ;
        for config in $(configs) {
            contents += "    sourceSets.$(config) {$(NEWLINE)" ;
            local nativeLibsPaths = [ MakeRelativePath $(jniLibsDirectory)/$(config) : $(gradleAppOutputDirectory) ] ;
            contents += "        jniLibs.srcDirs += [$(NEWLINE)" ;
            contents += "            '$(nativeLibsPaths)'$(NEWLINE)" ;
            contents += "        ]$(NEWLINE)" ;
            contents += "    }$(NEWLINE)" ;
        }
    }

    contents += "
    androidResources {
" ;
            contents += "        ignoreAssetsPattern '!.svn:!.git:!.ds_store:!*.scc:.*:<dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~'$(NEWLINE)" ;
            contents += "        noCompress '$(ANDROID.UNCOMPRESSED_ASSET_EXTENSIONS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))'$(NEWLINE)" ;
            contents += "
    }
    lint {
        abortOnError false
        checkReleaseBuilds false
    }
" ;

    local buildFeaturesLines = $(ANDROID.GRADLE_BUILD_FEATURES_LINES:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
    if $(buildFeaturesLines) {
        contents += "    buildFeatures {
$(buildFeaturesLines:J=$(NEWLINE))
    }
" ;
    }

    {
        local assetPacks = $(ANDROID.ASSET_PACKS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
        if $(assetPacks) {
            local assetStrings = \":$(assetPacks)\" ;
            contents += "    assetPacks = [$(assetStrings:J=, )]$(NEWLINE)" ;
        }
    }

contents += "}

repositories {
    mavenCentral()
    google()
" ;
            contents += $(ANDROID.GRADLE_REPOSITORIES:Z=$(C.COMPILER_SUITE_SYMBOL):E="") ;
            contents += "}

dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
" ;

            contents += "$(ANDROID.GRADLE_DEPENDENCIES:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))$(NEWLINE)" ;
            contents += "}$(NEWLINE)" ;

            local app-build.gradle = @(build.gradle:G=$(grist)|app) ;
            MakeLocate $(app-build.gradle) : $(gradleAppOutputDirectory) ;
            UseCommandLine $(app-build.gradle) : $(contents) ;
            CONTENTS on $(app-build.gradle) = $(contents) ;
            WriteFile $(app-build.gradle) ;
            Depends $(gradleTarget) : $(app-build.gradle) : $(gradlew) ;
        }

        #########################################################################################
        # app/buildHelpers.gradle
        #########################################################################################
        {
            local gradleAppOutputDirectory = $(GRADLE_OUTPUT_DIRECTORY)/app ;
            local relativePackageOutputPath = [ MakeRelativePath $(packageOutputPath) : $(gradleAppOutputDirectory) ] ;

            #String name = \"$(TARGET)-${variant.versionName}-${output.baseName}.apk\"
            #def destinationFolder = \"$(packageOutputPath)${output.baseName.replace(\"-\", \"/\")}\"
            #print \"Copying APK folder from: $sourceFolder into $destinationFolder\\n\"
            local contents ;
            contents += "// From https://stackoverflow.com/questions/22833297/how-to-define-apk-output-directory-when-using-gradle$(NEWLINE)" ;
            contents += "def archiveBuildTypes = [\"debug\", \"release\"]$(NEWLINE)" ;
            contents += "def distFolder = \"$(relativePackageOutputPath)\"$(NEWLINE)" ;

            contents += "
android {
    applicationVariants.all { variant ->
        variant.outputs.all { output ->
            if (variant.buildType.name in archiveBuildTypes) {
                // Update output filename
                if (variant.versionName != null) {
                    String name = \"$(TARGET)-${variant.versionName}-${variant.buildType.name}.apk\"
                    outputFileName = new File(name)
                }
                def taskSuffix = variant.name.capitalize()
                def assembleTaskName = \"assemble${taskSuffix}\"
                if (tasks.findByName(assembleTaskName)) {
                    def copyAPKFolderTask = tasks.create(name: \"archive${taskSuffix}\", type: org.gradle.api.tasks.Copy) {
                        description \"Archive/copy APK folder to a shared folder.\"
                        def sourceFolder = \"$buildDir/outputs/apk/${output.baseName.replace(\"-\", \"/\")}\"
                        def destinationFolder = \"$(relativePackageOutputPath)\"
                        from(sourceFolder)
                        into destinationFolder
                        eachFile { file ->
                            file.path = file.name // so we have a \"flat\" copy
                        }
                        includeEmptyDirs = false
                    }
                    tasks[assembleTaskName].finalizedBy = [copyAPKFolderTask]
                }
            }
        }
    }
}
" ;

            local app-buildHelpers.gradle = @(buildHelpers.gradle:G=$(grist)|app) ;
            MakeLocate $(app-buildHelpers.gradle) : $(gradleAppOutputDirectory) ;
            UseCommandLine $(app-buildHelpers.gradle) : $(contents) ;
            CONTENTS on $(app-buildHelpers.gradle) = $(contents) ;
            WriteFile $(app-buildHelpers.gradle) ;
            Depends $(gradleTarget) : $(app-buildHelpers.gradle) : $(gradlew) ;
        }

        #########################################################################################
        # app/proguard-rules.pro
        {
            local contents ;
            contents += "
# Add project specific ProGuard rules here.
# By default, the flags in this file are appended to flags specified
# in [sdk]/tools/proguard/proguard-android.txt
# You can edit the include path and order by changing the proguardFiles
# directive in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html
" ;
            contents += $(ANDROID.PROGUARD_LINES:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;

            local app-proguard-rules.pro = @(proguard-rules.pro:G=$(grist)|app) ;
            MakeLocate $(app-proguard-rules.pro) : $(GRADLE_OUTPUT_DIRECTORY)/app ;
            UseCommandLine $(app-proguard-rules.pro) : $(contents) ;
            CONTENTS on $(app-proguard-rules.pro) = $(contents) ;
            WriteFile $(app-proguard-rules.pro) ;
            Depends $(gradleTarget) : $(app-proguard-rules.pro) : $(gradlew) ;
        }

        #########################################################################################
        #if $(ANDROID_BUNDLE) = 1
        {
            #########################################################################################
            # Write asset pack directories
            if $(ANDROID.ASSET_PACKS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) {
                local packName ;
                for packName in $(ANDROID.ASSET_PACKS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) {
                    local assetPackOutputDirectory = $(GRADLE_OUTPUT_DIRECTORY)/$(packName) ;

                    local contents = "
apply plugin: 'com.android.asset-pack'
//plugins {
//    id 'com.android.asset-pack'
//}

assetPack {
    packName = \"$(packName)\"

    dynamicDelivery {
        deliveryType = \"$(ANDROID.ASSET_PACK.$(packName).TYPE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))\"
    }
}
" ;

                    # Set up the packTarget to collect all of the targets that go into the asset pack.
                    local packGrist = $(grist)|$(packName) ;
                    local packTarget = $(TARGET:G=$(packGrist)) ;
                    Always $(packTarget) ;
                    NotFile $(packTarget) ;
                    Depends $(gradleTarget) : $(packTarget) ;

                    # packName/build.gradle
                    local assetpack-build.gradle = @(build.gradle:G=$(packGrist)) ;
                    MakeLocate $(assetpack-build.gradle) : $(assetPackOutputDirectory) ;
                    UseCommandLine $(assetpack-build.gradle) : $(contents) ;
                    CONTENTS on $(assetpack-build.gradle) = $(contents) ;
                    WriteFile $(assetpack-build.gradle) ;
                    Depends $(packTarget) : $(assetpack-build.gradle) : $(gradlew) ;

                    # If wildcards were requested to be copied, do so here.
                    local assetsOutputDirectory = $(assetPackOutputDirectory)/src/main/assets ;
                    local destinationRelativePath = $(ANDROID.ASSET_PACK.$(packName).DESTINATION_RELATIVE_PATH:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
                    if $(destinationRelativePath) != "" {
                        assetsOutputDirectory = $(ANDROID.ASSET_PACK.$(packName).DESTINATION_RELATIVE_PATH:R=$(assetsOutputDirectory):Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
                    }

                    local processedFiles ;
                    local wildcard ;
                    for wildcard in $(ANDROID.ASSET_PACK.$(packName).WILDCARDS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) {
                        local wildcardSplit = [ Split $(wildcard) : "|" ] ;
                        local files = @($(wildcardSplit[1])/$(wildcardSplit[2]):W=$(wildcardSplit[1])/) ;
                        files -= $(processedFiles) ;

                        local targets = $(files:G=$(packGrist)) ;
                        Depends $(packTarget) : $(targets) ;
                        MakeLocate $(targets) : $(assetsOutputDirectory) : combine ;
                        Clean $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(targets) ;

                        local sources = $(files:G=$(packGrist)|source) ;
                        SEARCH on $(sources) = $(wildcardSplit[1]) ;

                        local target ;
                        for target in $(targets) {
                            local source = $(target:G=$(packGrist)|source) ;

                            Depends $(target) : $(source) ;
                            Copy1File $(target) : $(source) ;
                        }
                    }

                    # If targets were requested to be copied from, do so here.
                    local source ;
                    for source in $(ANDROID.ASSET_PACK.$(packName).TARGETS_TO_COPY:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) {
                        local outputRelativePath = $(OUTPUT_RELATIVE_PATH:Z=$(source)) ;
                        local outputDirectory = $(assetsOutputDirectory) ;
                        if $(outputRelativePath) != "" {
                            outputDirectory = $(outputDirectory)/$(outputRelativePath) ;
                        }

                        local target = $(source:G=$(packGrist)) ;
                        Depends $(packTarget) : $(target) : $(source) ;
                        MakeLocate $(target) : $(assetsOutputDirectory) : combine ;
                        Clean $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(target) ;

                        Copy1File $(target) : $(source) ;
                    }

                    # Clean any leftover fluff.
                    CLEAN.ROOTS on $(packTarget) = $(assetPackOutputDirectory)/**@-**/build/ ;
                    CLEAN.KEEP_TARGETS on $(packTarget) = [ DependsList $(packTarget) ] ;
                    CLEAN.VERBOSE on $(packTarget) = 1 ;
                    #CLEAN.NOOP on $(packTarget) = 1 ;
                    CleanRoots $(packTarget) ;
                }
            }

            # Set up the .aab dependencies.
            local _aab = $(TARGET)-$(ANDROID.VERSION_NAME:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))-$(C.CONFIG).aab ;
            _aab = [ C.GristFiles $(TARGET) : $(_aab) ] ;
            AAB_TARGET on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(_aab) ;

            MakeLocate $(_aab) : $(packageOutputPath:E=$(LOCATE_TARGET)) ;
            Depends $(_aab) : $(gradleTarget) ;

            if $(C.CONFIG) = debug {
                GRADLE_COMMAND on $(_aab) = bundleDebug ;
            } else {
                GRADLE_COMMAND on $(_aab) = bundleRelease ;
            }
            Always $(_aab) ;
            MightNotUpdate $(_aab) ;
            android._Gradle $(_aab) : [ DependsList $(gradleTarget) ] : $(C.COMPILER_SUITE_SYMBOL) ;

            # Make target depend on our aligned (signed) APK.
            #Depends all : $(TARGET) : $(_apk) ;
            # Set up the build-aab target.
            local _signed.aab = $(_aab:S=.signed.aab) ;
            SIGNED_AAB_TARGET on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(_signed.aab) ;
            MakeLocate $(_signed.aab) : $(packageOutputPath)/_signed ;
            BINDING on $(_signed.aab) = $(_aab:BS) ;
            Depends build-aab:$(TARGET) : $(_signed.aab) : $(_aab) ;
            Always build-aab:$(TARGET) ;
            NotFile build-aab:$(TARGET) ;

            # Sign the .aab.
            KEYSTORE_PATH on $(_signed.aab) = $(_keyStorePath) ;
            KEYSTORE_PASSWORD on $(_signed.aab) = $(_keyStorePassword) ;
            KEYSTORE_KEY_ALIAS on $(_signed.aab) = $(_keyStoreKeyAlias) ;
            KEYSTORE_KEY_PASSWORD on $(_signed.aab) = $(_keyStoreKeyPassword) ;

            Depends $(_signed.aab) : $(_keystorePath) ;
            UseCommandLine $(_signed.aab) : $(_keyStorePassword) $(_keyStoreKeyAlias) $(_keyStoreKeyPassword) ;

            Copy1File $(_signed.aab) : $(_aab) ;
            android._SignAab $(_signed.aab) : $(_aab) : $(C.COMPILER_SUITE_SYMBOL) ;

            # Set up the build-apks target.
            local _apks = $(_aab:S=.apks) ;
            MakeLocate $(_apks) : $(packageOutputPath:E=$(LOCATE_TARGET)) ;
            Depends $(_apks) : $(_signed.aab) ;
            #MightNotUpdate $(_apks) ;
            android._bundletool_build-apks $(_apks) : $(_signed.aab) : $(C.COMPILER_SUITE_SYMBOL) ;

            Depends build-apks:$(TARGET) : $(_apks) ;
#            Always build-apks:$(TARGET) ;
            NotFile build-apks:$(TARGET) ;

            # Set up an install target.
            Depends install-apks:$(TARGET) : $(_apks) ;
            Always install-apks:$(TARGET) ;
            NotFile install-apks:$(TARGET) ;
            android._bundletool_install-apks install-apks:$(TARGET) : $(_apks) : $(C.COMPILER_SUITE_SYMBOL) ;

            #return ;
        }

        # Set up the .apk dependencies.
        local _apk = $(TARGET)-$(ANDROID.VERSION_NAME:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))-$(C.CONFIG).apk ;
        _apk = [ C.GristFiles $(TARGET) : $(_apk) ] ;
        APK_TARGET on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(_apk) ;

        MakeLocate $(_apk) : $(packageOutputPath:E=$(LOCATE_TARGET)) ;
        Depends $(_apk) : $(gradleTarget) ;

        if $(C.CONFIG) = debug {
            GRADLE_COMMAND on $(_apk) = assembleDebug ;
        } else {
            GRADLE_COMMAND on $(_apk) = assembleRelease ;
        }
        Always $(_apk) ;
        #MightNotUpdate $(_apk) ;
        android._Gradle $(_apk) : [ DependsList $(gradleTarget) ] : $(C.COMPILER_SUITE_SYMBOL) ;

        # Make target depend on our aligned (signed) APK.
        Depends all : $(TARGET) : $(_apk) ;

        # To help deploy the APK generate a little launcher batch.
    #    local _deploy = [ C.GristFiles $(TARGET) : deploy.bat ] ;
    #    MakeLocate $(_deploy) : $(LOCATE_TARGET) ;
    #    local package = $(ANDROID.PACKAGE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
    #    local adb = $(ANDROID.ADB:Z=$(C.COMPILER_SUITE_SYMBOL)) ;
    #    local _deployContents = "pushd %~dp0 & $(adb:TC) uninstall $(package) & $(adb:TC) install $(_alignedApk:TC) & popd" ;
    #    CONTENTS on $(_deploy) = $(_deployContents) ;
    #    WriteFile $(_deploy) ;
    #    UseCommandLine $(_deploy) : $(_deployContents) ;
    #    Depends $(TARGET) : $(_deploy) ;

        # Set up an install target.
        Depends install:$(TARGET) : $(_apk) ;
        Always install:$(TARGET) ;
        NotFile install:$(TARGET) ;
        android._Install install:$(TARGET) : $(_apk) : $(C.COMPILER_SUITE_SYMBOL) ;

        # Set up an auto-install if requested.
        if install in $(OPTIONS) {
            Depends autoinstall:$(TARGET) : $(_apk) ;
            NotFile autoinstall:$(TARGET) ;
            android._Install autoinstall:$(TARGET) : $(_apk) : $(C.COMPILER_SUITE_SYMBOL) ;
            Depends $(TARGET) : autoinstall:$(TARGET) ;
        }

        # Set up an uninstall target.
        Always uninstall:$(TARGET) ;
        NotFile uninstall:$(TARGET) ;
        local applicationId = $(ANDROID.APPLICATION_ID:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
        applicationId ?= $(ANDROID.PACKAGE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
        PACKAGE on uninstall:$(TARGET) = $(applicationId) ;
        android._Uninstall uninstall:$(TARGET) : : $(C.COMPILER_SUITE_SYMBOL) ;

        # Depend on the link targets.
        Depends $(C.ACTIVE_TOOLCHAIN_TARGET) : $(linkTargets) ;

        # Hook up the project specific clean for this TARGET.
        Depends clean : clean:$(TARGET) : $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) ;
        NotFile clean:$(TARGET) $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) ;
        Always clean:$(TARGET) $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) ;
        Clean $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(_deploy) $(_alignedApk) ;

        return ;
    }

    # JARs that we depend on.
    local needJars = $(JAVA.NEEDJARS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;

    local _applicationJar = [ C.GristFiles $(TARGET) : $(TARGET).jar ] ;
    MakeLocate $(_applicationJar) : $(LOCATE_TARGET) ;

    # Jar directories.
    local _jarDirectories =
        $(JAVA.JARDIRECTORIES:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))
        $(JAVA.JARDIRECTORIES:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;
    local linkLibs = $(JAVA.PREBUILTJARS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
    SEARCH on $(linkLibs) += $(_jarDirectories) ;

    # Manifest
    local manifest = $(ANDROID.MANIFEST:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;

    # Assets.
    local assets = $(ANDROID.ASSETS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;

    # Uncompressed Asset Extensions
    local uncompressedAssetExtensions = $(ANDROID.UNCOMPRESSED_ASSET_EXTENSIONS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;

    # Resources
    local resources = $(ANDROID.RESOURCES:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;

    # Build AndroidManifest-extras.xml
    local libAndroidManifests ;
    local sdkVersion = $(ANDROID.SDK_VERSION:Z=$(C.COMPILER_SUITE_SYMBOL)) ;
    local sdkMinimumVersion = $(ANDROID.SDK_MINIMUM_VERSION:Z=$(C.ACTIVE_TOOLCHAIN_TARGET):E=$(sdkVersion)) ;
    local versionName = $(ANDROID.VERSION_NAME:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
    local versionCode = $(ANDROID.VERSION_CODE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
    local contents = "<?xml version=\"1.0\" encoding=\"utf-8\"?>$(NEWLINE)" ;
    contents += "<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"$(NEWLINE)" ;
    contents += "    xmlns:tools=\"http://schemas.android.com/tools\"$(NEWLINE)" ;
    contents += "    android:versionCode=\"$(versionCode)\"$(NEWLINE)" ;
    #contents += "    android:versionName=\"$(versionName)\" tools:replace=\"versionCode,versionName\"$(NEWLINE)" ;
    contents += "    android:versionName=\"$(versionName)\"$(NEWLINE)" ;
    contents += "    tools:replace=\"versionCode,versionName\"$(NEWLINE)" ;
    #contents += "    tools:node=\"merge\"$(NEWLINE)" ;
    #contents += "    package=\"$(ANDROID.PACKAGE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))\">$(NEWLINE)" ;
    contents += ">$(NEWLINE)" ;
    contents += "    <uses-sdk android:minSdkVersion=\"$(sdkMinimumVersion)\" android:targetSdkVersion=\"$(sdkVersion)\" />$(NEWLINE)" ;
    contents += "</manifest>$(NEWLINE)" ;
    local extrasAndroidManifest = @(AndroidManifest-extras.xml:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
    MakeLocate $(extrasAndroidManifest) : $(LOCATE_TARGET) ;
    CONTENTS on $(extrasAndroidManifest) = $(contents) ;
    UseCommandLine $(extrasAndroidManifest) : $(contents) ;
    WriteFile $(extrasAndroidManifest) ;
    libAndroidManifests += $(extrasAndroidManifest) ;

    # Get list of resource/asset directories from libraries we have built.
    local _needJarResourceDirs = $(resources) ;
    local classesJars ;
    if $(needJars) {
        local _needJar ;

        #local _needJarPackages ;
        #for _needJar in $(needJars:GB) {
            #_needJarPackages += $(ANDROID.PACKAGE:Z=$(_needJar:G=$(C.ACTIVE_TOOLCHAIN_GRIST))) ;
        #}
        #local _colon = \: ;
        #_needJarPackages = $(_needJarPackages:J=$(_colon)) ;
        #EXTRA_PACKAGES on $(_apk) = --extra-packages $(_needJarPackages) ;

        for _needJar in $(needJars:GB) {
            _needJarResourceDirs += $(ANDROID.RESOURCES:Z=$(_needJar:G=$(C.ACTIVE_TOOLCHAIN_GRIST))) ;
        }
        for _needJar in $(needJars:GB) {
            local binPath = $(JAVA.LIBPATH:Z=$(_needJar:G=$(C.ACTIVE_TOOLCHAIN_GRIST)))/bin ;
            if [ Glob $(binPath:T) : classes.jar ] {
                local classes.jar = @(classes.jar:G=$(_needJar:G=)) ;
                SEARCH on $(classes.jar) = $(binPath) ;
                classesJars += $(classes.jar) ;
            }

            local libPath = $(JAVA.LIBPATH:Z=$(_needJar:G=$(C.ACTIVE_TOOLCHAIN_GRIST))) ;
            if [ Glob $(libPath) : AndroidManifest.xml ] {
                local AndroidManifest.xml = @(AndroidManifest.xml:G=$(_needJar:G=)) ;
                SEARCH on $(AndroidManifest.xml) = $(libPath) ;
                libAndroidManifests += $(AndroidManifest.xml) ;
            }
        }
    }

    local aar ;
    for aar in $(JAVA.UNPACKEDAARS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) {
        local prebuiltAar = $(JAVA.PREBUILTAAR:Z=$(aar)) ;
        local aarPath = $(LOCATE:Z=$(aar)) ;
        local resPath = $(aarPath)/res ;
        resPath = [ Glob $(resPath:TP) : $(resPath:BS)/ ] ;
        if $(resPath) {
            _needJarResourceDirs += $(resPath) ;
        }

        if [ Glob $(aarPath) : classes.jar ] {
            local classes.jar = @(classes.jar:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)|aar|$(prebuiltAar:G=)) ;
            SEARCH on $(classes.jar) = $(aarPath) ;
            classesJars += $(classes.jar) ;
        }

        if [ Glob $(aarPath) : AndroidManifest.xml ] {
            local AndroidManifest.xml = @(AndroidManifest.xml:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)|aar|$(prebuiltAar:G=)) ;
            SEARCH on $(AndroidManifest.xml) = $(aarPath) ;
            libAndroidManifests += $(AndroidManifest.xml) ;
        }
    }

    if $(C.CONFIG) in debug {
        local AndroidManifest-debuggable.xml = @(AndroidManifest-debuggable.xml:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
        SEARCH on $(AndroidManifest-debuggable.xml) = $(JAM_MODULES_PATH)/c/toolchain/clang ;
        libAndroidManifests += $(AndroidManifest-debuggable.xml) ;
    }

    # Merge the final AndroidManifest.xml.
    local targetAndroidManifest = @(AndroidManifest.xml:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)|final) ;
    MakeLocate $(targetAndroidManifest) : $(LOCATE_TARGET)/_temp_ ;
    UseCommandLine $(targetAndroidManifest) : $(libAndroidManifests) ;
    Depends $(targetAndroidManifest) : $(manifest) $(libAndroidManifests) ;
    if $(libAndroidManifests) {
        android._ManifestMerger $(targetAndroidManifest) : $(manifest) $(libAndroidManifests) : $(C.COMPILER_SUITE_SYMBOL) ;
    } else {
        CopyFile $(C.ACTIVE_TOOLCHAIN_TARGET) : $(targetAndroidManifest) : $(manifest) ;
    }

    # Determine all of the built .jar files.
    local builtJars ;
    local _jar ;
    for _jar in $(needJars) {
        if $(BUILT:Z=$(_jar)) {
            builtJars += $(_jar) ;
        }
    }

    # Build DEX file from all JARs (prebuilt and ones we have built).
    local _dex = [ C.GristFiles $(TARGET) : classes.dex ] ;
    MakeLocate $(_dex) : $(LOCATE_TARGET) ;

    # Target dependent on DEX file.
    Depends $(TARGET) : $(_dex) ;

    # DEX file dependent on all JAR files.
    Depends $(_dex) : $(builtJars) $(linkLibs) $(_applicationJar) $(classesJars) ;

    # Action to bundle DEX file.
    android._DXBundle $(_dex) : $(builtJars) $(linkLibs) $(_applicationJar) $(classesJars) : $(C.COMPILER_SUITE_SYMBOL) ;

    # Build APK file from the DEX, manifest and resources.
    local _apk = [ C.GristFiles $(TARGET) : $(TARGET).unsigned.apk ] ;
    MakeLocate $(_apk) : $(LOCATE_TARGET) ;

    MANIFEST on $(_apk) = $(targetAndroidManifest) ;
    INPUT_DIRECTORY on $(_apk) = $(LOCATE_TARGET) ;

    # Store the resources directory onto the target so it can be accessed by the action.
    local _dashS = "-S " ;
    RESOURCES on $(_apk) = $(_dashS)$(_needJarResourceDirs:TC/) ;
    local _dashA = "-A " ;
    ASSETS on $(_apk) = $(_dashA)$(assets:TC/) ;
    local _dash0 = "-0 " ;
    UNCOMPRESSED_ASSET_EXTENSIONS on $(_apk) = $(_dash0)$(uncompressedAssetExtensions) ;

    # Glob in the assets directory for dependencies.
    local assetFiles ;
    if $(assets) {
        assetFiles = [ ListSort [ android._GlobRecursive $(assets:T) : *.* ] : 0 ] ;
        Depends $(_apk) : $(assetFiles) ;
    }

    # Native lib.
    local nativeLibs =
        $(ANDROID.NATIVELIBS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))
        $(ANDROID.NATIVELIBS:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

    local toolchain ;
    for toolchain in $(TOOLCHAINS) {
        local linkTargets = [ C.GetLinkTargets $(nativeLibs) : $(toolchain) ] ;

        local linkTarget ;
        for linkTarget in $(linkTargets) {
            if $(linkTarget:S) != .so {
                continue ;
            }

            # Get final filenames.
            local _strippedSo = $(linkTarget) ;
            #on $(nativeLibs) _strippedSo = $(STRIPPED_SO) ;

            # Copy stripped so into output directory.
            local _outputSo = $(_strippedSo:G=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
            local _binding = $(_strippedSo:TBS) ;
            switch $(C.ARCHITECTURE:Z=$(linkTarget)) {
                case arm :
                    _outputSo = $(_outputSo)|arm ;
                    BINDING on $(_outputSo) = $(_binding) ;
                    MakeLocate $(_outputSo) : $(LOCATE_TARGET)/lib/armeabi ;
                case armv7-a :
                    _outputSo = $(_outputSo)|armv7-a ;
                    BINDING on $(_outputSo) = $(_binding) ;
                    MakeLocate $(_outputSo) : $(LOCATE_TARGET)/lib/armeabi-v7a ;
                case arm64 :
                    _outputSo = $(_outputSo)|arm64-v8a ;
                    BINDING on $(_outputSo) = $(_binding) ;
                    MakeLocate $(_outputSo) : $(LOCATE_TARGET)/lib/arm64-v8a ;
                case x86 :
                    _outputSo = $(_outputSo)|x86 ;
                    BINDING on $(_outputSo) = $(_binding) ;
                    MakeLocate $(_outputSo) : $(LOCATE_TARGET)/lib/x86 ;
            }

            # Output file depends on input stripped SO file.
            Depends $(_outputSo) : $(_strippedSo) ;

            CopyFile $(TARGET) : $(_outputSo) : $(_strippedSo) ;

            Depends $(_apk) : $(_outputSo) ;
        }
    }

    # Native prebuilt libraries.
    local nativePrebuiltLibs = $(ANDROID.NATIVEPREBUILTLIBS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;

    local nativePrebuiltLibraryDirectories =
        $(ANDROID.NATIVEPREBUILTLIBRARYDIRECTORIES:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))
        $(ANDROID.NATIVEPREBUILTLIBRARYDIRECTORIES:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

    for toolchain in $(TOOLCHAINS) {
        local nativePrebuiltLib ;
        for nativePrebuiltLib in $(nativePrebuiltLibs) {
            # Get final filenames.
            local nativeLibraryFullName = lib$(nativePrebuiltLib).so ;

            # Copy it into output directory.
            local target = $(nativeLibraryFullName:G=$(toolchain) ;
            local source = $(nativeLibraryFullName:G=$(toolchain)|source) ;
            Echo target - $(target) ;
            Echo source - $(source) ;
            Exit ;

            switch $(architecture) {
                case arm :
                    SEARCH on $(source) +=
                        $(nativePrebuiltLibraryDirectories)/armeabi
                        $(nativePrebuiltLibraryDirectories)/armeabi-v7a
                    ;
                    MakeLocate $(target) : $(LOCATE_TARGET)/lib/armeabi ;
                case armv7-a :
                    SEARCH on $(source) += $(nativePrebuiltLibraryDirectories)/armeabi-v7a ;
                    MakeLocate $(target) : $(LOCATE_TARGET)/lib/armeabi-v7a ;
                case arm64 :
                    SEARCH on $(source) += $(nativePrebuiltLibraryDirectories)/arm64-v8a ;
                    MakeLocate $(target) : $(LOCATE_TARGET)/lib/arm64-v8a ;
                case x86 :
                    SEARCH on $(source) += $(nativePrebuiltLibraryDirectories)/x86 ;
                    MakeLocate $(target) : $(LOCATE_TARGET)/lib/x86 ;
            }

            CopyFile $(_apk) : $(target) : $(source) ;
            Clean $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(target) ;
        }
    }

    # Dependencies.
    Depends $(_apk) : $(_dex) $(targetAndroidManifest) ;

    # If debug build, copy GDB.
    if $(CONFIG) = debug {
        local _sourceGdb ;
        local _dstGdb ;
        switch $(C.ARCHITECTURE) {
            case arm :
                _sourceGdb = gdbserver|arm ;
                BINDING on $(_sourceGdb) = gdbserver ;
                SEARCH on $(_sourceGdb) = $(NDKROOT)/prebuilt/android-arm/gdbserver ;

                _dstGdb = [ C.GristFiles $(TARGET) : gdbserver|arm ] ;
                BINDING on $(_dstGdb) = gdbserver ;
                MakeLocate $(_dstGdb) : $(LOCATE_TARGET)/lib/armeabi-v7a ;
            case armv7-a :
                _sourceGdb = gdbserver|arm ;
                BINDING on $(_sourceGdb) = gdbserver ;
                SEARCH on $(_sourceGdb) = $(NDKROOT)/prebuilt/android-arm/gdbserver ;

                _dstGdb = [ C.GristFiles $(TARGET) : gdbserver|arm ] ;
                BINDING on $(_dstGdb) = gdbserver ;
                MakeLocate $(_dstGdb) : $(LOCATE_TARGET)/lib/armeabi-v7a ;
            case arm64 :
                _sourceGdb = gdbserver|arm ;
                BINDING on $(_sourceGdb) = gdbserver ;
                SEARCH on $(_sourceGdb) = $(NDKROOT)/prebuilt/android-arm/gdbserver ;

                _dstGdb = [ C.GristFiles $(TARGET) : gdbserver|arm ] ;
                BINDING on $(_dstGdb) = gdbserver ;
                MakeLocate $(_dstGdb) : $(LOCATE_TARGET)/lib/arm64-v8a ;
            case x86 :
                _sourceGdb = gdbserver|x86 ;
                BINDING on $(_sourceGdb) = gdbserver ;
                SEARCH on $(_sourceGdb) = $(NDKROOT)/prebuilt/android-x86/gdbserver ;

                _dstGdb = [ C.GristFiles $(TARGET) : gdbserver|x86 ] ;
                BINDING on $(_dstGdb) = gdbserver ;
                MakeLocate $(_dstGdb) : $(LOCATE_TARGET)/lib/x86 ;
        }

        CopyFile $(_apk) : $(_dstGdb) : $(_sourceGdb) ;
        Clean $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(_dstGdb) ;
    }

    # Command line.
    UseCommandLine $(_apk) : $(C.android.IGNORE_ASSETS_LIST) $(uncompressedAssetExtensions) $(assetFiles) ;

    # Action.
    android._APKPackage $(_apk) : $(_dex) : $(C.COMPILER_SUITE_SYMBOL) ;

    # Signed APK.
    local _signedApk = [ C.GristFiles $(TARGET) : $(TARGET).unaligned.apk ] ;
    MakeLocate $(_signedApk) : $(LOCATE_TARGET) ;

    Depends $(_signedApk) : $(_apk) ;

    local _keyStorePath =
        $(ANDROID.KEYSTORE_PATH:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))
        $(ANDROID.KEYSTORE_PATH:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;
    local _keyStorePassword =
        $(ANDROID.KEYSTORE_PASSWORD:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))
        $(ANDROID.KEYSTORE_PASSWORD:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;
    local _keyStoreKeyAlias =
        $(ANDROID.KEYSTORE_KEY_ALIAS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))
        $(ANDROID.KEYSTORE_KEY_ALIAS:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;
    local _keyStoreKeyPassword =
        $(ANDROID.KEYSTORE_KEY_PASSWORD:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))
        $(ANDROID.KEYSTORE_KEY_PASSWORD:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

    if ! $(_keyStorePath) || ! $(_keyStorePassword) || ! $(_keyStoreKeyAlias) || ! $(_keyStoreKeyPassword) {
        Exit *** error \: Must call android.Sign and specify keystore path, keystore password, key alias, and key password ;
    }

    KEYSTORE_PATH on $(_signedApk) = $(_keyStorePath) ;
    KEYSTORE_PASSWORD on $(_signedApk) = $(_keyStorePassword) ;
    KEYSTORE_KEY_ALIAS on $(_signedApk) = $(_keyStoreKeyAlias) ;
    KEYSTORE_KEY_PASSWORD on $(_signedApk) = $(_keyStoreKeyPassword) ;

    Depends $(_signedApk) : $(_keystorePath) ;
    UseCommandLine $(_signedApk) : $(_keyStorePassword) $(_keyStoreKey) ;

    android._SignApk $(_signedApk) : $(_apk) : $(C.COMPILER_SUITE_SYMBOL) ;

    # Aligned.
    local _alignedApk = [ C.GristFiles $(TARGET) : $(TARGET).apk ] ;
    APK_TARGET on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(_alignedApk) ;

    local packageOutputPath = $(ANDROID.PACKAGE_OUTPUT_PATH:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
    MakeLocate $(_alignedApk) : $(packageOutputPath:E=$(LOCATE_TARGET)) ;

    Depends $(_alignedApk) : $(_signedApk) ;

    android._ZipAlign $(_alignedApk) : $(_signedApk) : $(C.COMPILER_SUITE_SYMBOL) ;

    # Make target depend on our aligned (signed) APK.
    Depends all : $(TARGET) : $(_alignedApk) ;

    # To help deploy the APK generate a little launcher batch.
#    local _deploy = [ C.GristFiles $(TARGET) : deploy.bat ] ;
#    MakeLocate $(_deploy) : $(LOCATE_TARGET) ;
#    local package = $(ANDROID.PACKAGE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
#    local adb = $(ANDROID.ADB:Z=$(C.COMPILER_SUITE_SYMBOL)) ;
#    local _deployContents = "pushd %~dp0 & $(adb:TC) uninstall $(package) & $(adb:TC) install $(_alignedApk:TC) & popd" ;
#    CONTENTS on $(_deploy) = $(_deployContents) ;
#    WriteFile $(_deploy) ;
#    UseCommandLine $(_deploy) : $(_deployContents) ;
#    Depends $(TARGET) : $(_deploy) ;

    # Set up an install target.
    Depends install:$(TARGET) : $(_alignedApk) ;
    Always install:$(TARGET) ;
    NotFile install:$(TARGET) ;
    android._Install install:$(TARGET) : $(_alignedApk) : $(C.COMPILER_SUITE_SYMBOL) ;

    # Set up an auto-install if requested.
    if install in $(OPTIONS) {
        Depends autoinstall:$(TARGET) : $(_alignedApk) ;
        NotFile autoinstall:$(TARGET) ;
        android._Install autoinstall:$(TARGET) : $(_alignedApk) : $(C.COMPILER_SUITE_SYMBOL) ;
        Depends $(TARGET) : autoinstall:$(TARGET) ;
    }

    # Set up an uninstall target.
    Always uninstall:$(TARGET) ;
    NotFile uninstall:$(TARGET) ;
    PACKAGE on uninstall:$(TARGET) = $(package) ;
    android._Uninstall uninstall:$(TARGET) : : $(C.COMPILER_SUITE_SYMBOL) ;

    # Depend on the link targets.
    Depends $(C.ACTIVE_TOOLCHAIN_TARGET) : $(linkTargets) ;

    # Hook up the project specific clean for this TARGET.
    Depends clean : clean:$(TARGET) : $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) ;
    NotFile clean:$(TARGET) $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) ;
    Always clean:$(TARGET) $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) ;
    Clean $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(_deploy) $(_alignedApk) $(_signedApk) $(_apk) $(_dex) $(_aidlCompiledFiles) ;
}


rule android.WebServer TARGET {
    if $(C.PLATFORM) in android {
        TARGET = [ ActiveTarget $(TARGET) ] ;

        local apkTarget = $(APK_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
        local packagePath = $(apkTarget:TD) ;
        local OUTPUT_PATH = $(LOCATE:Z=$(apkTarget)) ;

        local archiveTarget = archive:$(TARGET) ;
        OUTPUT_PATH on $(archiveTarget) = $(OUTPUT_PATH) ;

        local IP ;
        if ! $(URL) {
            IP = [ LuaString "
                local socket = require 'socket'.udp()
                socket:setpeername('10.10.10.10', '9999')
                return socket:getsockname()
                " ] ;
            IP = $(IP[1]) ;
            URL = http://$(IP):9999 ;
        }
        if $(URL) {
            # Stolen from BetaBuilder:

            local index.html = @(index.html:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST):archive) ;
            MakeLocate $(index.html) : $(OUTPUT_PATH) ;
            Depends $(archiveTarget) : $(index.html) ;
            Clean $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(index.html) ;
            local contents ;

            local APK_FILENAME = $(apkTarget:BS) ;

            on $(C.ACTIVE_TOOLCHAIN_TARGET) contents = "
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> <html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
<title>$(TARGET)</title>
<style type="text/css">
body {background:#fff;margin:0;padding:0;font-family:arial,helvetica,sans-serif;text-align:center;padding:10px;color:#333;font-size:16px;}
#container {width:300px;margin:0 auto;}
h1 {margin:0;padding:0;font-size:14px;}
p {font-size:13px;}
.link {background:#ecf5ff;border-top:1px solid #fff;border:1px solid #dfebf8;margin-top:.5em;padding:.3em;}
.link a {text-decoration:none;font-size:15px;display:block;color:#069;}

</style>
</head>
<body>

<div id="container">

<h1>Android Users:</h1>

<div class="link"><a href="$(URL)/$(APK_FILENAME)">Tap Here to Install<br />$(TARGET)<br />On Your Device</a></div>

<p><strong>Link didn't work?</strong><br />
Make sure you're visiting this page on your device, not your computer.</p>

</div>

</body>
</html>
" ;
            CONTENTS on $(index.html) = $(contents) ;
            Always $(index.html) ;
            WriteFile $(index.html) ;
            UseCommandLine $(index.html) : $(contents) ;

            android._WebServer $(archiveTarget) ;
        }
    }
}


actions screenoutput android._WebServer {
	$(JAM_EXECUTABLE_PATH:C) --webserver $(OUTPUT_PATH)
}

} # if ! $(TARGETINFO_LOCATE)


#######################################################################################
# These rules mainly store values per config/platform that can then be accessed later.
#######################################################################################

# Specify paths to search when locating prebuilt JARs.
rule android.JarDirectories TARGET : DIRECTORIES {
    C.ActiveTarget $(TARGET) ;
    JAVA.JARDIRECTORIES on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(DIRECTORIES:R=$(SUBDIR:E="")) ;
}


# Specify prebuilt JARs to build against.
rule android.PrebuiltJars TARGET : LIBRARIES {
    TARGET = [ C.ActiveTarget $(TARGET) ] ;
    local grist = $(TARGET):prebuiltlib ;
    local gristedLibraries = $(LIBRARIES:G=$(grist)) ;
    SEARCH on $(gristedLibraries) += $(SUBDIR) $(SUBDIR)/libs ;
    SEARCH_EXTENSIONS on $(gristedLibraries) = .jar ;
    JAVA.PREBUILTJARS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(gristedLibraries) ;
}


# Specify prebuilt AARs to build against.
rule android.PrebuiltAars TARGET : LIBRARIES {
    TARGET = [ C.ActiveTarget $(TARGET) ] ;
    local grist = $(TARGET):prebuiltaar ;
    local gristedLibraries = $(LIBRARIES:G=$(grist)) ;
    JAVA.PREBUILTAARS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(gristedLibraries).aar ;
}


# Specify relative source path for target (if inside the current directory there is a
# 'src' directory which has the com/module/submodule structure inside, then 'src' would
# be the source path.
rule android.SourcePaths TARGET : DIRECTORIES {
    C.ActiveTarget $(TARGET) ;
    JAVA.SOURCEPATHS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(DIRECTORIES:R=$(SUBDIR:E="")) ;
}


# Specify the package name for the target, e.g. com.module.submodule
#
# By default, this is read from the AndroidManifest.xml, so only call this if an
# override is needed.
rule android.PackageName TARGET : PACKAGE {
    C.ActiveTarget $(TARGET) ;
    ANDROID.PACKAGE on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(PACKAGE) ;
}


# Specify the manifest file for the target.
rule android.Manifest TARGET : MANIFEST {
    TARGET = [ C.ActiveTarget $(TARGET) ] ;
    ANDROID.MANIFEST on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(MANIFEST:R=$(SUBDIR:E="")) ;
}


# Specify the resource directory for the target.
rule android.Resources TARGET : DIRECTORIES {
    C.ActiveTarget $(TARGET) ;
    ANDROID.RESOURCES on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(DIRECTORIES:R=$(SUBDIR:E="")) ;
}


# Specify the asset directories for the target.
rule android.Assets TARGET : DIRECTORY {
    C.ActiveTarget $(TARGET) ;
    ANDROID.ASSETS on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(DIRECTORY[1]:R=$(SUBDIR:E="")) ;
}


# Specify extensions to leave uncompressed when building the .apk.
rule android.UncompressedAssetExtensions TARGET : UNCOMPRESSED_ASSET_EXTENSIONS {
    C.ActiveTarget $(TARGET) ;
    ANDROID.UNCOMPRESSED_ASSET_EXTENSIONS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(UNCOMPRESSED_ASSET_EXTENSIONS) ;
}


#
rule android.AssetPack TARGET : PACK_NAME : TYPE : WILDCARDS : TARGETS_TO_COPY : DESTINATION_RELATIVE_PATH {
    C.ActiveTarget $(TARGET) ;
    ANDROID.ASSET_PACK.$(PACK_NAME).TYPE on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(TYPE) ;
    ANDROID.ASSET_PACK.$(PACK_NAME).WILDCARDS on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(WILDCARDS) ;
    ANDROID.ASSET_PACK.$(PACK_NAME).TARGETS_TO_COPY on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(TARGETS_TO_COPY) ;
    ANDROID.ASSET_PACK.$(PACK_NAME).DESTINATION_RELATIVE_PATH on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(DESTINATION_RELATIVE_PATH) ;
    ANDROID.ASSET_PACKS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(PACK_NAME) ;
}


# Specify the native libraries used by this target. The native library targets should be
# a target being built by the native part of the Android NDK Jam integration.
rule android.NativeLibraries TARGET : NATIVE_LIBRARIES {
    C.ActiveTarget $(TARGET) ;
    ANDROID.NATIVELIBS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(NATIVE_LIBRARIES) ;
}


# Specify the prebuilt native shared libraries used by this target.
rule android.NativePrebuiltLibraries TARGET : NATIVE_PREBUILT_LIBRARIES {
    C.ActiveTarget $(TARGET) ;
    ANDROID.NATIVEPREBUILTLIBS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(NATIVE_PREBUILT_LIBRARIES) ;
}


# Specify paths to search when locating prebuilt native libraries.
rule android.NativePrebuiltLibraryDirectories TARGET : DIRECTORIES {
    C.ActiveTarget $(TARGET) ;
    ANDROID.NATIVEPREBUILTLIBRARYDIRECTORIES on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(DIRECTORIES:R=$(SUBDIR:E="")) ;
}


# Specify code signing details (key store path, password and key).
rule android.Sign TARGET : KEYSTORE_PATH_PASSWORD_KEY {
    C.ActiveTarget $(TARGET) ;
    ANDROID.KEYSTORE_PATH on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(KEYSTORE_PATH_PASSWORD_KEY[1]) ;
    SEARCH on $(KEYSTORE_PATH_PASSWORD_KEY[1]) = $(SUBDIR) ;

    ANDROID.KEYSTORE_PASSWORD on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(KEYSTORE_PATH_PASSWORD_KEY[2]) ;
    ANDROID.KEYSTORE_KEY_ALIAS on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(KEYSTORE_PATH_PASSWORD_KEY[3]) ;
    ANDROID.KEYSTORE_KEY_PASSWORD on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(KEYSTORE_PATH_PASSWORD_KEY[4]) ;
}


# Specify JARs used by this module (not prebuilt ones though).
rule android.LinkJars TARGET : LIBRARIES {
    C.ActiveTarget $(TARGET) ;

    local suflib = .jar ;
    local gristLibraries ;
    local lib ;
    for lib in $(LIBRARIES) {
        local grist = $(C.ACTIVE_TOOLCHAIN_GRIST):$(lib) ;
        lib = $(lib:G=$(grist))$(suflib) ;
        gristLibraries += $(lib) ;
    }
    JAVA.NEEDJARS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(gristLibraries) ;
}


# Assign an output path for the .apk.
rule android.PackageOutputPath TARGET : OUTPUT_PATH {
    C.ActiveTarget $(TARGET) ;
    ANDROID.PACKAGE_OUTPUT_PATH on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(OUTPUT_PATH[1]:R=$(SUBDIR:E="")) ;
}


#
rule android.GradleDependencies TARGET : PACKAGES {
    C.ActiveTarget $(TARGET) ;
    ANDROID.GRADLE_DEPENDENCIES on $(C.ACTIVE_TOOLCHAIN_TARGET) += "    implementation '$(PACKAGES)'" ;
}


#
rule android.GradleDependenciesLines TARGET : LINES {
    C.ActiveTarget $(TARGET) ;
    ANDROID.GRADLE_DEPENDENCIES on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(LINES) ;
}


#
rule android.GradleProperties TARGET : PROPERTIES {
    C.ActiveTarget $(TARGET) ;
    ANDROID.GRADLE_PROPERTIES on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(PROPERTIES)$(NEWLINE) ;
}


#
rule android.GradleBuildFeaturesLines TARGET : LINES {
    C.ActiveTarget $(TARGET) ;
    ANDROID.GRADLE_BUILD_FEATURES_LINES on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(LINES) ;
}


#
#
#
rule android.GradleAllProjectsRepositories TARGET : REPOSITORIES {
    C.ActiveTarget $(TARGET) ;
    ANDROID.GRADLE_ALLPROJECTS_REPOSITORIES on $(C.COMPILER_SUITE_SYMBOL) += "    $(REPOSITORIES)$(NEWLINE)" ;
}


rule android.GradleRepositories TARGET : REPOSITORIES {
    C.ActiveTarget $(TARGET) ;
    ANDROID.GRADLE_REPOSITORIES on $(C.COMPILER_SUITE_SYMBOL) += "    $(REPOSITORIES)$(NEWLINE)" ;
}


#
rule android.ProGuardLines TARGET : LINES {
    C.ActiveTarget $(TARGET) ;
    ANDROID.PROGUARD_LINES on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(LINES) ;
}


rule android.Minify TARGET : MINIFY {
    C.ActiveTarget $(TARGET) ;
    if $(MINIFY) in 1 true {
        ANDROID.MINIFY on $(C.ACTIVE_TOOLCHAIN_TARGET) = true ;
    } else {
        ANDROID.MINIFY on $(C.ACTIVE_TOOLCHAIN_TARGET) = true ;
    }
}


rule android.ExcludeFromBuild TARGET : SOURCES {
    C.ActiveTarget $(TARGET) ;
    ANDROID.EXCLUDED_FROM_BUILD on $(SOURCES:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) = true ;
}


#
rule android.GradleVersionCatalogFile TARGET : VERSION_CATALOG_FILE {
    C.ActiveTarget $(TARGET) ;
    local target = $(VERSION_CATALOG_FILE:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
    SEARCH on $(target) = $(SUBDIR) ;
    ANDROID.GRADLE_VERSION_CATALOG_FILE on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(target) ;
}


###############################################################################
###############################################################################
###############################################################################
###############################################################################

if $(TARGETINFO_LOCATE) {

rule android.Application TARGET : SOURCES : OPTIONS {
    TARGET = [ C.ActiveTarget $(TARGET) ] ;

    # Build library out of the sources.
    android.Library $(TARGET) : $(SOURCES) : $(OPTIONS) application ;
}


# Create the APK for an Android application.
rule android.Package TARGET : TOOLCHAINS : OPTIONS {
    # Activate the requested target.
    TARGET = [ C.ActiveTarget $(TARGET) ] ;

    C.ActiveTarget $(TARGET) ;

    TOOLCHAINS ?= $(C.ACTIVE_TOOLCHAIN) ;

    # Native lib.
    local nativeLibs =
        $(ANDROID.NATIVELIBS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))
        $(ANDROID.NATIVELIBS:Z=$(C.ACTIVE_TOOLCHAIN_*))
    ;

    local toolchain ;
    for toolchain in $(TOOLCHAINS) {
        local linkTargets = [ C.GetLinkTargets $(nativeLibs) : $(toolchain) ] ;

        local linkTarget ;
        for linkTarget in $(linkTargets) {
            if $(linkTarget:S) != .so {
                continue ;
            }

            # Copy stripped so into output directory.
            switch $(C.ARCHITECTURE:Z=$(linkTarget)) {
                case arm :
                    Contents += "Projects[ [[$(TARGET)]] ].AdditionalSymbolSearchPaths[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(LOCATE_TARGET)/lib/armeabi]]$(NEWLINE)" ;
                case armv7-a :
                    Contents += "Projects[ [[$(TARGET)]] ].AdditionalSymbolSearchPaths[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(LOCATE_TARGET)/lib/armeabi-v7a]]$(NEWLINE)" ;
                case arm64 :
                    Contents += "Projects[ [[$(TARGET)]] ].AdditionalSymbolSearchPaths[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(LOCATE_TARGET)/lib/arm64-v8a]]$(NEWLINE)" ;
                case x86 :
                    Contents += "Projects[ [[$(TARGET)]] ].AdditionalSymbolSearchPaths[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(LOCATE_TARGET)/lib/x86]]$(NEWLINE)" ;
            }
        }
    }

    # Aligned.
    local _alignedApk = [ C.GristFiles $(TARGET) : $(TARGET).apk ] ;
    MakeLocate $(_alignedApk) : $(LOCATE_TARGET) ;

    Contents += "Projects[ [[$(TARGET)]] ].PackagePath[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(_alignedApk:T)]]$(NEWLINE)" ;
}



rule android.Library TARGET : SOURCES : OPTIONS {
    TARGET = [ C.ActiveTarget $(TARGET) ] ;

    Workspace $(TARGET) : $(TARGET) : all ;

    local sufexe = $(SUFEXE:Z=$(C.COMPILER_SUITE_SYMBOL)) ;
    local _t = [ C._retrieveOutputName : $(sufexe) ] ;
    _t = $(_t:G=$(C.ACTIVE_TARGET)) ;

    local outputPath = [ C._retrieveOutputPath ] ;

    C._ApplicationTargetInfo ;

    # Source path
    local sourcePaths = $(JAVA.SOURCEPATHS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
    sourcePaths ?= $(SUBDIR) ;

    # Set search path to all source paths available to this module.
    SOURCES = [ C.GristFiles : $(SOURCES) ] ;
    SEARCH on $(SOURCES) += $(sourcePaths) ;

    DumpProjectInfo $(TARGET) : $(SOURCES) : app $(OPTIONS) ;
    Depends all : $(TARGET) ;
}


rule android.ExcludeFromBuild TARGET : SOURCES {
}


} # if ! $(TARGETINFO_LOCATE)

VSPLATFORMMAP.android = ARM ;
VSNATIVEPLATFORM.android = true ;


IOS_DEFAULT_MINIMUM_SDK_VERSION = 11.0 ;

rule C.Toolchain.clang.ios-shared {
}


rule C.ios.FrameworkDirectories TARGET : FRAMEWORKDIRS {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	FRAMEWORKDIRS = $(FRAMEWORKDIRS:R=$(SUBDIR:E="")) ;
	FRAMEWORK_DIRECTORIES on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(FRAMEWORKDIRS) ;
	C.Flags $(TARGET) : CC C++ M MM : -F$(FRAMEWORKDIRS) ;
	C._LinkFlagsHelper $(TARGET) : -F$(FRAMEWORKDIRS) ;

	if $(TARGETINFO_LOCATE) {
		local prefix = "Projects[ [[$(C.ACTIVE_TARGET)]] ].FrameworkDirectories[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ]" ;
		Contents += "$(prefix) = concat($(prefix), {$(NEWLINE)" ;
			Contents += "$(TAB)[[$(FRAMEWORKDIRS:T)]],$(NEWLINE)" ;
		Contents += "})$(NEWLINE)" ;
	}
}


rule C.ios.LinkFrameworks TARGET : FRAMEWORKS : OPTIONS {
	C.ActiveTarget $(TARGET) ;
	FRAMEWORKS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(FRAMEWORKS) ;
	if public in $(OPTIONS) {
		__PUBLIC on $(C.ACTIVE_TOOLCHAIN_TARGET) = true ;
		PUBLIC_FRAMEWORKS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(FRAMEWORKS) ;
	}

	if $(TARGETINFO_LOCATE) {
		local prefix = "Projects[ [[$(C.ACTIVE_TARGET)]] ]" ;
		Contents += "$(prefix).Sources = concat($(prefix).Sources, {$(NEWLINE)" ;
			Contents += "$(TAB)[[$(FRAMEWORKS:T:S=.framework)]],$(NEWLINE)" ;
		Contents += "})$(NEWLINE)" ;
	}
}


rule C.ios.WeakLinkFrameworks TARGET : FRAMEWORKS {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	WEAK_FRAMEWORKS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(FRAMEWORKS) ;
	if public in $(OPTIONS) {
		__PUBLIC on $(C.ACTIVE_TOOLCHAIN_TARGET) = true ;
		PUBLIC_WEAK_FRAMEWORKS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(FRAMEWORKS) ;
	}
}


rule C.ios.EmbedFrameworks TARGET : FRAMEWORKS : OPTIONS {
	C.ActiveTarget $(TARGET) ;
	FRAMEWORKS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(FRAMEWORKS) ;
	EMBED_FRAMEWORKS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(FRAMEWORKS) ;
	if public in $(OPTIONS) {
		__PUBLIC on $(C.ACTIVE_TOOLCHAIN_TARGET) = true ;
		PUBLIC_FRAMEWORKS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(FRAMEWORKS) ;
		PUBLIC_EMBED_FRAMEWORKS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(FRAMEWORKS) ;
	}

	if $(TARGETINFO_LOCATE) {
		local frameworks ;

		#if embed in $(OPTIONS)
		{
			local frameworkDirectories = $(FRAMEWORK_DIRECTORIES:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
			local source ;
			for source in $(FRAMEWORKS) {
				source = $(source:S=.framework) ;
				local foundFramework = [ Glob $(frameworkDirectories) : $(source)/ ] ;
				frameworks += $(foundFramework[1]:P) ;
			}
		}

		local prefix = "Projects[ [[$(C.ACTIVE_TARGET)]] ]" ;
		Contents += "$(prefix).Sources = concat($(prefix).Sources, {$(NEWLINE)" ;
			Contents += "$(TAB)[[$(frameworks)]],$(NEWLINE)" ;
		Contents += "})$(NEWLINE)" ;

		local source ;
		for source in $(frameworks) {
			local fullprefix = "$(prefix).SourcesInfo[ [[$(source)]] ]" ;
			Contents += "$(fullprefix).buildFrameworks=true$(NEWLINE)" ;
			Contents += "$(fullprefix).embedFramework=true$(NEWLINE)" ;
		}

		local prefix = "Projects[ [[$(C.ACTIVE_TARGET)]] ].EmbedFrameworks[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ]" ;
		Contents += "$(prefix) = concat($(prefix), {$(NEWLINE)" ;
			Contents += "$(TAB)[[$(frameworks)]],$(NEWLINE)" ;
		Contents += "})$(NEWLINE)" ;
	}
}


rule C.ios.RPaths TARGET : RPATHS {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	C._LinkFlagsHelper $(TARGET) : "-rpath $(RPATHS)" ;

	if $(TARGETINFO_LOCATE) {
		local prefix = "Projects[ [[$(C.ACTIVE_TARGET)]] ].RPaths[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ]" ;
		Contents += "$(prefix) = concat($(prefix), {$(NEWLINE)" ;
			Contents += "$(TAB)[[$(RPATHS)]],$(NEWLINE)" ;
		Contents += "})$(NEWLINE)" ;
	}
}


actions C.ios.clang.Archive {
	$(C.AR:C) -static $(LIBFLAGS) -o $(<:C) -filelist ^^^($(>:J=$(NEWLINE))$(NEWLINE))
}


if ! $(NT) {

actions C.ios.clang.Link {
	$(C.LINK:C) $(LINKFLAGS) -o $(<[1]:C) -filelist ^^^($(>:J=$(NEWLINE))) -filelist ^^^($(NEEDLIBS:TCJ=$(NEWLINE))) $(LINKLIBS:TC)
}

rule ios.SDK SDK_VERSION {
	local SDK_PLATFORM ;
	SDK_PLATFORM ?= $(C.PLATFORM) ;

	local COMPILER_BIN_PATH = $(COMPILER_BIN_PATH:Z=$(C.COMPILER_SUITE_SYMBOL)) ;
	local developerRoot ;
	local isysroot ;
	local flags ;
	local sdkroot ;
	local architecture ;
	local minimumVersion ;

	switch $(SDK_PLATFORM) {
		case ios :
			if ! $(developerRoot) {
				developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
				local buffer = [ Shell "plutil -convert xml1 -o - $(developerRoot)/Platforms/iPhoneOS.platform/Version.plist" ] ;
				LuaString "
					if not plist then
						plist = require 'plist'
					end
					local ospath = require 'ospath'
					local versionPlist = plist.readbuffer(jam_getvar('buffer')[1])
					jam_setvar('SDK_VERSION', versionPlist['CFBundleVersion'])
				" ;
				isysroot = $(developerRoot)/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS$(SDK_VERSION).sdk ;
				sdkroot = iphoneos ;
				architecture = arm64 ;
				minimumVersion = 8.0 ;
			}

			flags += -fvisibility=hidden ;

		case iossimulator :
			if ! $(developerRoot) {
				developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
				isysroot = $(developerRoot)/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk ;
				sdkroot = iphoneos ;
				minimumVersion = 8.0 ;
				local buffer = [ Shell "plutil -convert xml1 -o - $(developerRoot)/Platforms/iPhoneSimulator.platform/Info.plist" ] ;
				LuaString "
					if not plist then
						plist = require 'plist'
					end
					local ospath = require 'ospath'
					local versionPlist = plist.readbuffer(jam_getvar('buffer')[1])
					jam_setvar('SDK_VERSION', versionPlist['CFBundleVersion'])
				" ;
			}

			architecture = i386 ;
	}

#	C.AR on $(C.COMPILER_SUITE_SYMBOL) = $(COMPILER_BIN_PATH)/$(C.AR:BSZ=$(C.COMPILER_SUITE_SYMBOL)) ;
#	C.CC on $(C.COMPILER_SUITE_SYMBOL) = $(COMPILER_BIN_PATH)/$(C.CC:BSZ=$(C.COMPILER_SUITE_SYMBOL)) ;
#	C.C++ on $(C.COMPILER_SUITE_SYMBOL) = $(COMPILER_BIN_PATH)/$(C.C++:BSZ=$(C.COMPILER_SUITE_SYMBOL)) ;
#	C.LINK on $(C.COMPILER_SUITE_SYMBOL) = $(COMPILER_BIN_PATH)/$(C.LINK:BSZ=$(C.COMPILER_SUITE_SYMBOL)) ;
#	C.RANLIB on $(C.COMPILER_SUITE_SYMBOL) = ;

	C.ARCHITECTURE on $(C.ACTIVE_TOOLCHAIN_*) = $(C.ARCHITECTURE:E=$(architecture)) ;
	ISYSROOT on $(C.ACTIVE_TOOLCHAIN_*) = $(isysroot) ;
	IPHONEOS_SDK_VERSION on $(C.ACTIVE_TOOLCHAIN_*) = $(SDK_VERSION) ;
	IOS_SDK_VERSION_MIN on $(C.ACTIVE_TOOLCHAIN_*) = $(minimumVersion:E=$(SDK_VERSION)) ;
	XCODE_SDKROOT on $(C.ACTIVE_TOOLCHAIN_*) = $(sdkroot) ;

	if $(TARGETINFO_LOCATE) {
		Contents += "Projects[ [[C.*]] ].XCODE_SDKROOT[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(sdkroot)]]
--Projects[ [[C.*]] ].XCODE_ARCHITECTURE[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = { [[$(architecture)]] }

" ;
	}
}

} else {

actions C.ios.clang.Link {
	$(C.LINK:C) -optlist ^^^($(LINKFLAGS:J=$(NEWLINE))) -o $(<[1]:C) -filelist ^^^($(>:\\J=$(NEWLINE))$(NEWLINE)$(NEEDLIBS:\\TCJ=$(NEWLINE):E=)$(NEWLINE)$(LINKLIBS:\\TCJ=$(NEWLINE):E=))
}

rule ios.SDK SDK_VERSION {
	local SDK_PLATFORM ;
	SDK_PLATFORM ?= $(C.PLATFORM) ;

	local COMPILER_BIN_PATH = $(COMPILER_BIN_PATH:Z=$(C.COMPILER_SUITE_SYMBOL)) ;
	local sysroot = $(IOSBUILDENV_PATH)/SDK ;
	SDK_VERSION ?= $(IOS_DEFAULT_MINIMUM_SDK_VERSION) ;

	C.AR on $(C.COMPILER_SUITE_SYMBOL) = $(COMPILER_BIN_PATH)/$(C.AR:BSZ=$(C.COMPILER_SUITE_SYMBOL)) ;
	C.CC on $(C.COMPILER_SUITE_SYMBOL) = $(COMPILER_BIN_PATH)/$(C.CC:BSZ=$(C.COMPILER_SUITE_SYMBOL)) ;
	C.C++ on $(C.COMPILER_SUITE_SYMBOL) = $(COMPILER_BIN_PATH)/$(C.C++:BSZ=$(C.COMPILER_SUITE_SYMBOL)) ;
	C.LINK on $(C.COMPILER_SUITE_SYMBOL) = $(COMPILER_BIN_PATH)/$(C.LINK:BSZ=$(C.COMPILER_SUITE_SYMBOL)) ;
	C.RANLIB on $(C.COMPILER_SUITE_SYMBOL) = ;

	C.ARCHITECTURE on $(C.ACTIVE_TOOLCHAIN_*) = $(C.ARCHITECTURE:E=arm64) ;
	ISYSROOT on $(C.ACTIVE_TOOLCHAIN_*) = $(sysroot) ;
	IPHONEOS_SDK_VERSION on $(C.ACTIVE_TOOLCHAIN_*) = $(SDK_VERSION) ;
	IOS_SDK_VERSION_MIN on $(C.ACTIVE_TOOLCHAIN_*) = $(IOS_DEFAULT_MINIMUM_SDK_VERSION) ;
}

} # if ! $(NT)


rule ios.MinimumOSVersion TARGET : SDK_VERSION_MIN {
	TARGET = [ ActiveTarget $(TARGET) ] ;

	local SDK_PLATFORM ;
	SDK_PLATFORM ?= $(C.PLATFORM) ;

	if $(IOSBUILDENV_PATH) {
		SDK_VERSION_MIN ?= $(IOS_DEFAULT_MINIMUM_SDK_VERSION) ;
	}

	IOS_SDK_VERSION_MIN on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(SDK_VERSION_MIN) ;

	if $(TARGETINFO_LOCATE) {
		if $(SDK_PLATFORM) in ios iossimulator {
			Contents += "Projects[ [[C.*]] ].IOS_SDK_VERSION_MIN[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(SDK_VERSION_MIN)]]

" ;
		} else if $(SDK_PLATFORM) in macosx32 macosx64 {
			Contents += "Projects[ [[C.*]] ].OSX_SDK_VERSION_MIN[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(SDK_VERSION_MIN)]]

" ;
		}
	}
}

LuaString "
function GetInfoPlistCurrentLevelNoCreate()
	if not plist then
		plist = require 'plist'
	end
	local plistName = jam_getvar('C.ACTIVE_TOOLCHAIN_TARGET_GRIST')[1] .. ':Info.plist'
	return _G[plistName]
end


function GetInfoPlistCurrentLevel()
	if not plist then
		plist = require 'plist'
	end
	local plistName = jam_getvar('C.ACTIVE_TOOLCHAIN_TARGET_GRIST')[1] .. ':Info.plist'
	if not _G[plistName] then
		_G[plistName] = plist.newdict()
	end
	return _G[plistName]
end


function PushInfoPlistLevel(key, value)
	local currentLevel = GetInfoPlistCurrentLevel()
	local newLevel = value
	rawset(newLevel, '__previous', currentLevel)
	local plistName = jam_getvar('C.ACTIVE_TOOLCHAIN_TARGET_GRIST')[1] .. ':Info.plist'
	_G[plistName] = newLevel
	return newLevel
end


function PopInfoPlistLevel()
	local currentLevel = GetInfoPlistCurrentLevel()
	local previousLevel = rawget(currentLevel, '__previous')
	if previousLevel then
		rawset(currentLevel, '__previous', nil)
		local plistName = jam_getvar('C.ACTIVE_TOOLCHAIN_TARGET_GRIST')[1] .. ':Info.plist'
		_G[plistName] = previousLevel
		return previousLevel
	end
	return currentLevel
end
" ;


rule ios.BundleInfoBoolean TARGET : KEY : VALUE : NO_OVERRIDE {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	LuaString "GetInfoPlistCurrentLevel()[jam_getvar('KEY')[1]] = jam_getvar('VALUE')[1] == 'true'" ;
	LuaString "
		local key = jam_getvar('KEY')[1]
		local pl = GetInfoPlistCurrentLevel()
		if not jam_getvar('NO_OVERRIDE')[1] or not pl[key] then
			pl[key] = jam_getvar('VALUE')[1] == 'true'
		end
		" ;
}


rule ios.BundleInfoInteger TARGET : KEY : VALUE : NO_OVERRIDE {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	LuaString "
		local key = jam_getvar('KEY')[1]
		local pl = GetInfoPlistCurrentLevel()
		if not jam_getvar('NO_OVERRIDE')[1] or not pl[key] then
			pl[key] = tonumber(jam_getvar('VALUE')[1])
		end
		" ;
}


rule ios.BundleInfoString TARGET : KEY : VALUE : NO_OVERRIDE {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	LuaString "
		local key = jam_getvar('KEY')[1]
		local pl = GetInfoPlistCurrentLevel()
		if not jam_getvar('NO_OVERRIDE')[1] or not pl[key] then
			pl[key] = jam_getvar('VALUE')[1]
		end
		" ;
}


rule ios.BundleInfoDictBegin TARGET : KEY {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	LuaString "
		local currentLevel = GetInfoPlistCurrentLevel()
		local newLevel = plist.newdict()
		currentLevel[jam_getvar('KEY')[1]] = newLevel
		rawset(newLevel, '__previous', currentLevel)
		local plistName = jam_getvar('C.ACTIVE_TOOLCHAIN_TARGET_GRIST')[1] .. ':Info.plist'
		_G[plistName] = newLevel
" ;
}


rule ios.BundleInfoDictEnd TARGET {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	LuaString "PopInfoPlistLevel()" ;
}


rule ios.BundleInfoArrayBegin TARGET : KEY {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	LuaString "
		local currentLevel = GetInfoPlistCurrentLevel()
		local newLevel = plist.newarray()
		currentLevel[jam_getvar('KEY')[1]] = newLevel
		rawset(newLevel, '__previous', currentLevel)
		local plistName = jam_getvar('C.ACTIVE_TOOLCHAIN_TARGET_GRIST')[1] .. ':Info.plist'
		_G[plistName] = newLevel
" ;
}


rule ios.BundleInfoArrayEnd TARGET {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	LuaString "PopInfoPlistLevel()" ;
}


rule ios.BundleInfoArrayDictBegin TARGET {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	LuaString "
		local currentLevel = GetInfoPlistCurrentLevel()
		local newLevel = plist.newdict()
		currentLevel[#currentLevel + 1] = newLevel
		rawset(newLevel, '__previous', currentLevel)
		local plistName = jam_getvar('C.ACTIVE_TOOLCHAIN_TARGET_GRIST')[1] .. ':Info.plist'
		_G[plistName] = newLevel
" ;
}


rule ios.BundleInfoArrayDictEnd TARGET {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	LuaString "PopInfoPlistLevel()" ;
}


rule ios.BundleInfoArrayBoolean TARGET : KEY : VALUE : NO_OVERRIDE {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	if $(VALUE) {
		LuaString "
			local key = jam_getvar('KEY')[1]
			local pl = GetInfoPlistCurrentLevel()
			if not jam_getvar('NO_OVERRIDE')[1] or not pl[key] then
				local values = jam_getvar('VALUE')
				for index, value in ipairs(values) do
					values[index] = value == 'true'
				end
				pl[key] = values
			end
			" ;
	} else {
		LuaString "
			local currentLevel = GetInfoPlistCurrentLevel()
			local key = jam_getvar('KEY')
			local values = jam_getvar('VALUE')
			for index, value in ipairs(values) do
				currentLevel[#currentLevel + 1] = value
			end
" ;
	}
}


rule ios.BundleInfoArrayInteger TARGET : KEY : VALUE : NO_OVERRIDE {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	if $(VALUE) {
		LuaString "
			local key = jam_getvar('KEY')[1]
			local pl = GetInfoPlistCurrentLevel()
			if not jam_getvar('NO_OVERRIDE')[1] or not pl[key] then
				local values = jam_getvar('VALUE')
				for index, value in ipairs(values) do
					values[index] = tonumber(value)
				end
				pl[key] = values
			end
" ;
	} else {
		LuaString "
			local currentLevel = GetInfoPlistCurrentLevel()
			local values = jam_getvar('KEY')
			for index, value in ipairs(values) do
				currentLevel[#currentLevel + 1] = tonumber(value)
			end
" ;
	}
}


rule ios.BundleInfoArrayString TARGET : KEY : VALUE : NO_OVERRIDE {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	if $(VALUE) {
		LuaString "
			local key = jam_getvar('KEY')[1]
			local pl = GetInfoPlistCurrentLevel()
			if not jam_getvar('NO_OVERRIDE')[1] or not pl[key] then
				pl[key] = jam_getvar('VALUE')
			end
			" ;
	} else {
		LuaString "
			local currentLevel = GetInfoPlistCurrentLevel()
			local values = jam_getvar('KEY')
			for index, value in ipairs(values) do
				currentLevel[#currentLevel + 1] = value
			end
" ;
	}
}


rule ios.BundleInfo TARGET : TYPE : VALUE : NO_OVERRIDE {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	on $(C.ACTIVE_TOOLCHAIN_TARGET) if ! $(INFO_PLIST_KEYS) {
		INFO_PLIST_KEYS on $(C.ACTIVE_TOOLCHAIN_TARGET) = true ;

		ios.BundleInfoString : CFBundleDevelopmentRegion : en : $(NO_OVERRIDE) ;
		ios.BundleInfoString : CFBundleExecutable : [ C._retrieveOutputName $(TARGET) ] : $(NO_OVERRIDE) ;
		ios.BundleInfoString : CFBundleInfoDictionaryVersion : 6.0 : $(NO_OVERRIDE) ;
		ios.BundleInfoString : CFBundlePackageType : APPL : $(NO_OVERRIDE) ;
		ios.BundleInfoString : CFBundleSignature : ???? : $(NO_OVERRIDE) ;

		switch $(C.PLATFORM) {
			case ios :
				local sdkversion = $(IPHONEOS_SDK_VERSION:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
				sdkversion ?= $(IPHONEOS_SDK_VERSION:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

				local minimumsdkversion = $(IOS_SDK_VERSION_MIN:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
				minimumsdkversion ?= $(IOS_SDK_VERSION_MIN:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;
				minimumsdkversion ?= $(IOS_DEFAULT_MINIMUM_SDK_VERSION) ;

				ios.BundleInfoBoolean : LSRequiresIPhoneOS : true : $(NO_OVERRIDE) ;
				ios.BundleInfoArrayInteger : UIDeviceFamily : 1 2 : $(NO_OVERRIDE) ;
				ios.BundleInfoString : DTPlatformName : iphoneos : $(NO_OVERRIDE) ;
				ios.BundleInfoString : DTPlatformVersion : $(sdkversion) : $(NO_OVERRIDE) ;
				ios.BundleInfoString : DTSDKName : iphoneos$(sdkversion) : $(NO_OVERRIDE) ;
				if ! $(NT) {
					local xcodeVersions = [ Match "Xcode ([^$(NEWLINE)]*).*Build version ([^$(NEWLINE)]*)" : [ Shell "xcodebuild -version" ] ] ;
					xcodeVersions = [ Subst $(xcodeVersions[1]) : "%." : "" ] $(xcodeVersions[2]) ;
					xcodeVersions = 0$(xcodeVersions[1]) $(xcodeVersions[2]) ;
					ios.BundleInfoString : DTXcode : $(xcodeVersions[1]) : $(NO_OVERRIDE) ;
					ios.BundleInfoString : DTXcodeBuild : $(xcodeVersions[2]) : $(NO_OVERRIDE) ;

					local sdkVersion = [ Match "([^$(NEWLINE)]*)" : [ Shell "xcrun --sdk iphoneos$(sdkversion) --show-sdk-build-version" ] ] ;
					ios.BundleInfoString : DTSDKBuild : $(sdkVersion) : $(NO_OVERRIDE) ;
					ios.BundleInfoString : DTPlatformBuild : $(sdkVersion) : $(NO_OVERRIDE) ;

					local osVersion = [ Match "([^$(NEWLINE)]*)" : [ Shell "sw_vers -buildVersion" ] ] ;
					ios.BundleInfoString : BuildMachineOSBuild : $(osVersion) : $(NO_OVERRIDE) ;
				}
				ios.BundleInfoArrayString : CFBundleSupportedPlatforms : iPhoneOS : $(NO_OVERRIDE) ;
				ios.BundleInfoString : MinimumOSVersion : $(minimumsdkversion) : $(NO_OVERRIDE) ;
				if $(TARGETINFO_LOCATE) {
					Contents += "Projects[ [[C.*]] ].TARGETED_DEVICE_FAMILY[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(actualValues:J=,)]]

" ;
				}

			case iossimulator :
				local sdkversion = $(IPHONEOS_SDK_VERSION:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
				sdkversion ?= $(IPHONEOS_SDK_VERSION:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

				local minimumsdkversion = $(IOS_SDK_VERSION_MIN:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
				minimumsdkversion ?= $(IOS_SDK_VERSION_MIN:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;
				minimumsdkversion ?= $(IOS_DEFAULT_MINIMUM_SDK_VERSION) ;

				ios.BundleInfoBoolean : LSRequiresIPhoneOS : true : $(NO_OVERRIDE) ;
				ios.BundleInfoArrayInteger : UIDeviceFamily : 1 2 : $(NO_OVERRIDE) ;
				ios.BundleInfoString : DTPlatformName : iphonesimulator : $(NO_OVERRIDE) ;
				ios.BundleInfoString : DTSDKName : iphonesimulator$(sdkversion) : $(NO_OVERRIDE) ;
				ios.BundleInfoArrayString : CFBundleSupportedPlatforms : iPhoneSimulator : $(NO_OVERRIDE) ;
				ios.BundleInfoString : MinimumOSVersion : $(minimumsdkversion) : $(NO_OVERRIDE) ;
				if $(TARGETINFO_LOCATE) {
					Contents += "Projects[ [[C.*]] ].TARGETED_DEVICE_FAMILY[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(actualValues:J=,)]]

" ;
				}
		}
	}

	switch $(TYPE:L) {
		case info :					ios.BundleInfoString : CFBundleGetInfoString : $(VALUE) : $(NO_OVERRIDE) ;
		case iconfile :				ios.BundleInfoString : CFBundleIconFile : $(VALUE) : $(NO_OVERRIDE) ;
		case iconfiles :			ios.BundleInfoArrayString : CFBundleIconFiles : $(VALUE) : $(NO_OVERRIDE) ;
		case longversion :			ios.BundleInfoString : CFBundleLongVersionString : $(VALUE) : $(NO_OVERRIDE) ;
		case bundlename :
			ios.BundleInfoString : CFBundleName : $(VALUE) : $(NO_OVERRIDE) ;
			CFBundleName on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(VALUE) ;
		case displayname :
			ios.BundleInfoString : CFBundleDisplayName : $(VALUE) : $(NO_OVERRIDE) ;
			CFBundleDisplayName on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(VALUE) ;
		case executable :			ios.BundleInfoString : CFBundleExecutable : $(VALUE) ;
		case identifier :
			ios.BundleInfoString : CFBundleIdentifier : $(VALUE) : $(NO_OVERRIDE) ;
			CFBundleIdentifier on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(VALUE) ;
		case shortversion :			ios.BundleInfoString : CFBundleShortVersionString : $(VALUE) ;
		case bundleversion :
			ios.BundleInfoString : CFBundleVersion : $(VALUE) : $(NO_OVERRIDE) ;
			CFBundleVersion on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(VALUE) ;
		case copyright :			ios.BundleInfoString : NSHumanReadableCopyright : $(VALUE) : $(NO_OVERRIDE) ;
		case mainnibfile :			ios.BundleInfoString : NSMainNibFile : $(VALUE) : $(NO_OVERRIDE) ;
		case supportedplatforms :   ios.BundleInfoArrayString : CFBundleSupportedPlatforms : $(VALUE) : $(NO_OVERRIDE) ;
		case minimumosversion :		ios.BundleInfoString : MinimumOSVersion : $(VALUE) : $(NO_OVERRIDE) ;
		case uidevicefamily :
			local actualValues ;
			local value ;
			for value in $(VALUE) {
				if $(value) = iphone {
					if ! ( 1 in $(actualValues) ) {
						actualValues += 1 ;
					}
				} else if $(value) = ipad {
					if ! ( 2 in $(actualValues) ) {
						actualValues += 2 ;
					}
				} else if ! ( $(value) in $(actualValues) ) {
					actualValues += $(value) ;
				}
			}
			ios.BundleInfoArrayInteger : UIDeviceFamily : $(actualValues) : $(NO_OVERRIDE) ;
			if $(TARGETINFO_LOCATE) {
				Contents += "Projects[ [[C.*]] ].TARGETED_DEVICE_FAMILY[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(actualValues:J=,)]]

" ;
			}
		case uiprerenderedicon :	ios.BundleInfoBoolean : UIPrerenderedIcon : $(VALUE) : $(NO_OVERRIDE) ;
		case uistatusbarhidden :	ios.BundleInfoBoolean : UIStatusBarHidden : $(VALUE) : $(NO_OVERRIDE) ;
		case uiviewcontrollerbasedstatusbarappearance : ios.BundleInfoBoolean : UIViewControllerBasedStatusBarAppearance : $(VALUE) : $(NO_OVERRIDE) ;
		case uiinterfaceorientation :
			if $(VALUE) = portrait {
				ios.BundleInfoString : UIInterfaceOrientation : UIInterfaceOrientationPortrait : $(NO_OVERRIDE) ;
			}
			if $(VALUE) = portraitupsidedown {
				ios.BundleInfoString : UIInterfaceOrientation : UIInterfaceOrientationPortraitUpsideDown : $(NO_OVERRIDE) ;
			}
			if $(VALUE) = landscapeleft {
				ios.BundleInfoString : UIInterfaceOrientation : UIInterfaceOrientationLandscapeLeft : $(NO_OVERRIDE) ;
			}
			if $(VALUE) = landscaperight {
				ios.BundleInfoString : UIInterfaceOrientation : UIInterfaceOrientationLandscapeRight : $(NO_OVERRIDE) ;
			}
		case uisupportedinterfaceorientations :
			local values = ;
			if portrait in $(VALUE) {
				values += UIInterfaceOrientationPortrait ;
			}
			if portraitupsidedown in $(VALUE) {
				values += UIInterfaceOrientationPortraitUpsideDown ;
			}
			if landscapeleft in $(VALUE) {
				values += UIInterfaceOrientationLandscapeLeft ;
			}
			if landscaperight in $(VALUE) {
				values += UIInterfaceOrientationLandscapeRight ;
			}
			ios.BundleInfoArrayString : UISupportedInterfaceOrientations : $(values) : $(NO_OVERRIDE) ;
	}
}


rule ios.MergeInfoPList TARGET : SOURCE {
	TARGET = [ ActiveTarget $(TARGET) ] ;

	local grist = $(C.ACTIVE_TOOLCHAIN_TARGET_GRIST):source ;
	local source = $(SOURCE:BSG=$(grist)) ;
	if $(SOURCE:D) != "" {
		SEARCH on $(source) ?= $(SOURCE:D) ;
	}
	SEARCH on $(source) ?= $(SEARCH_SOURCE) ;

	local sourcePath = $(source:T) ;
	LuaString "
		if not plist then
			plist = require 'plist'
		end
		local left = plist.read(jam_getvar('sourcePath')[1])
		plist.merge(left, GetInfoPlistCurrentLevel())
" ;
}


rule ios.MergeEntitlements TARGET : SOURCE {
	TARGET = [ ActiveTarget $(TARGET) ] ;

	local grist = $(C.ACTIVE_TOOLCHAIN_TARGET_GRIST):source ;
	local source = $(SOURCE:BSG=$(grist)) ;
	if $(SOURCE:D) != "" {
		SEARCH on $(source) ?= $(SOURCE:D) ;
	}
	SEARCH on $(source) ?= $(SEARCH_SOURCE) ;
	MERGE_ENTITLEMENTS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(source) ;

	if $(TARGETINFO_LOCATE) {
		Contents += "Projects[ [[$(TARGET)]] ].XCODE_ENTITLEMENTS[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(source:T)]]$(NEWLINE)" ;
	}
}


rule ios.InfoPListFile TARGET : SOURCE {
	#TARGET = [ ActiveTarget $(TARGET) ] ;

	local grist = $(C.ACTIVE_TOOLCHAIN_TARGET_GRIST):intermediate ;
	local destination = @(Info.plist:G=$(grist)) ;
	MakeLocate $(destination) : $(LOCATE_SOURCE) ;

	grist = $(C.ACTIVE_TOOLCHAIN_TARGET_GRIST):source ;
	local source = $(SOURCE:G=$(grist)) ;
	BINDING on $(source) = $(SOURCE:BS) ;
	SEARCH on $(source) ?= $(SOURCE:D:R=$(SEARCH_SOURCE)) ;

	local EXECUTABLE_NAME = [ C._retrieveOutputName $(TARGET) ] ;
	C.ConfigureFile $(TARGET) : $(destination) : $(source) : parens ;
	INFO_PLIST_FILE on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(destination) ;

	local sourcePath = $(destination:T) ;
	LuaString "
		if not plist then
			plist = require 'plist'
		end
		local left = plist.read(jam_getvar('sourcePath')[1])
		plist.merge(left, GetInfoPlistCurrentLevel())
" ;

	if $(TARGETINFO_LOCATE) {
		Contents += "Projects[ [[$(C.ACTIVE_TARGET)]] ].INFOPLIST_FILE[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(source:T)]]$(NEWLINE)" ;
		Contents += "Projects[ [[$(C.ACTIVE_TARGET)]] ].Sources = concat(Projects[ [[$(C.ACTIVE_TARGET)]] ].Sources, { [[$(source:T)]] })$(NEWLINE)" ;
	}
}


actions C.ios._GenerateDSYMFile {
	$(C.DSYMUTIL:C) $(2:C) -o $(OUTPUT_PATH:C)
}


rule ios.BundlePath TARGET : BUNDLE_PATH {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	ios._SetDefaultBundlePath ;
	BUNDLE_PATH on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(BUNDLE_PATH:R=$(SUBDIR)) ;
}


rule ios.GetBundlePath TARGET {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	local bundlePath = $(BUNDLE_PATH:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	if ! $(bundlePath) {
		ios._SetDefaultBundlePath ;
		return $(BUNDLE_PATH:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	} else {
		return $(bundlePath) ;
	}
}


rule ios.GetBundleTarget TARGET {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	local bundleTarget = $(BUNDLE_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	if ! $(bundleTarget) {
		ios._SetDefaultBundlePath ;
		return $(BUNDLE_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	} else {
		return $(bundleTarget) ;
	}
}


rule C.ios.GenerateDSYMFile TARGET {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	local bundlePath = [ ios.GetBundlePath $(TARGET) ] ;
	local dsymBundlePath = $(bundlePath).dSYM ;
	local _t = $(LIPO_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	local _t.dsym = $(_t).DSYM ;
	DSYM_NAME on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(_t.dsym) ;
	BINDING on $(_t.dsym) = $(BINDING:Z=$(_t)) ;
	OUTPUT_PATH on $(_t.dsym) = $(dsymBundlePath) ;
	MakeLocate $(_t.dsym) : $(dsymBundlePath)/Contents/Resources/DWARF ;
	Depends $(C.ACTIVE_TOOLCHAIN_TARGET) : $(_t.dsym) : $(_t) ;
	CleanTree $(CLEAN_BUNDLE_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) : $(dsymBundlePath) ;
	C.ios._GenerateDSYMFile $(_t.dsym) : $(_t) : $(C.COMPILER_SUITE_SYMBOL) ;
}


C.__DOLLAR = \\$ ;
C.__JUST_DOLLAR = $ ;
C.__COLON = ":" ;

# 1. Make copy of incoming entitlements file to destination file.
# 2. If "<key>aps-environment</key>" and "<string>development</string>" is in file, then set "aps-environment" to "development" in destination file (required for push notifications).
# 3. If "<key>aps-environment</key>" and "<string>production</string>" is in file, then set "aps-environment" to "production" in destination file (required for push notifications).
# 4. If "<key>beta-reports-active</key>" exists, and next line is "<true/>", then set "beta-reports-active" to "true" in destination file (required for push notifications).
# 5. Set "get-task-allow" as per get-task-allow settings in provisioning profile (these must match).
# 6. Set 'keychain-access-groups:" as per keychain-access-groups settings in provisioning profile (these must match).
# 7. Set 'application-identifier' as per application-identifier setting in provisioning profile (these must match).
actions ios.ProcessEntitlements
{
	cp $(2[1]) $(1)
	cat "$(PROVISION)" | grep "<key>aps-environment</key>" > /dev/null && cat "$(PROVISION)" | grep "<string>development</string>" > /dev/null && /usr/libexec/PlistBuddy -c "Add :aps-environment string development" $(1)
	cat "$(PROVISION)" | grep "<key>aps-environment</key>" > /dev/null && cat "$(PROVISION)" | grep "<string>production</string>" > /dev/null && /usr/libexec/PlistBuddy -c "Add :aps-environment string production" $(1)
	cat "$(PROVISION)" | awk '/<key>beta-reports-active<\/key>/,/\/>/' | grep '<key>beta-reports-active</key>' -A1 | grep '<true/>' > /dev/null && /usr/libexec/PlistBuddy -c "Add :beta-reports-active bool true" $(1)
	security cms -D -i "$(PROVISION)" > $(1:D)/tmp.plist
	/usr/libexec/PlistBuddy -c "Add :get-task-allow bool" $(1)
	/usr/libexec/PlistBuddy -c "Set :get-task-allow `/usr/libexec/PlistBuddy -c "Print :Entitlements:get-task-allow" $(1:D)/tmp.plist`" $(1)
	/usr/libexec/PlistBuddy -c "Set :keychain-access-groups:0 `/usr/libexec/PlistBuddy -c "Print :Entitlements:keychain-access-groups:0" $(1:D)/tmp.plist`" $(1)
	/usr/libexec/PlistBuddy -c "Set :application-identifier `/usr/libexec/PlistBuddy -c "Print :Entitlements:application-identifier" $(1:D)/tmp.plist`" $(1)
	rm $(1:D)/tmp.plist
}

if $(NT) {

actions C.ios._Lipo {
	if exist "$(1:\\).lipo" del /F "$(1:\\).lipo"
	if exist "$(1:\\)" del /F "$(1:\\)"
	$(C.LIPO:C) $(2:C) -output $(1:C) -create
}

} else {

actions C.ios._Lipo {
	$(C.LIPO:C) $(2:C) -output $(1:C) -create
}

}

rule C.ios.Lipo TARGET : LINK_TARGETS : OUTPUT_PATH {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	local _t = $(LINK_TARGETS[0]:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)$(C.__COLON)lipo) ;
	BINDING on $(_t) = $(BINDING:Z=$(LINK_TARGETS[0])) ;
	Depends $(TARGET) : $(C.ACTIVE_TOOLCHAIN_TARGET) : $(_t) : $(LINK_TARGETS) ;
	MakeLocate $(_t) : $(OUTPUT_PATH) ;
	UseCommandLine $(_t) : $(LINK_TARGETS) ;
	Clean $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(_t) ;
	C.ios._Lipo $(_t) : $(LINK_TARGETS) : $(C.COMPILER_SUITE_SYMBOL) ;
	LIPO_TARGET on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(_t) ;
	return $(linkTargets) ;
}


if ! $(TARGETINFO_LOCATE) {

rule ios.Bundle TARGET : TOOLCHAINS {
	TARGET = [ ActiveTarget $(TARGET) ] ;

	local bundlePath = [ ios.GetBundlePath ] ;
	local bundleTarget = [ ios.GetBundleTarget ] ;
	local cleanBundleTarget = $(CLEAN_BUNDLE_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	Depends $(C.ACTIVE_TOOLCHAIN_TARGET) : $(bundleTarget) ;
	NotFile $(bundleTarget) ;
	Depends clean : clean:$(TARGET) : $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(cleanBundleTarget) ;
	NotFile clean:$(TARGET) $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) ;
	Always clean:$(TARGET) $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) ;
	NotFile $(cleanBundleTarget) ;
	Always $(cleanBundleTarget) ;

	local linkTargets ;
	local toolchain ;
	for toolchain in $(TOOLCHAINS:E=$(C.ACTIVE_TOOLCHAIN)) {
		linkTargets += [ C.GetLinkTargets $(TARGET) : $(toolchain) ] ;
	}
	C.ios.Lipo $(TARGET) : $(linkTargets) : $(bundlePath).lipo ;

	{
		local isysroot = $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
		isysroot ?= $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

		# Handle the PkgInfo file
		local pkginfo = @(PkgInfo:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
		MakeLocate $(pkginfo) : $(bundlePath) ;
		local contents = APPL???? ;
		CONTENTS on $(pkginfo) = $(contents) ;
		WriteFile $(pkginfo) ;
		UseCommandLine $(pkginfo) : $(contents) ;
		Depends $(bundleTarget) : $(pkginfo) ;
		Clean $(cleanBundleTarget) : $(pkginfo) ;

		# Handle the Info.plist file.
		local infoplist = @(Info.plist:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
		MakeLocate $(infoplist) : $(bundlePath) ;
		Depends $(bundleTarget) : $(infoplist) ;
		Clean $(cleanBundleTarget) : $(infoplist) ;

		local CFBundleIdentifier ;
		local sourceInfoPlistFile = $(INFO_PLIST_FILE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
		if ! $(sourceInfoPlistFile) {
			local customPlistExists = [ LuaString "
				local currentLevel = GetInfoPlistCurrentLevelNoCreate()
				return currentLevel and true or false
" ] ;
			if $(customPlistExists) = false {
				local infoPlist = [ Glob $(SUBDIR) : Info.plist ] ;
				if $(infoPlist) {
					ios.InfoPListFile $(TARGET) : Info.plist ;
					sourceInfoPlistFile = $(INFO_PLIST_FILE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
				}
			}
		}
		local writeInternalInfoPlist = 1 ;

		local CFBundleVersion ;
		local CFBundleDisplayName ;
		local CFBundleExecutable ;
		LuaString "local pl = GetInfoPlistCurrentLevel()
				local CFBundleIdentifier = pl['CFBundleIdentifier']
				jam_setvar('CFBundleIdentifier', CFBundleIdentifier)
				local CFBundleVersion = pl['CFBundleVersion']
				jam_setvar('CFBundleVersion', CFBundleVersion)
				local CFBundleDisplayName = pl['CFBundleDisplayName']
				jam_setvar('CFBundleDisplayName', CFBundleDisplayName)
				local CFBundleExecutable = pl['CFBundleExecutable']
				jam_setvar('CFBundleExecutable', CFBundleExecutable)
				" ;
		CFBundleIdentifier on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(CFBundleIdentifier) ;
		CFBundleVersion on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(CFBundleVersion) ;
		CFBundleDisplayName on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(CFBundleDisplayName) ;

		#if $(CFBundleExecutable) {
			#CopyFile $(bundleTarget) : $(infoplist) : $(sourceInfoPlistFile) ;
			#writeInternalInfoPlist = 0 ;
		#} else {
		ios.BundleInfo $(TARGET) : : : 1 ;
		#}

		if $(writeInternalInfoPlist) = 1 {
			local infoplistcontents = [ LuaString "
				local currentLevel = GetInfoPlistCurrentLevel()
				return plist.dump(currentLevel, true)
" ] ;
			if $(infoplistcontents) {
				CONTENTS on $(infoplist) = $(infoplistcontents) ;
				WriteFile $(infoplist) ;

				UseCommandLine $(infoplist) : $(infoplistcontents) ;
			}
		}

		local provisionFileTarget = $(PROVISION_FILE_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
		if ! $(provisionFileTarget) {
			ios.Provision $(TARGET) : $(CFBundleIdentifier) ;
		}

		if $(DISABLE_ME)  &&  $(C.PLATFORM) in ios  &&  ! $(NT) {
			# Create Entitlements.plist.
			local sourceEntitlementsPlist = @(Entitlements.plist:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)|source) ;
			SEARCH on $(sourceEntitlementsPlist) = $(isysroot) ;
			local destEntitlementsPlist = @(Entitlements.plist:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
			MakeLocate $(destEntitlementsPlist) : $(LOCATE_TARGET) ;
			ENTITLEMENTS on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(destEntitlementsPlist) ;
			Depends $(bundleTarget) : $(destEntitlementsPlist) : $(sourceEntitlementsPlist) $(PROVISION_FILE_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
			Clean $(cleanBundleTarget) : $(destEntitlementsPlist) ;
			local provisionFileTarget = $(PROVISION_FILE_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
			PROVISION on $(destEntitlementsPlist) = $(provisionFileTarget:TC/) ;
			ios.ProcessEntitlements $(destEntitlementsPlist) : $(sourceEntitlementsPlist) $(PROVISION_FILE_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) : $(C.ACTIVE_TOOLCHAIN_TARGET) ;
		}
		if $(C.PLATFORM) in ios { #  &&  $(NT) {
#			local plistutil = $(JAM_EXECUTABLE_PATH:D)/libimobiledevice/plistutil.exe ;
#			if ! [ Search $(plistutil) ]
#			{
#				local downloadDirectory = $(JAM_EXECUTABLE_PATH:D)/libimobiledevice ;
#				Shell "mkdir $(downloadDirectory:\\C)" ;
#				local libimobiledevice.zip = $(downloadDirectory)/libimobiledevice.zip ;
#				local command = "curl -L -o $(libimobiledevice.zip:C) https://github.com/iFred09/libimobiledevice-windows/archive/master.zip" ;
#				Shell $(command) ;
#				local command = "unzip $(libimobiledevice.zip) -o -d $(downloadDirectory)" ;
#				Shell $(command) ;
#			}

#			local sourceEntitlementsPlist = @(Entitlements.plist:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)|source) ;
#			SEARCH on $(sourceEntitlementsPlist) = $(isysroot) ;

#Echo sourceEntitlementsPlist - [ $(sourceEntitlementsPlist) ] ;
#			if [ Search $(sourceEntitlementsPlist) ]
#			{
#				local buffer = [ Shell "$(plistutil) -i $(sourceEntitlementsPlist:C)" ] ;
#				Echo buffer - $(buffer) ;
#			}

			LuaString "
				if not plist then
					plist = require 'plist'
				end
" ;

			local getTaskAllowTrueEntitlement = "
<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">
<plist version=\"1.0\">
<dict>
	<key>get-task-allow</key>
	<true />

</dict>
</plist>
" ;

			local mergeEntitlements = $(MERGE_ENTITLEMENTS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
			if $(mergeEntitlements)
			{
				local sourcePath = $(mergeEntitlements[1]:T) ;
				LuaString "
					entitlementsPlist = plist.read(jam_getvar('sourcePath')[1])
" ;
				local sourceEntitlement ;
				for sourceEntitlement in $(mergeEntitlements[2-]) {
					local sourcePath = $(sourceEntitlement:T) ;
					LuaString "
						local newEntitlementsPlist = plist.read(jam_getvar('sourcePath')[1])
						plist.merge(newEntitlementsPlist, entitlementsPlist)
" ;
				}
				LuaString "
					local newEntitlementsPlist = plist.readbuffer(jam_getvar('getTaskAllowTrueEntitlement')[1])
					plist.merge(newEntitlementsPlist, entitlementsPlist)
" ;
				#if $(contents) {
				if 1 {
					local destEntitlementsPlist = @(Entitlements.plist:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
					MakeLocate $(destEntitlementsPlist) : $(LOCATE_TARGET) ;
					ENTITLEMENTS on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(destEntitlementsPlist) ;
					Depends $(bundleTarget) : $(destEntitlementsPlist) : $(mergeEntitlements) $(PROVISION_FILE_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
					Clean $(cleanBundleTarget) : $(destEntitlementsPlist) ;

					local provisionFileTarget = $(PROVISION_FILE_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
					local provisionFileTargetExpanded = $(provisionFileTarget:T) ;
					local CFBundleIdentifier ;
					local AppIdentifierPrefix ;
					local TeamIdentifier ;
					contents = [ LuaString "
						local plist = require 'plist'
						local pl = plist.read(jam_getvar('provisionFileTargetExpanded')[1])
						local prefix = pl.ApplicationIdentifierPrefix
						jam_setvar('AppIdentifierPrefix', prefix)
						local identifier = pl.Entitlements[\"application-identifier\"]
						identifier = identifier:sub(#prefix[1] + 1)
						jam_setvar('CFBundleIdentifier', identifier)
						local identifier = pl.Entitlements[\"com.apple.developer.team-identifier\"]
						jam_setvar('TeamIdentifier', identifier)
						--local buffer = plist.dump(pl.Entitlements, true)
						--local plEntitlements = plist.readbuffer(buffer)
						--plist.merge(plEntitlements, entitlementsPlist)
						--print(plist.dump(entitlementsPlist, true))
						return plist.dump(entitlementsPlist, true)
" ] ;

					#AppIdentifierPrefix = $(TeamIdentifier) ;
					contents = $(contents:A) ;

					PROVISION on $(destEntitlementsPlist) = $(provisionFileTarget:TC/) ;
					#ios.ProcessEntitlements $(destEntitlementsPlist) : $(sourceEntitlementsPlist) $(PROVISION_FILE_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) : $(C.ACTIVE_TOOLCHAIN_TARGET) ;

					CONTENTS on $(destEntitlementsPlist) = $(contents) ;
					WriteFile $(destEntitlementsPlist) ;

					UseCommandLine $(destEntitlementsPlist) : $(contents) ;
				}
			}
		}

		{
			local provisionFileTarget = $(PROVISION_FILE_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
			local embedded.mobileprovision = @(embedded.mobileprovision:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
			MakeLocate $(embedded.mobileprovision) : $(bundlePath) ;

			# Copy provision into the bundle and name it embedded.mobileprovision
			Depends $(bundleTarget) : $(embedded.mobileprovision) ;
			CopyFile $(TARGET) : $(embedded.mobileprovision) : $(provisionFileTarget) ;

			# Without this, if we change between profiles, the copy will not always
			# work due to destination time stamp being newer than source (despite
			# coming from a different file).
			UseCommandLine $(embedded.mobileprovision) : $(provisionFileTarget) ;
		}
	}
	

	if $(C.PLATFORM) in ios {
		local destinationPath = $(bundlePath)/Frameworks ;

		local frameworkDirectories = $(FRAMEWORK_DIRECTORIES:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;

		local framework ;
		for framework in $(EMBED_FRAMEWORKS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) {
			framework = $(framework:S=.framework) ;
			local foundFramework = [ Glob $(frameworkDirectories) : $(framework)/ ] ;
			if ! $(foundFramework) {
				Exit * Cannot find framework $(framework). ;
			}
			local frameworkTarget = $(bundleTarget)|$(framework) ;
			NotFile $(frameworkTarget) ;
			CopyDirectory $(frameworkTarget) : $(destinationPath)/$(framework) : $(foundFramework) : **@-**/Headers/@-**/Modules/@-**/PrivateHeaders/@-**/_CodeSignature/ ;

			local dependsList = [ DependsList $(frameworkTarget) ] ;
			dependsList = [ ListSort $(dependsList) ] ;

			local codeResources = @(CodeResources:G=$(frameworkTarget)) ;
			MakeLocate $(codeResources) : $(destinationPath)/$(framework)/_CodeSignature ;
			Depends $(bundleTarget) : $(frameworkTarget) ;

			if $(IOSBUILDENV_PATH) {
				UseCommandLine $(codeResources) : $(dependsList) ;
				Depends $(frameworkTarget) : $(codeResources) : $(dependsList) ;
				#Clean $(cleanBundleTarget) : $(codeResources) ;

				local framework = $(destinationPath)/$(framework)/$(framework:S=) ;
				local certificateChain = $(CERTIFICATE_CHAIN:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
				certificateChain ?= "ios_development.cer:AppleIncRootCertificate.cer:AppleWWDRCAG3.cer:private_key01.key:password" ;
				CERTIFICATE_CHAIN on $(codeResources) $(framework) = $(certificateChain) ;
				ios._CodeSignFramework $(codeResources) $(framework) : $(dependsList) $(framework) : $(C.COMPILER_SUITE_SYMBOL) ;
			} else {
				UseCommandLine $(codeResources) : $(dependsList) ;
				Depends $(frameworkTarget) : $(codeResources) : $(dependsList) ;
				#Clean $(cleanBundleTarget) : $(codeResources) ;

				local signingIdentity = $(SIGNING_IDENTITY:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
				signingIdentity ?= "Apple Development" ;
				SIGNING_IDENTITY on $(codeResources) $(framework) = $(signingIdentity) ;

				local framework = $(destinationPath)/$(framework)/$(framework:S=) ;
				FRAMEWORK_PATH on $(codeResources) $(framework) = $(framework) ;
				ios._CodeSignFramework $(codeResources) $(framework) : $(dependsList) $(framework) : $(C.COMPILER_SUITE_SYMBOL) ;
			}
		}
	}

	if $(C.PLATFORM) in ios {
		# Copy the lipo'ed executable to the bundle.
		local lipoTarget = $(LIPO_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
		local bundleTargetGrist = $(C.ACTIVE_TOOLCHAIN_TARGET_GRIST):bundle ;
		local bundleLipoTarget = $(lipoTarget:G=$(bundleTargetGrist)) ;
		MakeLocate $(bundleLipoTarget) : $(bundlePath) ;
		Depends $(bundleTarget) : $(bundleLipoTarget) : $(lipoTarget) ;
		BINDING on $(bundleLipoTarget) = $(lipoTarget:BS) ;
		Copy1File $(bundleLipoTarget) : $(lipoTarget) ;
		Clean $(cleanBundleTarget) : $(bundleLipoTarget) ;
		BUNDLE_LIPO_TARGET on $(bundleTarget) = $(bundleLipoTarget) ;

		local entitlements = $(ENTITLEMENTS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
		local signingIdentity = $(SIGNING_IDENTITY:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
		signingIdentity ?= "Apple Development" ;

		local dependsList = [ DependsList $(bundleTarget) ] ;
		dependsList = [ ListSort $(dependsList) ] ;

		local codeResources = @(CodeResources:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
		MakeLocate $(codeResources) : $(bundlePath)/_CodeSignature ;

		if $(IOSBUILDENV_PATH) {
			UseCommandLine $(codeResources) : $(dependsList) ;
			Depends $(bundleTarget) : $(codeResources) : $(dependsList) ;
			Clean $(cleanBundleTarget) : $(codeResources) ;

			local certificateChain = $(CERTIFICATE_CHAIN:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
			certificateChain ?= "ios_development.cer:AppleIncRootCertificate.cer:AppleWWDRCAG3.cer:private_key01.key:password" ;
			CERTIFICATE_CHAIN on $(codeResources) $(bundleLipoTarget) = $(certificateChain) ;
			ENTITLEMENTS on $(codeResources) $(bundleLipoTarget) = $(entitlements) ;
			ios._CodeSign $(codeResources) $(bundleLipoTarget) : $(dependsList) : $(C.COMPILER_SUITE_SYMBOL) ;
		} else {
			local codeResourcesSymbolicLink = [ C.GristFiles : CodeResourcesLink ] ;
			BINDING on $(codeResourcesSymbolicLink) = CodeResources ;
			MakeLocate $(codeResourcesSymbolicLink) : $(bundlePath) ;

			BUNDLE_PATH on $(codeResources) $(bundleLipoTarget) = $(bundlePath) ;
			ENTITLEMENTS on $(codeResources) $(bundleLipoTarget) = $(entitlements) ;
			SIGNING_IDENTITY on $(codeResources) $(bundleLipoTarget) = $(signingIdentity) ;

			local dsym_name = $(DSYM_NAME:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
			DSYM_NAME on $(codeResources) $(bundleLipoTarget) = $(dsym_name) ;

			UseCommandLine $(codeResources) : $(dependsList) $(dsym_name) ;
			Depends $(bundleTarget) : $(codeResources) : $(dependsList) $(dsym_name) ;
			Clean $(cleanBundleTarget) : $(codeResources) $(codeResourcesSymbolicLink) ;

			ios._CodeSign $(codeResources) : $(dependsList) $(dsym_name) : $(C.COMPILER_SUITE_SYMBOL) ;
		}
	}

	if $(C.PLATFORM) in ios iossimulator {
		C.ios.GenerateDSYMFile $(TARGET) ;
	}
}

} else { # TARGETINFO_LOCATE

rule ios.Bundle TARGET : TOOLCHAINS {
	TARGET = [ C.ActiveTarget $(TARGET) ] ;
	local project = "Projects[ [[$(TARGET)]] ]" ;
	local bundlePath = [ ios.GetBundlePath ] ;
	Contents += "$(project).BUNDLE_PATH[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(bundlePath)]]$(NEWLINE)" ;
	Contents += "if not $(project).Options then $(project).Options = {} end$(NEWLINE)" ;
	Contents += "$(project).Options['bundle'] = true$(NEWLINE)" ;
}

} # TARGETINFO_LOCATE


rule ios._SetDefaultBundlePath {
	if $(BUNDLE_PATH:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) {
		return ;
	}

	local outputName = [ C._retrieveOutputName ] ;
	local outputPath = [ C._retrieveOutputPath ] ;
	local bundlePath = $(outputPath)/$(outputName).app ;
	BUNDLE_PATH on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(bundlePath) ;

	local bundleTarget = $(C.ACTIVE_TOOLCHAIN_TARGET):bundle ;
	local colon = ":" ;
	local cleanBundleTarget = @(clean$(colon)$(bundleTarget:G=):G=$(C.ACTIVE_TOOLCHAIN_GRIST)) ;
	BUNDLE_TARGET on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(bundleTarget) ;
	CLEAN_BUNDLE_TARGET on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(cleanBundleTarget) ;
}


rule C.ios._ApplicationFromObjects_PostBuild {
	ios._SetDefaultBundlePath ;

	if bundle in $(OPTIONS) {
		ios.Bundle ;
	}

	if archive in $(OPTIONS) {
		ios.Archive ;
	}
}


rule C.ios._Inherits {
	local publicFrameworks = $(PUBLIC_FRAMEWORKS:Z=$(inheritsTarget)) ;
	if $(publicFrameworks) {
		FRAMEWORKS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(publicFrameworks) ;
		if $(public) {
			PUBLIC_FRAMEWORKS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(publicFrameworks) ;
		}
	}
}


rule ios.ProductVersion TARGET : VERSION_NAME : VERSION_CODE {
	TARGET = [ ActiveTarget $(TARGET) ] ;

	IOS.VERSION_NAME on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(VERSION_NAME) ;
	IOS.VERSION_CODE on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(VERSION_CODE) ;

	if $(TARGETINFO_LOCATE) {
		Contents += "Projects[ [[$(TARGET)]] ].PRODUCT_VERSION_NAME[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(VERSION_NAME)]]$(NEWLINE)" ;
		Contents += "Projects[ [[$(TARGET)]] ].PRODUCT_VERSION_CODE[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(VERSION_CODE)]]$(NEWLINE)" ;
	}
}


rule C.ios._MultiCppCompile_SetupFlags {
	local isysroot = $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	isysroot ?= $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

	local sdkversion = $(IPHONEOS_SDK_VERSION:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	sdkversion ?= $(IPHONEOS_SDK_VERSION:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

	local minimumsdkversion = $(IOS_SDK_VERSION_MIN:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	minimumsdkversion ?= $(IOS_SDK_VERSION_MIN:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;
	minimumsdkversion ?= $(IOS_DEFAULT_MINIMUM_SDK_VERSION) ;

	local architecture = $(C.ARCHITECTURE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	architecture ?= $(C.ARCHITECTURE:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

	local extraflags ;
	if $(IOSBUILDENV_PATH) {
		extraflags = -U__STDC_HOSTED__ -U__clang_major__ -D__clang_major__=99 ;
		architecture ?= armv7 ;
		extraflags += -target $(architecture)-apple-ios$(minimumsdkversion) ;
		if $(isysroot) {
			extraflags += --sysroot $(isysroot:C) ;
		}
		local noPeriodVersion = [ Subst $(minimumsdkversion) : %. : "" ] ;
		extraflags += -integrated-as -fdiagnostics-format=msvc -fconstant-cfstrings -fvisibility=hidden ;
		extraflags += -miphoneos-version-min=$(minimumsdkversion).0 ;
		extraflags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=$(noPeriodVersion)000 ;
		extraflags += -F\"$(IOSBUILDENV_PATH)/SDK/System/Library/Frameworks\" ;    #"
	} else {
		extraflags += -target $(architecture)-apple-ios$(minimumsdkversion) ;
		extraflags += "-isysroot $(isysroot:C)" ;
		extraflags += "-arch $(architecture)" ;
		switch $(C.PLATFORM) {
			case macosx32 :
				# 10.4, 10.5, 10.6, 10.7, 10.8 10.9
				extraflags += -mmacosx-version-min=$(minimumsdkversion) ;

			case macosx64 :
				# 10.4, 10.5, 10.6, 10.7, 10.8 10.9
				extraflags += -mmacosx-version-min=$(minimumsdkversion) ;

			case ios :
				# 4.3, 5.0, 5.1, 6.0, 6.1, 7.0, 7.1, 8.0, 8.1, 8.2, 8.3
				extraflags += -miphoneos-version-min=$(minimumsdkversion) ;

			case iossimulator :
				# 4.3, 5.0, 5.1, 6.0, 6.1, 7.0, 7.1, 8.0, 8.1, 8.2, 8.3
				extraflags += -mios-simulator-version-min=$(minimumsdkversion) ;
		}
	}

	_flags = $(_flags[1-4]) $(extraflags) $(_flags[5-]) ;

	C.$(C.COMPILER_SUITE)._MultiCppCompile_SetupFlags ;
}


rule C.ios._ApplicationFromObjects_LinkFlags {
	linkRule = C.ios.$(C.COMPILER_SUITE).Link ;

	local isysroot = $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	isysroot ?= $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

	local architecture = $(C.ARCHITECTURE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	architecture ?= $(C.ARCHITECTURE:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

	local sdkversion = $(IPHONEOS_SDK_VERSION:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	sdkversion ?= $(IPHONEOS_SDK_VERSION:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

	local minimumsdkversion = $(IOS_SDK_VERSION_MIN:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	minimumsdkversion ?= $(IOS_SDK_VERSION_MIN:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;
	minimumsdkversion ?= $(IOS_DEFAULT_MINIMUM_SDK_VERSION) ;

	if $(IOSBUILDENV_PATH) {
		linkFlags += "-arch $(architecture)" ;
		linkFlags += "-syslibroot $(isysroot:C\\)" ;
		linkFlags += -demangle -dead_strip ;
		linkFlags += "-ios_version_min $(minimumsdkversion)" ;
		linkFlags += "-sdk_version $(sdkversion)" ;
		linkFlags += -lobjc -lSystem -lc++ ;
		linkFlags += \"$(IOSBUILDENV_PATH)/SDK/libclang_rt.ios.a\" ;
		linkFlags += -F\"$(IOSBUILDENV_PATH)/SDK/System/Library/Frameworks\" ;
	} else {
		linkFlags += "-target $(architecture)-apple-ios$(minimumsdkversion)" ;
		linkFlags += "-isysroot $(isysroot:C)" ;
		linkFlags += "-arch $(architecture)" ;
		switch $(C.PLATFORM) {
			case ios :
				# 4.3, 5.0, 5.1, 6.0, 6.1, 7.0, 7.1, 8.0
				linkFlags += -miphoneos-version-min=$(minimumsdkversion) ;

			case iossimulator :
				# 4.3, 5.0, 5.1, 6.0 6.1 7.0
				linkFlags += -mios-simulator-version-min=$(minimumsdkversion) ;
		}
	}

	linkFlags += "-framework $(FRAMEWORKS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))" ;
	linkFlags += "-weak_framework $(WEAK_FRAMEWORKS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))" ;
}


rule C.ios._LibraryFromObjects_LibFlags {
	archiveRule = C.ios.$(C.COMPILER_SUITE).Archive ;

	local isysroot = $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	isysroot ?= $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;
	if $(isysroot) {
		#libFlags += -syslibroot $(isysroot:C) ;
	}
}


rule C.ios._SharedLibraryFromObjects_LinkFlags {
	linkRule = C.ios.$(C.COMPILER_SUITE).Link ;

	local isysroot = $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	isysroot ?= $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

	local architecture = $(C.ARCHITECTURE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	architecture ?= $(C.ARCHITECTURE:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

	if $(IOSBUILDENV_PATH) {
		linkFlags += "-syslibroot $(isysroot:C)" ;
		linkFlags += -F\"$(IOSBUILDENV_PATH)/SDK/System/Library/Frameworks\" ;
		linkFlags += -lSystem -lcrt1.o -lstdc++ ;
	} else {
		linkFlags += "-isysroot $(isysroot:C)" ;
		linkFlags += "-arch $(architecture)" ;
	}

	if module in $(OPTIONS) {
		linkFlags += -bundle -undefined dynamic_lookup -fPIC ;
	} else {
		local installName =
			$(INSTALL_NAME_PATH:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))
			$(INSTALL_NAME_PATH:Z=$(C.ACTIVE_TOOLCHAIN_*))
		;
		if ! $(installName) {
			installName = $(_t:TD) ;
		} else {
			installName = $(installName[1]) ;
		}
		local outputName = [ C._retrieveOutputName : $(_t:S) ] ;
		installName = $(outputName:BSR=$(installName)) ;
		linkFlags += -dynamiclib -fPIC -install_name $(installName) ;
	}
}


rule ios.ProvisionFile TARGET : FILENAME {
	TARGET = [ C.ActiveTarget $(TARGET) ] ;

	local _provisionDir = $(FILENAME:D) ;
	if $(_provisionDir) = "" {
	    _provisionDir = $(SUBDIR) ;
	}

	local _provisionFileTarget = $(FILENAME:BS/G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
	SEARCH on $(_provisionFileTarget) = $(_provisionDir) ;
	PROVISION_FILE_TARGET on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(_provisionFileTarget) ;

	_provisionFileTarget = $(_provisionFileTarget:T) ;

	local bundleIdentifier ;
	local teamIdentifier ;
	local provisioningProfileSpecifier ;
	LuaString "
		local pl = require 'plist'.read(jam_getvar('_provisionFileTarget')[1])
		local prefix = pl.ApplicationIdentifierPrefix
		local identifier = pl.Entitlements[\"application-identifier\"]
		identifier = identifier:sub(#prefix[1] + 2)
		jam_setvar('bundleIdentifier', identifier)

		local identifier = pl.Entitlements[\"com.apple.developer.team-identifier\"]
		jam_setvar('teamIdentifier', identifier)

		local name = pl.Name
		jam_setvar('provisioningProfileSpecifier', name)
	" ;
	if $(bundleIdentifier) != * {
		ios.BundleInfoString $(TARGET) : CFBundleIdentifier : $(bundleIdentifier) ;
		CFBundleIdentifier on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(bundleIdentifier) ;

		if $(TARGETINFO_LOCATE) {
			Contents += "Projects[ [[$(TARGET)]] ].PRODUCT_BUNDLE_IDENTIFIER[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(bundleIdentifier)]]
" ;
			Contents += "Projects[ [[$(TARGET)]] ].PROVISIONING_PROFILE_SPECIFIER[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(provisioningProfileSpecifier)]]
" ;
		}
	}
	if $(teamIdentifier) {
		if $(TARGETINFO_LOCATE) {
			Contents += "Projects[ [[$(TARGET)]] ].TEAM_IDENTIFIER[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(teamIdentifier)]]
" ;
		}
	}
}


if $(TARGETINFO_LOCATE) {

rule ios.XIB {

}

rule C.ios.SetTaskAllow {
}

rule ios.CodeSign TARGET : SIGNING_IDENTITY {
	Contents += "Projects[ [[C.*]] ].IOS_SIGNING_IDENTITY[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(SIGNING_IDENTITY)]]

" ;
}


rule ios.CodeSignAutomatic TARGET {
	TARGET = [ ActiveTarget $(TARGET) ] ;

	Contents += "Projects[ [[$(TARGET)]] ].IOS_SIGNING_AUTOMATIC[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = true$(NEWLINE)" ;
}


rule C.ios._ApplicationTargetInfo {
#	if $(C.PLATFORM) in ios  &&  ! $(NT) {
#		local isysroot $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
#		isysroot ?= $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;
#		
#		# Create Entitlements.plist.
#		local sourceEntitlementsPlist = @(Entitlements.plist:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)|source) ;
#		SEARCH on $(sourceEntitlementsPlist) = $(isysroot) ;
#		local destEntitlementsPlist = @(Entitlements.plist:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
#		MakeLocate $(destEntitlementsPlist) : $(LOCATE_TARGET) ;
#		Depends all : $(destEntitlementsPlist) : $(sourceEntitlementsPlist) $(PROVISION_FILE_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
#		ios.ProcessEntitlements $(destEntitlementsPlist) : $(sourceEntitlementsPlist) $(PROVISION_FILE_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) : $(C.ACTIVE_TOOLCHAIN_TARGET) ;
#
#		Contents += "Projects[ [[$(TARGET)]] ].XCODE_ENTITLEMENTS[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(destEntitlementsPlist:T)]]
#
#" ;
#	}

if 1 { return ; }
	# This isn't a great place for this, but it is the only accessible one at this time.
	local _linkLibs =
		$(LINKLIBS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))
		$(LINKLIBS:Z=$(C.ACTIVE_TOOLCHAIN_*))
	;
	local linkLibs ;
	local lib ;
	for lib in $(_linkLibs) {
		if ! $(lib) in $(linkLibs) {
			linkLibs += $(lib) ;
		}
	}
	local prefix = "Projects[ [[$(C.ACTIVE_TARGET)]] ]" ;
	Contents += "$(prefix).Sources = concat($(prefix).Sources, {$(NEWLINE)" ;
		Contents += "$(TAB)[[lib$(linkLibs).a]],$(NEWLINE)" ;
	Contents += "})$(NEWLINE)" ;
}


rule ios.Storyboard TARGET : SOURCES {
    TARGET = [ ActiveTarget $(TARGET) ] ;

    SOURCES = $(SOURCES:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
    SEARCH on $(SOURCES) += $(SEARCH_SOURCE) ;

    local LANGUAGE_SUBDIRECTORY = $(SOURCES[1]:TD) ;
    LANGUAGE_SUBDIRECTORY = $(LANGUAGE_SUBDIRECTORY:BS) ;

	if $(TARGETINFO_LOCATE) {
		local prefix = "Projects[ [[$(C.ACTIVE_TARGET)]] ]" ;
		Contents += "$(prefix).Sources = concat($(prefix).Sources, {$(NEWLINE)" ;
			Contents += "$(TAB)[[$(SOURCES:T)]],$(NEWLINE)" ;
		Contents += "})$(NEWLINE)" ;
	}
}


rule ios.Storyboards TARGET : LANGUAGE_DIRECTORY : STORYBOARD_FILES {
    LANGUAGE_DIRECTORY = $(LANGUAGE_DIRECTORY:R=$(SUBDIR)) ;
    local storyboards = [ Glob $(LANGUAGE_DIRECTORY) : *.storyboard ] ;
    storyboards = $(storyboards:BSG=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
    SEARCH on $(storyboards) = $(LANGUAGE_DIRECTORY) ;
    ios.Storyboard $(TARGET) : $(storyboards) ;

	if ! $(INFO_PLIST_FILE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) {
		if $(STORYBOARD_FILES[1]) {
			ios.BundleInfoString : UILaunchStoryboardName : $(STORYBOARD_FILES[1]) ;
		}
		if $(STORYBOARD_FILES[2]) {
			ios.BundleInfoString : UIMainStoryboardFile : $(STORYBOARD_FILES[2]) ;
		}
	}
}


rule ios.AssetCatalog PARENT : ASSET_CATALOG_PATH : APP_ICON_NAME : LAUNCH_IMAGE_NAME : DESTINATION_PATH {
    ASSET_CATALOG_PATH = $(ASSET_CATALOG_PATH:R=$(SUBDIR)) ;

    local target = [ ios.GetBundleTarget ] ;
    local bundlePath = [ ios.GetBundlePath ] ;
    if ! $(DESTINATION_PATH) {
        DESTINATION_PATH = $(bundlePath) ;
    }
    ASSET_CATALOG_PATH = $(ASSET_CATALOG_PATH:R=$(SUBDIR)) ;

	if $(TARGETINFO_LOCATE) {
		Contents += "Projects[ [[$(C.ACTIVE_TARGET)]] ].Sources = concat(Projects[ [[$(C.ACTIVE_TARGET)]] ].Sources, { [[$(ASSET_CATALOG_PATH:T)]] })$(NEWLINE)" ;
		Contents += "Projects[ [[$(C.ACTIVE_TARGET)]] ].ASSETCATALOG_COMPILER_APPICON_NAME[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(APP_ICON_NAME:E=AppIcon)]]$(NEWLINE)" ;
	}
}




} else {

rule ios.XIB PARENT : SOURCES  {
	PARENT = [ C.ActiveTarget $(PARENT) ] ;
	
	local bundlePath = [ ios.GetBundlePath ] ;
	if ! $(bundlePath)
	{
		Echo *** XIB $(PARENT) \: $(SOURCES) ;
		Exit *** Bundle path not setup for target $(TARGET) ;
	}


	SOURCES = $(SOURCES:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
	SEARCH on $(SOURCES) += $(SEARCH_SOURCE) ;
	
	local targets = $(SOURCES:S=.nib) ;
	
	MakeLocate $(targets) : $(bundlePath) ;
	Clean $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(targets) ;	
	
	Depends $(C.ACTIVE_TOOLCHAIN_TARGET) : $(targets) ;

	local source ;
	for source in $(SOURCES) {
		local target = $(source:S=.nib) ;
		Depends $(target) : $(source) ;
	
		ios.CompileXIB $(target) : $(source) : $(C.COMPILER_SUITE_SYMBOL) ;
	}
}


	#/Developer/usr/bin/ibtool --errors --warnings --notices --output-format human-readable-text --compile $(1:C) $(2:C)
actions ios.CompileXIB
{
	PATH=$(MACOSX_SDK_DEVELOPER_ROOT)/usr/bin:$PATH
	/Applications/Xcode.app/Contents/Developer/usr/bin/ibtool --errors --warnings --notices --output-format human-readable-text --compile $(1:C) $(2:C)
}


rule ios.Storyboard TARGET : SOURCES {
    TARGET = [ ActiveTarget $(TARGET) ] ;

    local bundleTarget = [ ios.GetBundleTarget ] ;
    if ! $(bundleTarget)
    {
        Echo *** ios.Storyboard $(TARGET) \: $(SOURCES) ;
        Exit *** Bundle target not setup for target $(TARGET) ;
    }

    local bundlePath = [ ios.GetBundlePath ] ;
    if ! $(bundlePath)
    {
        Echo *** ios.Storyboard $(TARGET) \: $(SOURCES) ;
        Exit *** Bundle path not setup for target $(TARGET) ;
    }

    SOURCES = $(SOURCES:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
    SEARCH on $(SOURCES) += $(SEARCH_SOURCE) ;

    local LANGUAGE_SUBDIRECTORY = $(SOURCES[1]:TD) ;
    LANGUAGE_SUBDIRECTORY = $(LANGUAGE_SUBDIRECTORY:BS) ;

    local intermediateDirectory = $(LOCATE_TARGET)/$(LANGUAGE_SUBDIRECTORY) ;

    local finalTargets ;
    local storyboardsToLink ;
    local source ;
    for source in $(SOURCES) {
        local compileTarget = @(Info.plist:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)|$(source:BS)) ;
        Depends $(bundleTarget) : $(compileTarget) : $(source) ;
        local compileIntermediateDirectory = $(intermediateDirectory)/$(source:BS)c ;
        MakeLocate $(compileTarget) : $(compileIntermediateDirectory) ;
        CleanTree $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(compileIntermediateDirectory) ;
        storyboardsToLink += $(compileTarget) ;

        local finalTargetOutputDirectory ;
        if $(LANGUAGE_SUBDIRECTORY:S) = .lproj {
            finalTargetOutputDirectory = $(bundlePath)/$(LANGUAGE_SUBDIRECTORY)/$(source:BS)c ;
        } else {
            finalTargetOutputDirectory = $(bundlePath)/$(source:BS)c ;
        }
        local finalTarget = @(Info.plist:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)|final|$(source:BS)) ;
        Depends $(bundleTarget) : $(finalTarget) : $(compileTarget) ;
        MakeLocate $(finalTarget) : $(finalTargetOutputDirectory) ;
        CleanTree $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(finalTargetOutputDirectory) ;
        finalTargets += $(finalTarget) ;

        local partialInfo.plist = $(LOCATE_TARGET)/$(source:B)-SBPartialInfo.plist ;
        Clean $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(partialInfo.plist) ;

        TARGET on $(compileTarget) = $(TARGET) ;
        OUTPUT_PARTIAL_INFO_PLIST on $(compileTarget) = $(partialInfo.plist) ;
        OUTPUT_DIRECTORY on $(compileTarget) = $(intermediateDirectory) ;
        ios._CompileStoryboard $(compileTarget) : $(source) : $(C.COMPILER_SUITE_SYMBOL) ;
    }

    TARGET on $(finalTargets) = $(TARGET) ;
    BUNDLE_DIRECTORY on $(finalTargets) = $(bundlePath) ;
    ios._LinkStoryboards $(finalTargets) : $(storyboardsToLink) ;
}


if $(NT) {

actions ios._CompileStoryboard
{
	rmdir /s/q $(OUTPUT_DIRECTORY:C\\)\\$(2:BS)c
	copy $(2:C\\) $(OUTPUT_DIRECTORY:C\\)
	$(IBTOOL:C) -compile $(OUTPUT_DIRECTORY)/$(2:D=)
}


actions ios._LinkStoryboards
{
	rem rmdir /s/q $(1:DC\\)
	xcopy $(2:DC\\)\*.* $(1:DC\\)\*.* /s/e/Y
}

} else {

actions ios._CompileStoryboard
{
	PATH=$(MACOSX_SDK_DEVELOPER_ROOT)/usr/bin:$PATH
	/Applications/Xcode.app/Contents/Developer/usr/bin/ibtool --errors --warnings --notices --module $(TARGET) --output-partial-info-plist $(OUTPUT_PARTIAL_INFO_PLIST) --auto-activate-custom-fonts --target-device iphone --target-device ipad --minimum-deployment-target 10.2 --output-format human-readable-text --compilation-directory $(OUTPUT_DIRECTORY) $(2:C)
}


actions ios._LinkStoryboards
{
	PATH=$(MACOSX_SDK_DEVELOPER_ROOT)/usr/bin:$PATH
	/Applications/Xcode.app/Contents/Developer/usr/bin/ibtool --errors --warnings --notices --module $(TARGET) --target-device iphone --target-device ipad --minimum-deployment-target 10.2 --output-format human-readable-text --link $(BUNDLE_DIRECTORY) $(2:CD)
}

}


rule ios.Storyboards TARGET : LANGUAGE_DIRECTORY : STORYBOARD_FILES {
    LANGUAGE_DIRECTORY = $(LANGUAGE_DIRECTORY:R=$(SUBDIR)) ;
    local storyboards = [ Glob $(LANGUAGE_DIRECTORY) : *.storyboard ] ;
    storyboards = $(storyboards:BSG=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
    SEARCH on $(storyboards) = $(LANGUAGE_DIRECTORY) ;
    ios.Storyboard $(TARGET) : $(storyboards) ;

    if $(STORYBOARD_FILES[1]) {
        ios.BundleInfoString : UILaunchStoryboardName : $(STORYBOARD_FILES[1]) ;
    }
    if $(STORYBOARD_FILES[2]) {
        ios.BundleInfoString : UIMainStoryboardFile : $(STORYBOARD_FILES[2]) ;
    }
}





if $(NT) {
    actions ios._ImageCopy {
        copy $(2:C\\) $(1:C\\)
    }

    actions ios._ImageResize {
        $(IMCONVERT:C) $(2:C) -quiet -resize $(IMAGE_SIZE) $(1:C)
    }

    actions ios._CompileAssetCatalog {
        $(ACTOOL:C) -idioms ipad,iphone -compile $(SOURCE_PATH) -out $(1[1]:D)\Assets.car
    }
} else {
    actions ios._CompileAssetCatalog {
        $(ACTOOL:C) --output-format human-readable-text --output-partial-info-plist $(OUTPUT_PARTIAL_INFO_PLIST) --notices --warnings $(APP_ICON) $(LAUNCH_IMAGE) --compress-pngs --enable-on-demand-resources YES --sticker-pack-identifier-prefix .sticker-pack. --target-device iphone --target-device ipad --minimum-deployment-target 6.0 --platform iphoneos --product-type com.apple.product-type.application --compile $(1[1]:D) $(SOURCE_PATH)
    }
}


rule ios.AssetCatalog PARENT : ASSET_CATALOG_PATH : APP_ICON_NAME : LAUNCH_IMAGE_NAME : DESTINATION_PATH {
    ASSET_CATALOG_PATH = $(ASSET_CATALOG_PATH:R=$(SUBDIR)) ;

    local target = [ ios.GetBundleTarget ] ;
    local cleanTarget = $(CLEAN_BUNDLE_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
    local bundlePath = [ ios.GetBundlePath ] ;
    if ! $(DESTINATION_PATH) {
        DESTINATION_PATH = $(bundlePath) ;
    }
    ASSET_CATALOG_PATH = $(ASSET_CATALOG_PATH:R=$(SUBDIR)) ;

    local COLON = ":" ;
    local code = "
        local ospath = require 'ospath'
        local filefind = require 'filefind'

        local parent = jam_getvar('target')[1]
        local targetGrist = jam_getvar('C.ACTIVE_TOOLCHAIN_TARGET_GRIST')[1]
        targetGrist = targetGrist .. '|assetcatalog'
        local assetCatalogPath = jam_getvar('ASSET_CATALOG_PATH')[1]
        local destinationPath = jam_getvar('DESTINATION_PATH')[1]
        local cleanTarget = jam_getvar('cleanTarget')[1]

        local destinationTargets = {}
        local sourceTargets = {}

        local appIcon = ''
        local launchImage = ''
        local NT = jam_getvar('NT')[1]

        local appIcons = {}
        local launchImages = {}

        local at = '@'
        local dollar = '$'
" ;

    code += "
        for directoryEntry in filefind.match(ospath.join(assetCatalogPath, '*.*')) do repeat
            if not directoryEntry.is_directory then break end

            local extension = ospath.get_extension(directoryEntry.filename)
            if extension == '.appiconset' then
                appIcon = ospath.remove_extension(ospath.get_filename(directoryEntry.filename))
                local sourcePath = ospath.join(assetCatalogPath, directoryEntry.filename)
                local contentsJsonFilename = ospath.join(sourcePath, 'Contents.json')
                local contents = require 'rapidjson'.decode(ospath.read_file(contentsJsonFilename))

                for _, entry in ipairs(contents.images) do repeat
                    if not entry.filename then break end

                    local filename = appIcon .. entry.size
                    local scale = 1
                    if entry.scale  and  entry.scale ~= '1x' then
                        filename = filename .. '@' .. entry.scale
                        scale = tonumber(entry.scale:match('(%d+)x'))
                    end
                    if entry.idiom  and  entry.idiom ~= 'iphone' then
                        filename = filename .. '~' .. entry.idiom
                    end
                    filename = filename .. '.png'

                    local inputTarget = '<' .. targetGrist .. ':source>' .. entry.filename
                    local outputTarget = '<' .. targetGrist .. '>' .. filename
                    jam_setvar(inputTarget, 'SEARCH', sourcePath)
                    --jam_evaluaterule('MakeLocate', outputTarget, destinationPath)
                    --jam_evaluaterule('Depends', parent, outputTarget, inputTarget)
                    --jam_evaluaterule('Clean', cleanTarget, outputTarget)

                    if false then
                        local width, height = entry.size:match('(%d+)x(%d+)')
                        jam_setvar(outputTarget, 'IMAGE_SIZE', (width * scale) .. 'x' .. (height * scale))
                        jam_evaluaterule('ios._ImageResize', outputTarget, inputTarget, jam_getvar('C.COMPILER_SUITE_SYMBOL'))
                    else
                        destinationTargets[#destinationTargets + 1] = outputTarget
                        sourceTargets[#sourceTargets + 1] = inputTarget
                    end

                    local textToExpand = at .. '(' .. outputTarget:gsub(':', dollar .. '(COLON)') .. ':BS)'
                    appIcons[#appIcons + 1] = jam_expand(textToExpand)[1]
                until true end
" ;

    code += "
            elseif extension == '.imageset' then
                local imageset = ospath.remove_extension(ospath.get_filename(directoryEntry.filename))
                local sourcePath = ospath.join(assetCatalogPath, directoryEntry.filename)
                local contentsJsonFilename = ospath.join(sourcePath, 'Contents.json')
                local contents = require 'rapidjson'.decode(ospath.read_file(contentsJsonFilename))

                local activeFilenames = {}
                local function MakeFilename(entry, build)
                    local filename = imageset

                    if entry.scale  and  entry.scale ~= '1x' then
                        filename = filename .. '@' .. entry.scale
                    end

--                    if entry.idiom  and  entry.idiom ~= 'iphone' then
--                        filename = filename .. '~' .. entry.idiom
--                    end

                    if build then
                        activeFilenames[filename] = true
                    end

                    return filename
                end

                for _, entry in ipairs(contents.images) do
                    MakeFilename(entry, true)
                end

                for _, entry in ipairs(contents.images) do repeat
                    if not entry.filename then break end
                    local filename = MakeFilename(entry)
                    if not filename then break end
                    filename = filename .. '.png'

                    local inputTarget = '<' .. targetGrist .. ':source>' .. entry.filename
                    local outputTarget = '<' .. targetGrist .. '>' .. filename
                    jam_setvar(inputTarget, 'SEARCH', sourcePath)
                    --jam_evaluaterule('MakeLocate', outputTarget, destinationPath)
                    --jam_evaluaterule('Depends', parent, outputTarget, inputTarget)
                    --jam_evaluaterule('Clean', cleanTarget, outputTarget)

                    if false then
                        jam_setvar(outputTarget, 'IMAGE_SIZE', entry.size)
                        jam_evaluaterule('ios._ImageCopy', outputTarget, inputTarget, jam_getvar('C.COMPILER_SUITE_SYMBOL'))
                    else
                        destinationTargets[#destinationTargets + 1] = outputTarget
                        sourceTargets[#sourceTargets + 1] = inputTarget
                    end

--                    local textToExpand = at .. '(' .. outputTarget:gsub(':', dollar .. '(COLON)') .. ':B)'
--                    launchImages[#launchImages + 1] = {
--                        osVersion = entry['minimum-system-version'],
--                        fileTitle = jam_expand(textToExpand)[1],
--                        orientation = entry.orientation,
--    --                    imageSize = '{' .. entry.size .. '}',
--                    }
                until true end

            elseif extension == '.launchimage' then
                launchImage = ospath.remove_extension(ospath.get_filename(directoryEntry.filename))
                local sourcePath = ospath.join(assetCatalogPath, directoryEntry.filename)
                local contentsJsonFilename = ospath.join(sourcePath, 'Contents.json')
                local contents = require 'rapidjson'.decode(ospath.read_file(contentsJsonFilename))

                local activeFilenames = {}
                local function MakeLaunchImageFilename(entry, build)
                    local filename = launchImage
                    local minimumSystemVersion = entry['minimum-system-version']
                    if minimumSystemVersion == '7.0' then
                        filename = filename .. '-700'
                    elseif minimumSystemVersion == '8.0' then
                        filename = filename .. '-800'
                    elseif minimumSystemVersion == '11.0' then
                        filename = filename .. '-1100'
                    end

                    if entry.orientation == 'portrait' then
                        if not build then
                            entry.orientation = 'landscape'
                            local alternateFilename = MakeLaunchImageFilename(entry)
                            if activeFilenames[alternateFilename] then
                                filename = filename .. '-Portrait'
                            end
                            entry.orientation = 'portrait'
                        else
                            filename = filename .. '-Portrait'
                        end
                    elseif entry.orientation == 'landscape' then
                        filename = filename .. '-Landscape'
                    end

                    if entry.subtype then
                        if entry.subtype == 'retina4' then
                            filename = filename .. '-568h'
                        else
                            filename = filename .. '-' .. entry.subtype
                        end
                    end

                    if entry.scale  and  entry.scale ~= '1x' then
                        filename = filename .. '@' .. entry.scale
                    end

                    if entry.idiom  and  entry.idiom ~= 'iphone' then
                        filename = filename .. '~' .. entry.idiom
                    end

                    if build then
                        activeFilenames[filename] = true
                    end

                    return filename
                end

                for _, entry in ipairs(contents.images) do
                    MakeLaunchImageFilename(entry, true)
                end

                for _, entry in ipairs(contents.images) do repeat
                    if not entry.filename then break end
                    local filename = MakeLaunchImageFilename(entry)
                    if not filename then break end
                    filename = filename .. '.png'

                    local inputTarget = '<' .. targetGrist .. ':source>' .. entry.filename
                    local outputTarget = '<' .. targetGrist .. '>' .. filename
                    jam_setvar(inputTarget, 'SEARCH', sourcePath)
                    --jam_evaluaterule('MakeLocate', outputTarget, destinationPath)
                    --jam_evaluaterule('Depends', parent, outputTarget, inputTarget)
                    --jam_evaluaterule('Clean', cleanTarget, outputTarget)

                    if false then
                        jam_setvar(outputTarget, 'IMAGE_SIZE', entry.size)
                        jam_evaluaterule('ios._ImageCopy', outputTarget, inputTarget, jam_getvar('C.COMPILER_SUITE_SYMBOL'))
                    else
                        destinationTargets[#destinationTargets + 1] = outputTarget
                        sourceTargets[#sourceTargets + 1] = inputTarget
                    end

                    local textToExpand = at .. '(' .. outputTarget:gsub(':', dollar .. '(COLON)') .. ':B)'
                    launchImages[#launchImages + 1] = {
                        osVersion = entry['minimum-system-version'],
                        fileTitle = jam_expand(textToExpand)[1],
                        orientation = entry.orientation,
    --                    imageSize = '{' .. entry.size .. '}',
                    }
                until true end
            end
        until true end

        if true then
            local generatedInfoPlist = jam_getvar('LOCATE_TARGET')[1] .. '/assetcatalog_generated_info.plist'
            jam_evaluaterule('Clean', cleanTarget, generatedInfoPlist)

            local outputTarget = '<' .. targetGrist .. '>Assets.car'
            jam_evaluaterule('MakeLocate', outputTarget, destinationPath)
            jam_evaluaterule('Clean', cleanTarget, outputTarget)

            destinationTargets = { outputTarget }
            for _, target in ipairs(destinationTargets) do
                if appIcon ~= '' then
                    jam_setvar(target, 'APP_ICON',  '--app-icon ' .. appIcon)
                end
                if launchImage ~= '' then
                    jam_setvar(target, 'LAUNCH_IMAGE',  '--launch-image ' .. launchImage)
                end
                jam_setvar(target, 'SOURCE_PATH',  assetCatalogPath)
                jam_setvar(target, 'OUTPUT_PARTIAL_INFO_PLIST', generatedInfoPlist)
            end
            jam_evaluaterule('Depends', parent, destinationTargets, sourceTargets)
            jam_evaluaterule('ios._CompileAssetCatalog', destinationTargets, sourceTargets, jam_getvar('C.COMPILER_SUITE_SYMBOL')[1])
        end

        if appIcons[1] then
            local dict = GetInfoPlistCurrentLevel()
            dict.CFBundleIconFiles = appIcons
        end

        if false  and  launchImages[1] then
            jam_evaluaterule('ios.BundleInfoArrayBegin', 'UILaunchImages')

            for _, launchImageInfo in ipairs(launchImages) do
                jam_evaluaterule('ios.BundleInfoArrayDictBegin')
                    jam_evaluaterule('ios.BundleInfoString', 'UILaunchImageMinimumOSVersion', launchImageInfo.osVersion)
                    jam_evaluaterule('ios.BundleInfoString', 'UILaunchImageName', launchImageInfo.fileTitle)
                    jam_evaluaterule('ios.BundleInfoString', 'UILaunchImageOrientation', launchImageInfo.orientation)
                    jam_evaluaterule('ios.BundleInfoString', 'UILaunchImageSize', launchImageInfo.imageSize)
                jam_evaluaterule('ios.BundleInfoArrayDictEnd')
            end

            jam_evaluaterule('ios.BundleInfoArrayEnd')
        end
" ;

    LuaString $(code:J) ;
}


rule ios.Provision TARGET : PROFILE_ID {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	local _matchingProvision ;

	# See if provided provision is a filename that exists.
	local _profileDir = $(PROFILE_ID:P/) ;
	local _profileFilename = $(PROFILE_ID:BS/G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
	
	if $(_profileDir) && $(_profileDir) != "" && $(_profileFilename) && $(_profileFilename) != ""
	{
		SEARCH on $(_profileFilename) = $(_profileDir) ;
		if $(_profileFilename:TC/) != $(PROFILE_ID:BSTC/)
		{
			_matchingProvision = $(_profileFilename) ;
		}
	}

	local _systemProfileDirectory ;
	if ! $(_matchingProvision)
	{
		if $(NT)
		{
			_systemProfileDirectory = "$(IOSBUILDENV_PATH)/Keychain" ;
		}
		else
		{
			_systemProfileDirectory = "$(HOME)/Library/MobileDevice/Provisioning Profiles" ;
		}

		SEARCH on $(_profileFilename) = $(_systemProfileDirectory) ;
		if $(_profileFilename:TC/) != $(PROFILE_ID:BSTC/)
		{
			_matchingProvision = $(_profileFilename) ;
		}
	}

	if ! $(_matchingProvision)
	{
		local _mobileProvisions = [ Glob $(_systemProfileDirectory) : *.mobileprovision ] ;

		local _mobileProvision ;
		local AppIdentifierPrefix ;
		local CFBundleIdentifier ;
		local TeamIdentifier ;
		for _mobileProvision in $(_mobileProvisions) {
			LuaString "
				local plist = require 'plist'
				local pl = plist.read(jam_getvar('_mobileProvision')[1])
				local prefix = pl.ApplicationIdentifierPrefix
				jam_setvar('AppIdentifierPrefix', prefix)
				local identifier = pl.Entitlements[\"application-identifier\"]
				identifier = identifier:sub(#prefix[1] + 2)
				jam_setvar('CFBundleIdentifier', identifier)
				local identifier = pl.Entitlements[\"com.apple.developer.team-identifier\"]
				jam_setvar('TeamIdentifier', identifier)
			" ;

			if $(CFBundleIdentifier[1]) = $(PROFILE_ID) {
				_matchingProvision = $(_mobileProvision) ;
				break ;
			}
		}
	}

	if ! $(_matchingProvision) {
		Exit *** No mobile provisions found that match PROFILE_ID \: $(PROFILE_ID) ;
	}

	local _provisionFileTarget = $(_matchingProvision:BS/G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
	SEARCH on $(_provisionFileTarget) = $(_matchingProvision:D) ;
	PROVISION_FILE_TARGET on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(_provisionFileTarget) ;

	_provisionFileTarget = $(_provisionFileTarget:T) ;

	local bundleIdentifier ;
	local teamIdentifier ;
	local provisioningProfileSpecifier ;
	LuaString "
		local pl = require 'plist'.read(jam_getvar('_provisionFileTarget')[1])
		local prefix = pl.ApplicationIdentifierPrefix
		local identifier = pl.Entitlements[\"application-identifier\"]
		identifier = identifier:sub(#prefix[1] + 2)
		jam_setvar('bundleIdentifier', identifier)

		local identifier = pl.Entitlements[\"com.apple.developer.team-identifier\"]
		jam_setvar('teamIdentifier', identifier)

		local name = pl.Name
		jam_setvar('provisioningProfileSpecifier', name)
	" ;
	if $(bundleIdentifier) != * {
		ios.BundleInfoString $(TARGET) : CFBundleIdentifier : $(bundleIdentifier) ;
		CFBundleIdentifier on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(bundleIdentifier) ;

		if $(TARGETINFO_LOCATE) {
			Contents += "Projects[ [[$(TARGET)]] ].PRODUCT_BUNDLE_IDENTIFIER[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(bundleIdentifier)]]
" ;
			Contents += "Projects[ [[$(TARGET)]] ].PROVISIONING_PROFILE_SPECIFIER[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(provisioningProfileSpecifier)]]
" ;
		}
	}
	if $(teamIdentifier) {
		if $(TARGETINFO_LOCATE) {
			Contents += "Projects[ [[$(TARGET)]] ].TEAM_IDENTIFIER[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(teamIdentifier)]]
" ;
		}
	}
}


if $(NT) {

actions ios._CodeSign
{
    "$(IOSBUILDENV_PATH)/Toolchain/ldid" -k"$(IOSBUILDENV_PATH)/Keychain" -S"$(CERTIFICATE_CHAIN)" -E"$(ENTITLEMENTS:TE=)" $(1[2]:CT)
    copy /B $(1[2]:CT\\)+,, $(1[2]:CT\\) > nul
    copy /B $(1[1]:C\\)+,, $(1[1]:CT\\) > nul
}

actions ios._CodeSignFramework
{
    "$(IOSBUILDENV_PATH)/Toolchain/ldid" -k"$(IOSBUILDENV_PATH)/Keychain" -S"$(CERTIFICATE_CHAIN)" $(1[2]:CT)
    copy /B $(1[2]:CT\\)+,, $(1[2]:CT\\) > nul
    copy /B $(1[1]:C\\)+,, $(1[1]:CT\\) > nul
}

} else {

actions ios._CodeSign
{
	export CODESIGN_ALLOCATE=$(COMPILER_BIN_PATH_SECONDARY)/codesign_allocate
	/usr/bin/codesign --force --no-strict --sign "$(SIGNING_IDENTITY)" --entitlements $(ENTITLEMENTS:CT) --timestamp=none $(BUNDLE_PATH)
	touch $(1[1]:C)
	touch $(DSYM_NAME:CT)
}

actions ios._CodeSignFramework
{
	export CODESIGN_ALLOCATE=$(COMPILER_BIN_PATH_SECONDARY)/codesign_allocate
	/usr/bin/codesign --force --sign "$(SIGNING_IDENTITY)" --preserve-metadata=identifier,entitlements $(FRAMEWORK_PATH)
	touch $(1[1]:C)
}

}


rule ios.CodeSign TARGET : SIGNING_IDENTITY : CERTIFICATE_CHAIN {
	ActiveTarget $(TARGET) ;

	if $(C.PLATFORM) in ios {
		if $(CERTIFICATE_CHAIN) {
			CERTIFICATE_CHAIN on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(CERTIFICATE_CHAIN) ;
		} else {
			CERTIFICATE_CHAIN on $(C.ACTIVE_TOOLCHAIN_TARGET) = "::" ;
		}
		SIGNING_IDENTITY on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(SIGNING_IDENTITY) ;
	}
}


rule ios.CodeSignAutomatic TARGET {
	TARGET = [ ActiveTarget $(TARGET) ] ;
}


rule ios.Archive TARGET : OUTPUT_PATH : ITUNES_ARTWORK : OPTIONS {
	# Set up the archive support.
	if $(C.PLATFORM) in ios {
		TARGET = [ ActiveTarget $(TARGET) ] ;

		local bundlePath = [ ios.GetBundlePath ] ;
		local bundleTarget = [ ios.GetBundleTarget ] ;
		local bundleTargetDependsList = [ DependsList $(bundleTarget) ] ;

		local archiveTarget = archive:$(TARGET) ;
		NotFile $(archiveTarget) ;

		local ipaTarget = @($(bundlePath:D=:S=).ipa:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
		OUTPUT_PATH ?= $(LOCATE_TARGET) ;
		MakeLocate $(ipaTarget) : $(OUTPUT_PATH) ;

		if $(ITUNES_ARTWORK) {
			local itunesArtworkDirectory = $(ITUNES_ARTWORK:D) ;
			ITUNES_ARTWORK = $(ITUNES_ARTWORK:BSG=$(C.ACTIVE_TOOLCHAIN_GRIST)) ;
			Search on $(ITUNES_ARTWORK) = $(itunesArtworkDirectory:E=$(SUBDIR)) ;
			Depends $(archiveTarget) : $(ipaTarget) : $(ITUNES_ARTWORK) ;
		}
		Depends $(archiveTarget) : $(ipaTarget) : $(bundleTarget) ;
		Clean $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(ipaTarget) ;
		BUNDLE_PATH on $(ipaTarget) = $(bundlePath) ;
		SIGNING_IDENTITY on $(ipaTarget) = $(SIGNING_IDENTITY:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
		ITUNES_ARTWORK on $(ipaTarget) = $(ITUNES_ARTWORK) ;
		ios._Archive $(ipaTarget) : $(bundleTargetDependsList) $(ITUNES_ARTWORK) : $(C.COMPILER_SUITE_SYMBOL) ;

		if $(NT) {
			# Set up an install target.
			Depends install:$(TARGET) : $(ipaTarget) ;
			Always install:$(TARGET) ;
			NotFile install:$(TARGET) ;
			IPA_TARGET on install:$(TARGET) = $(ipaTarget) ;
			ios._Install install:$(TARGET) : $(ipaTarget) : $(C.COMPILER_SUITE_SYMBOL) ;

			# Set up an auto-install if requested.
			if install in $(OPTIONS) {
				Depends autoinstall:$(TARGET) : $(ipaTarget) ;
				NotFile autoinstall:$(TARGET) ;
				IPA_TARGET on autoinstall:$(TARGET) = $(ipaTarget) ;
				ios._Install autoinstall:$(TARGET) : $(ipaTarget) : $(C.COMPILER_SUITE_SYMBOL) ;
				Depends $(TARGET) : autoinstall:$(TARGET) ;
			}

			# Set up an uninstall target.
			Always uninstall:$(TARGET) ;
			NotFile uninstall:$(TARGET) ;
			APPID on uninstall:$(TARGET) = $(CFBundleIdentifier:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
			ios._Uninstall uninstall:$(TARGET) : : $(C.COMPILER_SUITE_SYMBOL) ;

			# Set up a run target.
			Depends run:$(TARGET) : install:$(TARGET) ;
			Always run:$(TARGET) ;
			NotFile run:$(TARGET) ;
			APPID on run:$(TARGET) = $(CFBundleIdentifier:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
			ios._Run run:$(TARGET) : : $(C.COMPILER_SUITE_SYMBOL) ;

			# Set up an auto-run if requested.
			if run in $(OPTIONS) {
				Depends autorun:$(TARGET) : install:$(TARGET) ;
				NotFile autorun:$(TARGET) ;
				APPID on autorun:$(TARGET) = $(CFBundleIdentifier:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
				ios._Run autorun:$(TARGET) : : $(C.COMPILER_SUITE_SYMBOL) ;
				Depends $(TARGET) : autorun:$(TARGET) ;
			}
		}

		# Set up the webserver.
		if webserver in $(OPTIONS) {
			ios.WebServer ;
		}
	}
}


actions screenoutput ios._Install {
	"$(JAM_EXECUTABLE_PATH:D)/libimobiledevice/ideviceinstaller" -i $(IPA_TARGET:TC)
}


actions screenoutput ios._Uninstall {
	"$(JAM_EXECUTABLE_PATH:D)/libimobiledevice/ideviceinstaller" -U $(APPID)
}


actions screenoutput ios._Run {
	"$(JAM_EXECUTABLE_PATH:D)/libimobiledevice/idevicedebug" run $(APPID)
}


rule ios.WebServer TARGET {
	# Set up the archive support.
	if $(C.PLATFORM) in ios {
		TARGET = [ ActiveTarget $(TARGET) ] ;

		local bundlePath = [ ios.GetBundlePath ] ;
		local ipaTarget = @($(bundlePath:D=:S=).ipa:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
		local OUTPUT_PATH = $(LOCATE:Z=$(ipaTarget)) ;

		local archiveTarget = archive:$(TARGET) ;
		OUTPUT_PATH on $(archiveTarget) = $(OUTPUT_PATH) ;

		local IP ;
		if ! $(URL) {
			if $(NT) {
				IP = [ Match ([^$(CRLF)]*) : [ Shell "FOR /F \"tokens=4 delims= \" %%i in ('route print ^| find \" 0.0.0.0\"') do @echo %%i" ] ] ;
			} else {
				# https://stackoverflow.com/questions/13322485/how-to-get-the-primary-ip-address-of-the-local-machine-on-linux-and-os-x
				IP = [ Match ([^$(NEWLINE)]*) : [ Shell "ifconfig | sed -En 's/127.0.0.1//;s/.*inet (addr:)?(([0-9]*\\.){3}[0-9]*).*/\\2/p'" ] ] ;
			}
			IP = $(IP[1]) ;
			URL = https://$(IP):9999 ;
		}
		if $(URL) {
			# Stolen from BetaBuilder:

			# Write manifest.plist.
			local manifest.plist = @(manifest.plist:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST):archive) ;
			MakeLocate $(manifest.plist) : $(OUTPUT_PATH) ;
			Depends $(archiveTarget) : $(manifest.plist) : $(ipaTarget) ;
			Clean $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(manifest.plist) ;
			local contents ;
			on $(C.ACTIVE_TOOLCHAIN_TARGET) contents =
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">
<plist version=\"1.0\">
<dict>
	<key>items</key>
	<array>
		<dict>
			<key>assets</key>
			<array>
				<dict>
					<key>kind</key>
					<string>software-package</string>
					<key>url</key>
					<string>$(URL)/$(ipaTarget:D=:G=)</string>
				</dict>
			</array>
			<key>metadata</key>
			<dict>
				<key>bundle-identifier</key>
				<string>$(CFBundleIdentifier)</string>
				<key>bundle-version</key>
				<string>$(CFBundleVersion)</string>
				<key>kind</key>
				<string>software</string>
				<key>title</key>
				<string>$(CFBundleDisplayName)</string>
			</dict>
		</dict>
	</array>
</dict>
</plist>
" ;
			CONTENTS on $(manifest.plist) = $(contents) ;
			Always $(manifest.plist) ;
			WriteFile $(manifest.plist) ;
			UseCommandLine $(manifest.plist) : $(contents) ;

			local minimumsdkversion = $(IOS_SDK_VERSION_MIN:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
			minimumsdkversion ?= $(IOS_SDK_VERSION_MIN:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

			local index.html = @(index.html:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST):archive) ;
			MakeLocate $(index.html) : $(OUTPUT_PATH) ;
			Depends $(archiveTarget) : $(index.html) : $(manifest.plist) ;
			Clean $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(index.html) ;
			local contents ;
			on $(C.ACTIVE_TOOLCHAIN_TARGET) contents = "
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> <html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
<title>$(CFBundleDisplayName)</title>
<style type="text/css">
body {background:#fff;margin:0;padding:0;font-family:arial,helvetica,sans-serif;text-align:center;padding:10px;color:#333;font-size:16px;}
#container {width:300px;margin:0 auto;}
h1 {margin:0;padding:0;font-size:14px;}
p {font-size:13px;}
.link {background:#ecf5ff;border-top:1px solid #fff;border:1px solid #dfebf8;margin-top:.5em;padding:.3em;}
.link a {text-decoration:none;font-size:15px;display:block;color:#069;}

</style>
</head>
<body>

<div id="container">

<h1>iOS $(minimumsdkversion:E=4.0)+ Users:</h1>

<div class="link"><a href="itms-services://?action=download-manifest&url=$(URL)/manifest.plist">Tap Here to Install<br />$(CFBundleDisplayName)<br />On Your Device</a></div>

<p><strong>Link didn't work?</strong><br />
Make sure you're visiting this page on your device, not your computer.</p>

</div>

<h3><strong>Troubleshooting:</strong></h3>

<p>If your iOS device pops up a dialog stating &quot;Cannot connect to $(IP:E="")&quot;, <a href="jamplusCA.cer">install the JamPlus Certificate Authority certificate</a>.</p>

</body>
</html>
" ;
			CONTENTS on $(index.html) = $(contents) ;
			Always $(index.html) ;
			WriteFile $(index.html) ;
			UseCommandLine $(index.html) : $(contents) ;

			ios._WebServer $(archiveTarget) ;
		}
	}
}


actions screenoutput ios._WebServer {
	$(JAM_EXECUTABLE_PATH:C) --webserver -ssl $(OUTPUT_PATH:C)
}

#if $(NT) {
if 1 {


actions lua ios._Archive
{
	local ospath = require 'ospath'
	local filefind = require 'filefind'
	local filelist = {}
	local bundlePath = ospath.remove_slash([[$(BUNDLE_PATH)]])
	local bundleName = ospath.get_filename(bundlePath)
	for entry in filefind.glob(bundlePath .. '/**') do
		filelist[#filelist + 1] = {
			EntryName = 'Payload/' .. bundleName .. '/' .. entry.filename:sub(#bundlePath + 2),
			SourcePath = entry.filename,
		}
	end
	local itunesArtwork = [[$(ITUNES_ARTWORK:T:E=)]]
	if itunesArtwork ~= '' then
		filelist[#filelist + 1] = { EntryName = 'iTunesArtwork', SourcePath = itunesArtwork }
	end

	local ziparchive = require 'ziparchive'
	local archive = ziparchive.open([[$(1)]], 'a')
	archive:processfilelist(filelist)
	archive:close()
	ospath.touch([[$(1)]])
}

} else {

actions ios._Archive
{
	export CODESIGN_ALLOCATE=$(COMPILER_BIN_PATH)/codesign_allocate
	/usr/bin/xcrun -sdk iphoneos PackageApplication -v "$(BUNDLE_PATH)" -o "$(1)" --sign "$(SIGNING_IDENTITY)" --embed "$(BUNDLE_PATH)/embedded.mobileprovision"
}

}


} # TARGETINFO_LOCATE


rule ios.CopyFilesToBundle TARGET : SOURCE_PATHS {
	C.ActiveTarget $(TARGET) ;

	local bundlePath = $(BUNDLE_PATH:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	local bundleTarget = $(BUNDLE_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;

	if ! $(TARGETINFO_LOCATE) {
		local source ;
		for source in $(SOURCE_PATHS) {
			CopyFile $(bundleTarget) : $(bundlePath)/$(source:D=) : $(source) ;
		}
	} else {
		local prefix = "Projects[ [[$(C.ACTIVE_TARGET)]] ]" ;
		Contents += "$(prefix).Sources = concat($(prefix).Sources, {$(NEWLINE)" ;
			Contents += "$(TAB)[[$(SOURCE_PATHS:T)]],$(NEWLINE)" ;
		Contents += "})$(NEWLINE)" ;

		local source ;
		for source in $(SOURCE_PATHS) {
			local fullprefix = "$(prefix).SourcesInfo[ [[$(source:TR=$(SUBDIR))]] ]" ;
			Contents += "$(fullprefix).buildResources=true$(NEWLINE)" ;
			#Contents += "$(fullprefix).copyFiles=true$(NEWLINE)" ;
			Contents += "$(fullprefix).fileType=\"file\"$(NEWLINE)" ;
		}
	}
}

rule ios.CopyDirectoryContentsToBundle TARGET : DESTINATION_RELATIVE_PATH : SOURCE_PATHS {
	C.ActiveTarget $(TARGET) ;

	local bundlePath = $(BUNDLE_PATH:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	if $(DESTINATION_RELATIVE_PATH) {
		bundlePath = $(bundlePath)/$(DESTINATION_RELATIVE_PATH) ;
	}
	local bundleTarget = $(BUNDLE_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;

	if ! $(TARGETINFO_LOCATE) {
		local source ;
		for source in $(SOURCE_PATHS) {
			local dirs = @($(source)/*/:W) ;
			local dir ;
			for dir in $(dirs) {
				CopyDirectory $(bundleTarget) : $(bundlePath)/@($(dir:P):BS) : $(dir) : * : 1 ;
			}

			local files = @($(source)/*:W) ;
			local file ;
			for file in $(files) {
				CopyFile $(bundleTarget) : $(bundlePath)/$(file:BS) : $(file) ;
			}
		}
	} else {
#		local prefix = "Projects[ [[$(C.ACTIVE_TARGET)]] ]" ;
#		Contents += "$(prefix).Sources = concat($(prefix).Sources, {$(NEWLINE)" ;
#			Contents += "$(TAB)[[$(SOURCE_PATHS:T)]],$(NEWLINE)" ;
#		Contents += "})$(NEWLINE)" ;
#
#		local source ;
#		for source in $(SOURCE_PATHS) {
#			local fullprefix = "$(prefix).SourcesInfo[ [[$(source:TR=$(SUBDIR))]] ]" ;
#			Contents += "$(fullprefix).buildResources=true$(NEWLINE)" ;
#			Contents += "$(fullprefix).fileType=\"file\"$(NEWLINE)" ;
#		}
	}
}

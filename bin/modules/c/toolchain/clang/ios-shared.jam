rule C.Toolchain.clang.ios-shared {
}


rule C.ios.FrameworkDirectories TARGET : FRAMEWORKDIRS {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	C.Flags $(TARGET) : CC C++ M MM : -F\"$(FRAMEWORKDIRS)\" ;
	C.LinkFlags $(TARGET) : -F\"$(FRAMEWORKDIRS)\" ;
}


rule C.ios.LinkFrameworks TARGET : FRAMEWORKS : OPTIONS {
	C.ActiveTarget $(TARGET) ;
	FRAMEWORKS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(FRAMEWORKS) ;
	if public in $(OPTIONS) {
		__PUBLIC on $(C.ACTIVE_TOOLCHAIN_TARGET) = true ;
		PUBLIC_FRAMEWORKS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(FRAMEWORKS) ;
	}
}


rule C.ios.WeakLinkFrameworks TARGET : FRAMEWORKS {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	C.LinkFlags $(TARGET) : "-weak_framework $(FRAMEWORKS)" ;
}


actions C.ios.clang.Archive {
	$(C.AR:C) -static $(LIBFLAGS) -o $(<:C) -filelist ^^^($(>:J=$(NEWLINE)))
}


actions C.ios.clang.Link {
	$(C.LINK:C) $(LINKFLAGS) -o $(<[1]:C) -filelist ^^^($(>:J=$(NEWLINE))) $(NEEDLIBS:TC) $(LINKLIBS:TC)
}


if ! $(NT) {

rule C.ios.SDK SDK_VERSION {
	local SDK_PLATFORM ;
	SDK_PLATFORM ?= $(C.PLATFORM) ;

	local COMPILER_BIN_PATH = $(COMPILER_BIN_PATH:Z=$(C.COMPILER_SUITE_SYMBOL)) ;
	local developerRoot ;
	local isysroot ;
	local flags ;
	local sdkroot ;
	local architecture ;

	switch $(SDK_PLATFORM) {
		case iphone :
			developerRoot = /Developer/Platforms/iPhoneOS.platform/Developer ;
			SDK_VERSION ?= 8.1 ;
			switch $(SDK_VERSION) {
				case 4.3 :
					isysroot = $(developerRoot)/SDKs/iPhoneOS4.3.sdk ;
					architecture = armv6 ;
					sdkroot = iphoneos4.3 ;

				case 5.0 :
					isysroot = $(developerRoot)/SDKs/iPhoneOS5.0.sdk ;
					architecture = armv6 ;
					sdkroot = iphoneos5.0 ;

				case 5.1 :
					isysroot = @(../../SDKs/iPhoneOS5.1.sdk:R=$(COMPILER_BIN_PATH)) ;
					architecture = armv6 ;
					sdkroot = iphoneos5.1 ;

				case 6.0 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS6.0.sdk ;
					sdkroot = iphoneos6.0 ;
					architecture = armv7 ;

				case 6.1 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS6.1.sdk ;
					sdkroot = iphoneos6.1 ;
					architecture = armv7 ;

				case 7.0 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS7.0.sdk ;
					sdkroot = iphoneos7.0 ;
					architecture = armv7 ;

				case 7.1 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS7.1.sdk ;
					sdkroot = iphoneos7.1 ;
					architecture = armv7 ;

				case 8.0 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.0.sdk ;
					sdkroot = iphoneos8.0 ;
					architecture = armv7 ;

				case 8.1 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.1.sdk ;
					sdkroot = iphoneos8.1 ;
					architecture = armv7 ;

				case * :		Exit "* C.ios.SDK: Unsupported version $(SDK_VERSION) for SDK platform $(SDK_PLATFORM)." ;
			}
			flags += -fvisibility=hidden ;

		case iphonesimulator :
			developerRoot = /Developer/Platforms/iPhoneSimulator.platform/Developer ;
			SDK_VERSION ?= 8.1 ;
			switch $(SDK_VERSION) {
				case 4.3 :
					isysroot = $(developerRoot)/SDKs/iPhoneSimulator4.3.sdk ;
					#flags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=30200 ;
					sdkroot = iphoneos4.3 ;

				case 5.0 :
					isysroot = $(developerRoot)/SDKs/iPhoneSimulator5.0.sdk ;
					sdkroot = iphoneos5.0 ;

				case 5.1 :
					isysroot = @(../../../../Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator5.1.sdk:R=$(COMPILER_BIN_PATH)) ;
					sdkroot = iphoneos5.1 ;

				case 6.0 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator6.0.sdk ;
					sdkroot = iphoneos6.0 ;

				case 6.1 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator6.1.sdk ;
					sdkroot = iphoneos6.1 ;

				case 7.0 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator7.0.sdk ;
					sdkroot = iphoneos7.0 ;

				case 7.1 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator7.1.sdk ;
					sdkroot = iphoneos7.1 ;

				case 8.0 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.0.sdk ;
					sdkroot = iphoneos8.0 ;

				case 8.1 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.1.sdk ;
					sdkroot = iphoneos8.1 ;

				case * :		Exit "* C.ios.SDK: Unsupported version $(SDK_VERSION) for SDK platform $(SDK_PLATFORM)." ;
			}
			architecture = i386 ;

		case ipadsimulator :
			developerRoot = /Developer/Platforms/iPhoneSimulator.platform/Developer ;
			SDK_VERSION ?= 8.1 ;
			switch $(SDK_VERSION) {
				case 4.3 :
					isysroot = $(developerRoot)/SDKs/iPhoneSimulator4.3.sdk ;
					#flags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=40300 ;
					sdkroot = iphoneos4.3 ;

				case 5.0 :
					isysroot = $(developerRoot)/SDKs/iPhoneSimulator5.0.sdk ;
					sdkroot = iphoneos5.0 ;

				case 5.1 :
					isysroot = @(../../../../Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator5.1.sdk:R=$(COMPILER_BIN_PATH)) ;
					sdkroot = iphoneos5.1 ;

				case 6.0 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator6.0.sdk ;
					sdkroot = iphoneos6.0 ;

				case 6.1 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator6.1.sdk ;
					sdkroot = iphoneos6.1 ;

				case 7.0 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator7.0.sdk ;
					sdkroot = iphoneos7.0 ;

				case 7.1 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator7.1.sdk ;
					sdkroot = iphoneos7.1 ;

				case 8.0 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.0.sdk ;
					sdkroot = iphoneos8.0 ;

				case 8.1 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.0.sdk ;
					sdkroot = iphoneos8.1 ;

				case * :		Exit "* C.ios.SDK: Unsupported version $(SDK_VERSION) for SDK platform $(SDK_PLATFORM)." ;
			}
			architecture = i386 ;

		case ipad :
			developerRoot = /Developer/Platforms/iPhoneOS.platform/Developer ;
			SDK_VERSION ?= 8.1 ;
			switch $(SDK_VERSION) {
				case 4.3 :
					isysroot = $(developerRoot)/SDKs/iPhoneOS4.3.sdk ;
					sdkroot = iphoneos4.3 ;

				case 5.0 :
					isysroot = $(developerRoot)/SDKs/iPhoneOS5.0.sdk ;
					sdkroot = iphoneos5.0 ;

				case 5.1 :
					isysroot = @(../../SDKs/iPhoneOS5.1.sdk:R=$(COMPILER_BIN_PATH)) ;
					sdkroot = iphoneos5.1 ;

				case 6.0 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS6.0.sdk ;
					sdkroot = iphoneos6.0 ;

				case 6.1 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS6.1.sdk ;
					sdkroot = iphoneos6.1 ;

				case 7.0 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS7.0.sdk ;
					sdkroot = iphoneos7.0 ;

				case 7.1 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS7.1.sdk ;
					sdkroot = iphoneos7.1 ;

				case 8.0 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.0.sdk ;
					sdkroot = iphoneos8.0 ;

				case 8.1 :
					developerRoot = [ Match ([^$(NEWLINE)]*) : [ Shell "xcode-select --print-path" ] ] ;
					isysroot = $(developerRoot)/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.1.sdk ;
					sdkroot = iphoneos8.1 ;

				case * :		Exit "* C.ios.SDK: Unsupported version $(SDK_VERSION) for SDK platform $(SDK_PLATFORM)." ;
			}
			architecture = armv7 ;
	}

	C.AR on $(C.COMPILER_SUITE_SYMBOL) = $(COMPILER_BIN_PATH)/$(C.AR:BSZ=$(C.COMPILER_SUITE_SYMBOL)) ;
	C.CC on $(C.COMPILER_SUITE_SYMBOL) = $(COMPILER_BIN_PATH)/$(C.CC:BSZ=$(C.COMPILER_SUITE_SYMBOL)) ;
	C.C++ on $(C.COMPILER_SUITE_SYMBOL) = $(COMPILER_BIN_PATH)/$(C.C++:BSZ=$(C.COMPILER_SUITE_SYMBOL)) ;
	C.LINK on $(C.COMPILER_SUITE_SYMBOL) = $(COMPILER_BIN_PATH)/$(C.LINK:BSZ=$(C.COMPILER_SUITE_SYMBOL)) ;
	C.RANLIB on $(C.COMPILER_SUITE_SYMBOL) = ;

	C.ARCHITECTURE on $(C.ACTIVE_TOOLCHAIN_*) = $(C.ARCHITECTURE:E=$(architecture)) ;
	ISYSROOT on $(C.ACTIVE_TOOLCHAIN_*) = $(isysroot) ;	
	IPHONEOS_SDK_VERSION on $(C.ACTIVE_TOOLCHAIN_*) = $(SDK_VERSION) ;
	IOS_SDK_VERSION_MIN on $(C.ACTIVE_TOOLCHAIN_*) = $(SDK_VERSION) ;
	XCODE_SDKROOT on $(C.ACTIVE_TOOLCHAIN_*) = $(sdkroot) ;

	if $(TARGETINFO_LOCATE) {
		Contents += "Projects[ [[C.*]] ].XCODE_SDKROOT[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(sdkroot)]]

" ;
	}
}

} else {

rule C.ios.SDK SDK_VERSION {
	local SDK_PLATFORM ;
	SDK_PLATFORM ?= $(C.PLATFORM) ;

	local COMPILER_BIN_PATH = $(COMPILER_BIN_PATH:Z=$(C.COMPILER_SUITE_SYMBOL)) ;
	local sysroot = $(IOSBUILDENV_PATH)/SDK ;
	SDK_VERSION ?= 5.0 ;

	C.AR on $(C.COMPILER_SUITE_SYMBOL) = $(COMPILER_BIN_PATH)/$(C.AR:BSZ=$(C.COMPILER_SUITE_SYMBOL)) ;
	C.CC on $(C.COMPILER_SUITE_SYMBOL) = $(COMPILER_BIN_PATH)/$(C.CC:BSZ=$(C.COMPILER_SUITE_SYMBOL)) ;
	C.C++ on $(C.COMPILER_SUITE_SYMBOL) = $(COMPILER_BIN_PATH)/$(C.C++:BSZ=$(C.COMPILER_SUITE_SYMBOL)) ;
	C.LINK on $(C.COMPILER_SUITE_SYMBOL) = $(COMPILER_BIN_PATH)/$(C.LINK:BSZ=$(C.COMPILER_SUITE_SYMBOL)) ;
	C.RANLIB on $(C.COMPILER_SUITE_SYMBOL) = ;

	C.ARCHITECTURE on $(C.ACTIVE_TOOLCHAIN_*) = $(C.ARCHITECTURE) ;
	ISYSROOT on $(C.ACTIVE_TOOLCHAIN_*) = $(sysroot) ;
	IPHONEOS_SDK_VERSION on $(C.ACTIVE_TOOLCHAIN_*) = $(SDK_VERSION) ;
	IOS_SDK_VERSION_MIN on $(C.ACTIVE_TOOLCHAIN_*) = $(SDK_VERSION) ;
}

} # if ! $(NT)


rule C.ios.MinimumOSVersion TARGET : SDK_VERSION_MIN {
	TARGET = [ ActiveTarget $(TARGET) ] ;

	local SDK_PLATFORM ;
	SDK_PLATFORM ?= $(C.PLATFORM) ;

	IOS_SDK_VERSION_MIN on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(SDK_VERSION_MIN) ;

	if $(TARGETINFO_LOCATE) {
		if $(SDK_PLATFORM) in iphone iphonesimulator ipad ipadsimulator {
			Contents += "Projects[ [[C.*]] ].IOS_SDK_VERSION_MIN[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(SDK_VERSION_MIN)]]

" ;
		} else if $(SDK_PLATFORM) in macosx32 macosx64 {
			Contents += "Projects[ [[C.*]] ].OSX_SDK_VERSION_MIN[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(SDK_VERSION_MIN)]]

" ;
		}
	}
}

rule C.ios._BundleInfoArray KEY : VALUE {
	if ! $(KEY) in $(INFO_PLIST_KEYS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) {
		INFO_PLIST_KEYS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(KEY) ;
	}
	INFO_PLIST_KEYS.$(KEY).TYPE on $(C.ACTIVE_TOOLCHAIN_TARGET) = ArrayString ;
	INFO_PLIST_KEYS.$(KEY).VALUE on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(VALUE) ;
}


rule C.ios._BundleInfoIntegerArray KEY : VALUE {
	if ! $(KEY) in $(INFO_PLIST_KEYS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) {
		INFO_PLIST_KEYS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(KEY) ;
	}
	INFO_PLIST_KEYS.$(KEY).TYPE on $(C.ACTIVE_TOOLCHAIN_TARGET) = ArrayInteger ;
	INFO_PLIST_KEYS.$(KEY).VALUE on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(VALUE) ;
}


rule C.ios._BundleInfoBoolean KEY : VALUE {
	if ! $(KEY) in $(INFO_PLIST_KEYS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) {
		INFO_PLIST_KEYS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(KEY) ;
	}
	INFO_PLIST_KEYS.$(KEY).TYPE on $(C.ACTIVE_TOOLCHAIN_TARGET) = Boolean ;
	INFO_PLIST_KEYS.$(KEY).VALUE on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(VALUE) ;
}


rule C.ios._BundleInfoString KEY : VALUE {
	if ! $(KEY) in $(INFO_PLIST_KEYS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) {
		INFO_PLIST_KEYS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(KEY) ;
	}
	INFO_PLIST_KEYS.$(KEY).TYPE on $(C.ACTIVE_TOOLCHAIN_TARGET) = String ;
	INFO_PLIST_KEYS.$(KEY).VALUE on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(VALUE) ;
}


rule C.ios.BundleInfo TARGET : TYPE : VALUE {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	on $(C.ACTIVE_TOOLCHAIN_TARGET) if ! $(INFO_PLIST_KEYS) {
		C.ios._BundleInfoString CFBundleDevelopmentRegion : en ;
		C.ios._BundleInfoString CFBundleExecutable : [ C._retrieveOutputName $(TARGET) ] ;
		C.ios._BundleInfoString CFBundleInfoDictionaryVersion : 6.0 ;
		C.ios._BundleInfoString CFBundlePackageType : APPL ;
		C.ios._BundleInfoString CFBundleSignature : ???? ;
		if ! $(NT) {
			C.ios._BundleInfoString CFBundleResourceSpecification : ResourceRules.plist ;
		}

		switch $(C.PLATFORM) {
			case iphone :
				C.ios._BundleInfoBoolean LSRequiresIPhoneOS : true ;
				C.ios._BundleInfoIntegerArray UIDeviceFamily : 1 ;
				C.ios._BundleInfoString DTPlatformName : iphoneos ;
				C.ios._BundleInfoString DTSDKName : iphoneos$(IPHONEOS_SDK_VERSION) ;
				C.ios._BundleInfoArray CFBundleSupportedPlatforms : iPhoneOS ;
				C.ios._BundleInfoString MinimumOSVersion : $(IOS_SDK_VERSION_MIN) ;

			case iphonesimulator :
				C.ios._BundleInfoBoolean LSRequiresIPhoneOS : true ;
				C.ios._BundleInfoIntegerArray UIDeviceFamily : 1 ;
				C.ios._BundleInfoString DTPlatformName : iphonesimulator ;
				C.ios._BundleInfoString DTSDKName : iphonesimulator$(IPHONEOS_SDK_VERSION) ;
				C.ios._BundleInfoArray CFBundleSupportedPlatforms : iPhoneSimulator ;
				C.ios._BundleInfoString MinimumOSVersion : $(IOS_SDK_VERSION_MIN) ;

			case ipad :
				C.ios._BundleInfoBoolean LSRequiresIPhoneOS : true ;
				C.ios._BundleInfoIntegerArray UIDeviceFamily : 2 ;
				C.ios._BundleInfoString DTPlatformName : iphoneos ;
				C.ios._BundleInfoString DTSDKName : iphoneos$(IPHONEOS_SDK_VERSION) ;
				C.ios._BundleInfoArray CFBundleSupportedPlatforms : iPhoneOS ;
				C.ios._BundleInfoString MinimumOSVersion : $(IOS_SDK_VERSION_MIN) ;

			case ipadsimulator :
				C.ios._BundleInfoBoolean LSRequiresIPhoneOS : true ;
				C.ios._BundleInfoIntegerArray UIDeviceFamily : 2 ;
				C.ios._BundleInfoString DTPlatformName : iphonesimulator ;
				C.ios._BundleInfoString DTSDKName : iphonesimulator$(IPHONEOS_SDK_VERSION) ;
				C.ios._BundleInfoArray CFBundleSupportedPlatforms : iPhoneSimulator ;
				C.ios._BundleInfoString MinimumOSVersion : $(IOS_SDK_VERSION_MIN) ;
		}
	}

	switch $(TYPE:L) {
		case info :					C.ios._BundleInfoString CFBundleGetInfoString : $(VALUE) ;
		case iconfile :				C.ios._BundleInfoString CFBundleIconFile : $(VALUE) ;
		case iconfiles :			C.ios._BundleInfoArray CFBundleIconFiles : $(VALUE) ;
		case longversion :			C.ios._BundleInfoString CFBundleLongVersionString : $(VALUE) ;
		case bundlename :
			C.ios._BundleInfoString CFBundleName : $(VALUE) ;
			CFBundleName on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(VALUE) ;
		case displayname :
			C.ios._BundleInfoString CFBundleDisplayName : $(VALUE) ;
			CFBundleDisplayName on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(VALUE) ;
		case executable :			C.ios._BundleInfoString CFBundleExecutable : $(VALUE) ;
		case identifier :
			C.ios._BundleInfoString CFBundleIdentifier : $(VALUE[1]) ;
			CFBundleIdentifier on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(VALUE[1]) ;
			AppIdentifierPrefix on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(VALUE[2]) ;
		case shortversion :			C.ios._BundleInfoString CFShortVersionString : $(VALUE) ;
		case bundleversion :
			C.ios._BundleInfoString CFBundleVersion : $(VALUE) ;
			CFBundleVersion on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(VALUE) ;
		case copyright :			C.ios._BundleInfoString NSHumanReadableCopyright : $(VALUE) ;
		case mainnibfile :			C.ios._BundleInfoString NSMainNibFile : $(VALUE) ;
		case resourcespec :			C.ios._BundleInfoString CFBundleResourceSpecification : $(VALUE) ;
		case supportedplatforms :   C.ios._BundleInfoArray CFBundleSupportedPlatforms : $(VALUE) ;
		case minimumosversion :		C.ios._BundleInfoString MinimumOSVersion : $(VALUE) ;
		case uidevicefamily :		C.ios._BundleInfoIntegerArray UIDeviceFamily : $(VALUE) ;
		case uiprerenderedicon :	C.ios._BundleInfoBoolean UIPrerenderedIcon : $(VALUE) ;
		case uistatusbarhidden :	C.ios._BundleInfoBoolean UIStatusBarHidden : $(VALUE) ;
		case uiviewcontrollerbasedstatusbarappearance : C.ios._BundleInfoBoolean UIViewControllerBasedStatusBarAppearance : $(VALUE) ;
		case uiinterfaceorientation :	
			if $(VALUE) = portrait {
				C.ios._BundleInfoString UIInterfaceOrientation : UIInterfaceOrientationPortrait ;
			}
			if $(VALUE) = portraitupsidedown {
				C.ios._BundleInfoString UIInterfaceOrientation : UIInterfaceOrientationPortraitUpsideDown ;
			}
			if $(VALUE) = landscapeleft {
				C.ios._BundleInfoString UIInterfaceOrientation : UIInterfaceOrientationLandscapeLeft ;
			}
			if $(VALUE) = landscaperight {
				C.ios._BundleInfoString UIInterfaceOrientation : UIInterfaceOrientationLandscapeRight ;
			}
		case uisupportedinterfaceorientations :
			local values = ;
			if portrait in $(VALUE) {
				values += UIInterfaceOrientationPortrait ;
			}
			if portraitupsidedown in $(VALUE) {
				values += UIInterfaceOrientationPortraitUpsideDown ;
			}
			if landscapeleft in $(VALUE) {
				values += UIInterfaceOrientationLandscapeLeft ;
			}
			if landscaperight in $(VALUE) {
				values += UIInterfaceOrientationLandscapeRight ;
			}
			C.ios._BundleInfoArray UISupportedInterfaceOrientations : $(values) ;
	}
}


actions C.ios._GenerateDSYMFile {
	@($(COMPILER_BIN_PATH)/dsymutil:C) $(2:C) -o $(OUTPUT_PATH:C)
}


rule C.ios.GenerateDSYMFile TARGET {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	local bundlePath = $(BUNDLE_PATH:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	local dsymBundlePath = $(bundlePath).dSYM ;
	local _t = $(LIPO_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	local _t.dsym = $(_t).DSYM ;
	DSYM_NAME on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(_t.dsym) ;
	BINDING on $(_t.dsym) = $(BINDING:Z=$(_t)) ;
	OUTPUT_PATH on $(_t.dsym) = $(dsymBundlePath) ;
	MakeLocate $(_t.dsym) : $(dsymBundlePath)/Contents/Resources/DWARF ;
	Depends $(C.ACTIVE_TOOLCHAIN_TARGET) : $(_t.dsym) : $(_t) ;
	CleanTree $(CLEAN_BUNDLE_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) : $(dsymBundlePath) ;
	C.ios._GenerateDSYMFile $(_t.dsym) : $(_t) : $(C.COMPILER_SUITE_SYMBOL) ;
}


actions ios.CpResource
{
	ditto $(2) $(1:D)
}

C.__DOLLAR = \\$ ;
C.__JUST_DOLLAR = $ ;
C.__COLON = ":" ;

actions ios.ProcessEntitlements
{
	plutil -convert xml1 -o $(1) $(2)
	sed -i "" -e "s/$(C.__DOLLAR)(CFBundleIdentifier)/$(CFBundleIdentifier:E=*needs-CFBundleIdenfier*)/g" -e "s/$(C.__DOLLAR)(AppIdentifierPrefix)/$(AppIdentifierPrefix:E=*needs-AppIdentifierPrefix*)./g" -e "s/<key>keychain-access-groups/$(GET_TASK_ALLOW:E="")<key>keychain-access-groups/g" $(1)
}
	#plutil -convert binary1 $(1)

actions C.ios._Lipo {
	$(C.LIPO:C) $(2:C) -output $(1:C) -create
}

rule C.ios.Lipo TARGET : LINK_TARGETS : OUTPUT_PATH {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	local _t = $(LINK_TARGETS[0]:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)$(C.__COLON)lipo) ;
	BINDING on $(_t) = $(BINDING:Z=$(LINK_TARGETS[0])) ;
	Depends $(TARGET) : $(C.ACTIVE_TOOLCHAIN_TARGET) : $(_t) : $(LINK_TARGETS) ;
	MakeLocate $(_t) : $(OUTPUT_PATH) ;
	Clean $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(_t) ;
	C.ios._Lipo $(_t) : $(LINK_TARGETS) : $(C.COMPILER_SUITE_SYMBOL) ;
	LIPO_TARGET on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(_t) ;
	return $(linkTargets) ;
}


rule C.ios.Bundle TARGET : TOOLCHAINS {
	TARGET = [ ActiveTarget $(TARGET) ] ;

	local outputName = [ C._retrieveOutputName ] ;
	local outputPath = [ C._retrieveOutputPath ] ;
	local bundlePath = $(outputPath)/$(outputName).app ;
	BUNDLE_PATH on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(bundlePath) ;

	local bundleTarget = $(C.ACTIVE_TOOLCHAIN_TARGET_GRIST):bundle ;
	local colon = ":" ;
	local cleanBundleTarget = @(clean$(colon)$(TARGET)$(colon)bundle:G=$(C.ACTIVE_TOOLCHAIN_GRIST)) ;
	BUNDLE_TARGET on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(bundleTarget) ;
	CLEAN_BUNDLE_TARGET on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(cleanBundleTarget) ;
	Depends $(C.ACTIVE_TOOLCHAIN_TARGET) : $(bundleTarget) ;
	NotFile $(bundleTarget) ;
	Depends clean : clean:$(TARGET) : $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(cleanBundleTarget) ;
	NotFile clean:$(TARGET) $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) ;
	Always clean:$(TARGET) $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) ;
	NotFile $(cleanBundleTarget) ;
	Always $(cleanBundleTarget) ;

	local linkTargets ;
	local toolchain ;
	for toolchain in $(TOOLCHAINS:E=$(C.ACTIVE_TOOLCHAIN)) {
		linkTargets += [ C.GetLinkTargets $(TARGET) : $(toolchain) ] ;
	}
	C.ios.Lipo $(TARGET) : $(linkTargets) : $(bundlePath) ;

	{
		local isysroot = $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
		isysroot ?= $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

		# Get task allow value - trying target first, if not set falling back to configuration, if not set defaulting to true.
		local getTaskAllowValue = $(GET_TASK_ALLOW:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
		getTaskAllowValue ?= $(GET_TASK_ALLOW:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;
		getTaskAllowValue ?= true ;

		local pkginfo = @(PkgInfo:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
		MakeLocate $(pkginfo) : $(bundlePath) ;
		local contents = APPL???? ;
		CONTENTS on $(pkginfo) = $(contents) ;
		WriteFile $(pkginfo) ;
		UseCommandLine $(pkginfo) : $(contents) ;
		Depends $(bundleTarget) : $(pkginfo) ;
		Clean $(cleanBundleTarget) : $(pkginfo) ;

		if $(INFO_PLIST_KEYS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) {

			# Set up Info.plist file header.
			local infoplistcontents = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">
<plist version=\"1.0\">
<dict>
" ;
			# Set up each key/value pair based on the type (Array/Boolean/String).
			for _key in $(INFO_PLIST_KEYS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))
			{
				switch $(INFO_PLIST_KEYS.$(_key).TYPE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))
				{
					case ArrayInteger :
						infoplistcontents += "$(TAB)<key>$(_key)</key>$(NEWLINE)$(TAB)<array>$(NEWLINE)" ;
						for value in $(INFO_PLIST_KEYS.$(_key).VALUE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) {
							infoplistcontents += "$(TAB)$(TAB)<integer>$(value)</integer>$(NEWLINE)" ;
						}
						infoplistcontents += "$(TAB)</array>$(NEWLINE)" ;
					case ArrayString :
						infoplistcontents += "$(TAB)<key>$(_key)</key>$(NEWLINE)$(TAB)<array>$(NEWLINE)" ;
						for value in $(INFO_PLIST_KEYS.$(_key).VALUE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) {
							infoplistcontents += "$(TAB)$(TAB)<string>$(value)</string>$(NEWLINE)" ;
						}
						infoplistcontents += "$(TAB)</array>$(NEWLINE)" ;
					case Boolean :
						infoplistcontents += "$(TAB)<key>$(_key)</key>$(NEWLINE)$(TAB)" ;
						if $(INFO_PLIST_KEYS.$(_key).VALUE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) = true {
							infoplistcontents += "<true/>$(NEWLINE)" ;
						} else {
							infoplistcontents += "<false/>$(NEWLINE)" ;
						}
					case String :
						infoplistcontents += "$(TAB)<key>$(_key)</key>$(NEWLINE)$(TAB)<string>$(INFO_PLIST_KEYS.$(_key).VALUE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))</string>$(NEWLINE)" ;
				}
			}

			# Set up Info.plist file footer.
			infoplistcontents += "</dict>
</plist>
" ;
			infoplistcontents = $(infoplistcontents:J="") ;

			local infoplist = @(Info.plist:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
			MakeLocate $(infoplist) : $(bundlePath) ;
			CONTENTS on $(infoplist) = $(infoplistcontents) ;
			WriteFile $(infoplist) ;

			UseCommandLine $(infoplist) : $(infoplistcontents) ;
			Depends $(bundleTarget) : $(infoplist) ;
			Clean $(cleanBundleTarget) : $(infoplist) ;
		}

		if $(C.PLATFORM) in ipad iphone  &&  ! $(NT) {
			# Copy ResourceRules.plist.
			local sourceResourceRulesPlist = @(ResourceRules.plist:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)|source) ;
			SEARCH on $(sourceResourceRulesPlist) = $(isysroot) ;
			local destResourceRulesPlist = @(ResourceRules.plist:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
			MakeLocate $(destResourceRulesPlist) : $(bundlePath) ;

			Depends $(bundleTarget) : $(destResourceRulesPlist) : $(sourceResourceRulesPlist) ;	
			Clean $(cleanBundleTarget) : $(destResourceRulesPlist) ;
			ios.CpResource $(destResourceRulesPlist) : $(sourceResourceRulesPlist) ;

			# Create Entitlements.plist.
			local sourceEntitlementsPlist = @(Entitlements.plist:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)|source) ;
			SEARCH on $(sourceEntitlementsPlist) = $(isysroot) ;
			local destEntitlementsPlist = @(Entitlements.plist:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
			MakeLocate $(destEntitlementsPlist) : $(LOCATE_TARGET) ;
			ENTITLEMENTS on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(destEntitlementsPlist) ;
			Depends $(bundleTarget) : $(destEntitlementsPlist) : $(sourceEntitlementsPlist) ;
			local getTaskAllow = "<key>get-task-allow<\\/key><$(getTaskAllowValue)\\/>" ;
			GET_TASK_ALLOW on $(destEntitlementsPlist) = $(getTaskAllow) ;
			on $(C.ACTIVE_TOOLCHAIN_TARGET) UseCommandLine $(destEntitlementsPlist) : $(CFBundleIdentifier) $(AppIdentifierPrefix) $(getTaskAllow) ;
			Clean $(cleanBundleTarget) : $(destEntitlementsPlist) ;
			ios.ProcessEntitlements $(destEntitlementsPlist) : $(sourceEntitlementsPlist) : $(C.ACTIVE_TOOLCHAIN_TARGET) ;
		}

		{
			local provisionFileTarget = $(PROVISION_FILE_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
			local embedded.mobileprovision = @(embedded.mobileprovision:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
			MakeLocate $(embedded.mobileprovision) : $(bundlePath) ;

			# Copy provision into the bundle and name it embedded.mobileprovision
			Depends $(bundleTarget) : $(embedded.mobileprovision) ;
			CopyFile $(TARGET) : $(embedded.mobileprovision) : $(provisionFileTarget) ;

			# Without this, if we change between profiles, the copy will not always
			# work due to destination time stamp being newer than source (despite
			# coming from a different file).
			UseCommandLine $(embedded.mobileprovision) : $(provisionFileTarget) ;
		}
	}
	
	if $(C.PLATFORM) in ipad ipadsimulator iphone iphonesimulator {
		if ! $(NT) {
			C.ios.GenerateDSYMFile $(TARGET) ;
		}
	}

	if $(C.PLATFORM) in ipad iphone {
		local linkTarget = $(LIPO_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
		local entitlements = $(ENTITLEMENTS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
		local signingIdentity = $(SIGNING_IDENTITY:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;

		local dependsList = [ DependsList $(bundleTarget) ] ;

		local codeResources = @(CodeResources:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
		MakeLocate $(codeResources) : $(bundlePath)/_CodeSignature ;

		LINK_TARGET on $(codeResources) = $(linkTarget) ;

		if $(IOSBUILDENV_PATH) {
			local resourceRulesPlist = @(ResourceRules.plist:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
			MakeLocate $(resourceRulesPlist) : $(bundlePath) ;

			UseCommandLine $(codeResources) $(resourceRulesPlist) : $(dependsList) ;
			Depends $(bundleTarget) : $(codeResources) $(resourceRulesPlist) : $(dependsList) $(linkTarget) ;
			Clean $(cleanBundleTarget) : $(codeResources) $(resourceRulesPlist) ;

			CERTIFICATE_CHAIN on $(codeResources) = $(CERTIFICATE_CHAIN:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
			C.ios._CodeSign $(codeResources) : $(dependsList) $(linkTarget) : $(C.COMPILER_SUITE_SYMBOL) ;
		} else {
			local codeResourcesSymbolicLink = [ C.GristFiles : CodeResourcesLink ] ;
			BINDING on $(codeResourcesSymbolicLink) = CodeResources ;
			MakeLocate $(codeResourcesSymbolicLink) : $(bundlePath) ;

			BUNDLE_PATH on $(codeResources) = $(bundlePath) ;
			ENTITLEMENTS on $(codeResources) = $(entitlements) ;
			SIGNING_IDENTITY on $(codeResources) = $(signingIdentity) ;

			local dsym_name = $(DSYM_NAME:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
			DSYM_NAME on $(codeResources) = $(dsym_name) ;
			C.ios._CodeSign $(codeResources) : $(dependsList) : $(C.COMPILER_SUITE_SYMBOL) ;

			UseCommandLine $(codeResources) : $(dependsList) ;
			Depends $(bundleTarget) : $(codeResources) : $(dependsList) $(dsym_name) ;
			Clean $(cleanBundleTarget) : $(codeResources) $(codeResourcesSymbolicLink) ;
		}
	}

}


rule C.ios._ApplicationFromObjects_PostBuild {
	if bundle in $(OPTIONS) {
		C.ios.Bundle ;
	}
}


rule C.ios._Inherits {
	local publicFrameworks = $(PUBLIC_FRAMEWORKS:Z=$(inheritsTarget)) ;
	if $(publicFrameworks) {
		FRAMEWORKS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(publicFrameworks) ;
		if $(public) {
			PUBLIC_FRAMEWORKS on $(C.ACTIVE_TOOLCHAIN_TARGET) += $(publicFrameworks) ;
		}
	}
}


rule C.ios._MultiCppCompile_SetupFlags {
	local isysroot = $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	isysroot ?= $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

	local sdkversion = $(IPHONEOS_SDK_VERSION:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	sdkversion ?= $(IPHONEOS_SDK_VERSION:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

	local minimumsdkversion = $(IOS_SDK_VERSION_MIN:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	minimumsdkversion ?= $(IOS_SDK_VERSION_MIN:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

	local architecture = $(C.ARCHITECTURE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	architecture ?= $(C.ARCHITECTURE:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

	local extraflags ;
	if $(IOSBUILDENV_PATH) {
		architecture ?= armv7 ;
		extraflags = -target $(architecture)-apple-ios$(sdkversion) ;
		if $(isysroot) {
			extraflags += --sysroot $(isysroot:C) ;
		}
		local noPeriodVersion = [ Subst $(minimumsdkversion) : %. : "" ] ;
		extraflags += -miphoneos-version-min=$(minimumsdkversion).0 ;
		extraflags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=$(noPeriodVersion)000 ;
		extraflags += -F\"$(IOSBUILDENV_PATH)/SDK/System/Library/Frameworks\" ;    #"
	} else {
		extraflags += "-isysroot $(isysroot:C)" ;
		extraflags += "-arch $(architecture)" ;
		switch $(C.PLATFORM) {
			case macosx32 :
				# 10.4, 10.5, 10.6, 10.7, 10.8 10.9
				extraflags += -mmacosx-version-min=$(minimumsdkversion) ;

			case macosx64 :
				# 10.4, 10.5, 10.6, 10.7, 10.8 10.9
				extraflags += -mmacosx-version-min=$(minimumsdkversion) ;

			case iphone :
				# 4.3, 5.0, 5.1, 6.0 6.1 7.0
				extraflags += -miphoneos-version-min=$(minimumsdkversion) ;

			case iphonesimulator :
				# 4.3, 5.0, 5.1, 6.0 6.1 7.0
				extraflags += -mios-simulator-version-min=$(minimumsdkversion) ;

			case ipadsimulator :
				# 4.3, 5.0, 5.1, 6.0 6.1 7.0
				extraflags += -mios-simulator-version-min=$(minimumsdkversion) ;

			case ipad :
				# 4.3, 5.0, 5.1, 6.0 6.1 7.0
				extraflags += -miphoneos-version-min=$(minimumsdkversion) ;
		}
	}

	_flags = $(_flags[1-4]) $(extraflags) $(_flags[5-]) ;

	C.clang._MultiCppCompile_SetupFlags ;
}


rule C.ios._ApplicationFromObjects_LinkFlags {
	linkRule = C.ios.clang.Link ;

	local isysroot = $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	isysroot ?= $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

	local architecture = $(C.ARCHITECTURE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	architecture ?= $(C.ARCHITECTURE:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

	local sdkversion = $(IPHONEOS_SDK_VERSION:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	sdkversion ?= $(IPHONEOS_SDK_VERSION:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

	local minimumsdkversion = $(IOS_SDK_VERSION_MIN:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	minimumsdkversion ?= $(IOS_SDK_VERSION_MIN:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

	if $(IOSBUILDENV_PATH) {
		linkFlags += "-syslibroot $(isysroot:C)" ;
		linkFlags += -ios_version_min $(minimumsdkversion) ;
		linkFlags += -F\"$(IOSBUILDENV_PATH)/SDK/System/Library/Frameworks\" ;
		linkFlags += -lSystem -lcrt1.o -lstdc++ ;
		#linkFlags += -lSystem -lbundle1.o -lstdc++ ;
	} else {
		linkFlags += "-isysroot $(isysroot:C)" ;
		linkFlags += "-arch $(architecture)" ;
		switch $(C.PLATFORM) {
			case iphone :
				# 4.3, 5.0, 5.1, 6.0 6.1 7.0
				linkFlags += -miphoneos-version-min=$(minimumsdkversion) ;

			case iphonesimulator :
				# 4.3, 5.0, 5.1, 6.0 6.1 7.0
				linkFlags += -mios-simulator-version-min=$(minimumsdkversion) ;

			case ipadsimulator :
				# 4.3, 5.0, 5.1, 6.0 6.1 7.0
				linkFlags += -mios-simulator-version-min=$(minimumsdkversion) ;

			case ipad :
				# 4.3, 5.0, 5.1, 6.0 6.1 7.0
				linkFlags += -miphoneos-version-min=$(minimumsdkversion) ;
		}
	}

	linkFlags += "-framework $(FRAMEWORKS:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))" ;
}


rule C.ios._LibraryFromObjects_LibFlags {
	archiveRule = C.ios.clang.Archive ;

	local isysroot = $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	isysroot ?= $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;
	if $(isysroot) {
		#libFlags += -syslibroot $(isysroot:C) ;
	}
}


rule C.ios._SharedLibraryFromObjects_LinkFlags {
	linkRule = C.ios.clang.Link ;

	local isysroot = $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	isysroot ?= $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

	local architecture = $(C.ARCHITECTURE:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	architecture ?= $(C.ARCHITECTURE:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;

	if $(IOSBUILDENV_PATH) {
		linkFlags += "-syslibroot $(isysroot:C)" ;
		linkFlags += -F\"$(IOSBUILDENV_PATH)/SDK/System/Library/Frameworks\" ;
		linkFlags += -lSystem -lcrt1.o -lstdc++ ;
	} else {
		linkFlags += "-isysroot $(isysroot:C)" ;
		linkFlags += "-arch $(architecture)" ;
	}

	if module in $(OPTIONS) {
		linkFlags += -bundle -undefined dynamic_lookup -fPIC ;
	} else {
		local installName =
			$(INSTALL_NAME_PATH:Z=$(C.ACTIVE_TOOLCHAIN_TARGET))
			$(INSTALL_NAME_PATH:Z=$(C.ACTIVE_TOOLCHAIN_*))
		;
		if ! $(installName) {
			installName = $(_t:TD) ;
		} else {
			installName = $(installName[1]) ;
		}
		local outputName = [ C._retrieveOutputName : $(_t:S) ] ;
		installName = $(outputName:BSR=$(installName)) ;
		linkFlags += -dynamiclib -fPIC -install_name $(installName) ;
	}
}


rule C.ios.SetTaskAllow TARGET : VALUE {
	TARGET = [ ActiveTarget $(TARGET) ] ;

	# If true/false isn't specific, assume true, as 'setting' could be thought of enabling.
	VALUE ?= true ;

	# Save value passed, we'll later check both $(TARGET) and C.* so we can have config defaults and support overrides.
	GET_TASK_ALLOW on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(VALUE) ;
}


if $(TARGETINFO_LOCATE) {

rule ios.XIB {

}

rule C.ios.SetTaskAllow {
}

rule C.ios.CodeSign TARGET : SIGNING_IDENTITY {
	Contents += "Projects[ [[C.*]] ].IOS_SIGNING_IDENTITY[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(SIGNING_IDENTITY)]]

" ;
}


rule C.ios._ApplicationTargetInfo {
	if $(C.PLATFORM) in ipad iphone  &&  ! $(NT) {
		local isysroot $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
		isysroot ?= $(ISYSROOT:Z=$(C.ACTIVE_TOOLCHAIN_*)) ;
		
		# Create Entitlements.plist.
		local sourceEntitlementsPlist = @(Entitlements.plist:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)|source) ;
		SEARCH on $(sourceEntitlementsPlist) = $(isysroot) ;
		local destEntitlementsPlist = @(Entitlements.plist:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
		MakeLocate $(destEntitlementsPlist) : $(LOCATE_TARGET) ;
		Depends all : $(destEntitlementsPlist) : $(sourceEntitlementsPlist) ;
		on $(C.ACTIVE_TOOLCHAIN_TARGET) UseCommandLine $(destEntitlementsPlist) : $(CFBundleIdentifier) $(AppIdentifierPrefix) ;
		ProcessEntitlements $(destEntitlementsPlist) : $(sourceEntitlementsPlist) : $(C.ACTIVE_TOOLCHAIN_TARGET) ;

		Contents += "Projects[ [[$(TARGET)]] ].XCODE_ENTITLEMENTS[ [[$(C.PLATFORM)]] ][ [[$(C.CONFIG)]] ] = [[$(destEntitlementsPlist:T)]]

" ;
	}
}

} else {

rule ios.XIB PARENT : SOURCES  {
	PARENT = [ ActiveTarget $(PARENT) ] ;
	
	local bundlePath = $(BUNDLE_PATH:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	if ! $(bundlePath)
	{
		Echo *** XIB $(PARENT) \: $(SOURCES) ;
		Exit *** Bundle path not setup for target $(TARGET) ;
	}


	SOURCES = $(SOURCES:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
	SEARCH on $(SOURCES) = $(SEARCH_SOURCE) ;
	
	local targets = $(SOURCES:S=.nib) ;
	
	MakeLocate $(targets) : $(bundlePath) ;
	Clean $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(targets) ;	
	
	Depends $(C.ACTIVE_TOOLCHAIN_TARGET) : $(targets) ;

	local source ;
	for source in $(SOURCES) {
		local target = $(source:S=.nib) ;
		Depends $(target) : $(source) ;
	
		ios.CompileXIB $(target) : $(source) : $(C.COMPILER_SUITE_SYMBOL) ;
	}
}


	#/Developer/usr/bin/ibtool --errors --warnings --notices --output-format human-readable-text --compile $(1:C) $(2:C)
actions ios.CompileXIB
{
	PATH=$(MACOSX_SDK_DEVELOPER_ROOT)/usr/bin:$PATH
	/Applications/Xcode.app/Contents/Developer/usr/bin/ibtool --errors --warnings --notices --output-format human-readable-text --compile $(1:C) $(2:C)
}


rule C.ios.ProvisionFile TARGET : FILENAME {
	TARGET = [ C.ActiveTarget $(TARGET) ] ;

	local _provisionDir = $(FILENAME:D) ;
	if $(_provisionDir) = "" {
	    _provisionDir = $(SUBDIR) ;
	}

	local _provisionFileTarget = $(FILENAME:BS/G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
	SEARCH on $(_provisionFileTarget) = $(_provisionDir) ;
	PROVISION_FILE_TARGET on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(_provisionFileTarget) ;
}


rule C.ios.Provision TARGET : PROFILE_ID {
	TARGET = [ ActiveTarget $(TARGET) ] ;
	local _matchingProvision ;

	# See if provided provision is a filename that exists.
	local _profileDir = $(PROFILE_ID:P/) ;
	local _profileFilename = $(PROFILE_ID:BS/G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
	
	if $(_profileDir) && $(_profileDir) != "" && $(_profileFilename) && $(_profileFilename) != ""
	{
		SEARCH on $(_profileFilename) = $(_profileDir) ;
		if $(_profileFilename:TC/) != $(PROFILE_ID:BSTC/)
		{
			_matchingProvision = $(_profileFilename) ;
		}
	}

	if ! $(_matchingProvision)
	{
		# Find profile from GUID.
		local _profileDirectory = "$(HOME)/Library/MobileDevice/Provisioning Profiles" ;

		# Open each profile and search for : "<string>$(PROFILE_ID)</string>"
		local _mobileProvisions = [ Glob $(_profileDirectory) : *.mobileprovision ] ;

		local _mobileProvision ;
		for _mobileProvision in $(_mobileProvisions) {
			local _cmd = "cat \"$(_mobileProvision)\" | grep \"<string>$(PROFILE_ID)</string>\"" ;
			local result = [ Shell $(_cmd) ] ;
			if $(result) != "" {
				_matchingProvision = $(_mobileProvision) ;
				break ;
			}
		}
	}

	if ! $(_matchingProvision) {
		Exit *** No mobile provisions found that match PROFILE_ID \: $(PROFILE_ID) ;
	}

	# Get bundle path.
	local _bundlePath ;
	local _bundlePath = $(BUNDLE_PATH:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
	local _bundleTarget = $(BUNDLE_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;

	if ! $(_bundlePath) {
		Echo *** C.ios.Provision $(TARGET) \: $(PROFILE_ID) ;
		Exit *** Bundle path not setup for target $(TARGET) ;
	}
	if ! $(_bundleTarget) {
		Echo *** C.ios.Provision $(TARGET) \: $(PROFILE_ID) ;
		Exit *** Bundle target not setup for target $(TARGET) ;
	}

	local _dstProvision = [ C.GristFiles : embedded.mobileprovision ] ;
	MakeLocate $(_dstProvision) : $(_bundlePath) ;

	# Copy provision into the bundle and name it embedded.mobileprovision
	CopyFile $(TARGET) : $(_dstProvision) : $(_matchingProvision) ;
	Depends $(_bundleTarget) : $(_dstProvision) ;

	# Without this, if we change between profiles, the copy will not always
	# work due to destination time stamp being newer than source (despite
	# coming from a different file).
	UseCommandLine $(_dstProvision) : $(_matchingProvision) ;
}


if $(NT) {

actions C.ios._CodeSign
{
    "$(IOSBUILDENV_PATH)/Toolchain/ldid" -k"$(IOSBUILDENV_PATH)/Keychain" -S$(CERTIFICATE_CHAIN) -E"" $(LINK_TARGET:CT)
    copy /B $(LINK_TARGET:CT\\)+,, $(LINK_TARGET:CT\\) > nul
}

} else {

actions C.ios._CodeSign
{
	export CODESIGN_ALLOCATE=$(COMPILER_BIN_PATH)/codesign_allocate
	/usr/bin/codesign --force --sign "$(SIGNING_IDENTITY)" --resource-rules="$(BUNDLE_PATH)/ResourceRules.plist" --entitlements $(ENTITLEMENTS:CT) $(BUNDLE_PATH)
	touch $(1:C)
	touch $(DSYM_NAME:CT)
}

}


rule C.ios.CodeSign TARGET : SIGNING_IDENTITY : CERTIFICATE_CHAIN {
	ActiveTarget $(TARGET) ;

	if $(C.PLATFORM) in ipad iphone {
		if $(IOSBUILDENV_PATH) {
			if $(CERTIFICATE_CHAIN) {
				CERTIFICATE_CHAIN on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(CERTIFICATE_CHAIN) ;
			} else {
				CERTIFICATE_CHAIN on $(C.ACTIVE_TOOLCHAIN_TARGET) = "::" ;
			}
		} else {
			#local codeResourcesSymbolicLink = [ C.GristFiles : CodeResourcesLink ] ;
			#BINDING on $(codeResourcesSymbolicLink) = CodeResources ;
			#MakeLocate $(codeResourcesSymbolicLink) : $(bundlePath) ;

			#BUNDLE_PATH on $(codeResources) = $(bundlePath) ;
			#LINK_TARGET on $(codeResources) = $(linkTarget) ;
			ENTITLEMENTS on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(entitlements) ;
			SIGNING_IDENTITY on $(C.ACTIVE_TOOLCHAIN_TARGET) = $(SIGNING_IDENTITY) ;

			#DSYM_NAME on $(codeResources) = $(DSYM_NAME:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
			#C._CodeSign $(codeResources) : $(dependsList) : $(C.COMPILER_SUITE_SYMBOL) ;

			#UseCommandLine $(codeResources) : $(dependsList) ;
			#Depends $(bundleTarget) : $(codeResources) : $(dependsList) ;
			#Clean $(cleanBundleTarget) : $(codeResources) $(codeResourcesSymbolicLink) ;
		}
	}
}


rule C.ios.Archive TARGET : OUTPUT_PATH : ITUNES_ARTWORK {
	# Set up the archive support.
	if $(C.PLATFORM) in ipad iphone {
		TARGET = [ ActiveTarget $(TARGET) ] ;

		local bundlePath = $(BUNDLE_PATH:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
		local linkTarget = $(LINK_TARGET:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;

		local archiveTarget = archive:$(TARGET) ;
		NotFile $(archiveTarget) ;

		local ipaTarget = @($(bundlePath:D=:S=).ipa:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
		OUTPUT_PATH ?= $(LOCATE_TARGET) ;
		MakeLocate $(ipaTarget) : $(OUTPUT_PATH) ;

		if $(ITUNES_ARTWORK) {
			Depends $(archiveTarget) : $(ipaTarget) : $(ITUNES_ARTWORK) ;
		}
		Depends $(archiveTarget) : $(ipaTarget) : $(TARGET:G=$(C.ACTIVE_TOOLCHAIN_GRIST)) ;
		Clean $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(ipaTarget) ;
		BUNDLE_PATH on $(ipaTarget) = $(bundlePath) ;
		SIGNING_IDENTITY on $(ipaTarget) = $(SIGNING_IDENTITY:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
		ITUNES_ARTWORK on $(ipaTarget) = $(ITUNES_ARTWORK) ;
		C.ios._Archive $(ipaTarget) : $(linkTarget) : $(C.COMPILER_SUITE_SYMBOL) ;
	}
}


rule C.ios.WebServer TARGET {
	# Set up the archive support.
	if $(C.PLATFORM) in ipad iphone {
		TARGET = [ ActiveTarget $(TARGET) ] ;

		local bundlePath = $(BUNDLE_PATH:Z=$(C.ACTIVE_TOOLCHAIN_TARGET)) ;
		local ipaTarget = @($(bundlePath:D=:S=).ipa:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST)) ;
		local OUTPUT_PATH = $(LOCATE:Z=$(ipaTarget)) ;

		local archiveTarget = archive:$(TARGET) ;
		OUTPUT_PATH on $(archiveTarget) = $(OUTPUT_PATH) ;

		if ! $(URL) {
			URL = [ LuaString "
				local socket = require 'socket'.udp()
				socket:setpeername('10.10.10.10', '9999')
				return 'https://' .. socket:getsockname() .. ':9999'
			" ] ;
		}
		if $(URL) {
			# Stolen from BetaBuilder:

			# Write manifest.plist.
			local manifest.plist = @(manifest.plist:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST):archive) ;
			MakeLocate $(manifest.plist) : $(OUTPUT_PATH) ;
			Depends $(archiveTarget) : $(manifest.plist) : $(ipaTarget) ;
			Clean $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(manifest.plist) ;
			local contents ;
			on $(C.ACTIVE_TOOLCHAIN_TARGET) contents =
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">
<plist version=\"1.0\">
<dict>
	<key>items</key>
	<array>
		<dict>
			<key>assets</key>
			<array>
				<dict>
					<key>kind</key>
					<string>software-package</string>
					<key>url</key>
					<string>$(URL)/$(ipaTarget:D=:G=)</string>
				</dict>
			</array>
			<key>metadata</key>
			<dict>
				<key>bundle-identifier</key>
				<string>$(CFBundleIdentifier)</string>
				<key>bundle-version</key>
				<string>$(CFBundleVersion)</string>
				<key>kind</key>
				<string>software</string>
				<key>title</key>
				<string>$(CFBundleDisplayName)</string>
			</dict>
		</dict>
	</array>
</dict>
</plist>
" ;
			CONTENTS on $(manifest.plist) = $(contents) ;
			Always $(manifest.plist) ;
			WriteFile $(manifest.plist) ;
			UseCommandLine $(manifest.plist) : $(contents) ;

			local index.html = @(index.html:G=$(C.ACTIVE_TOOLCHAIN_TARGET_GRIST):archive) ;
			MakeLocate $(index.html) : $(OUTPUT_PATH) ;
			Depends $(archiveTarget) : $(index.html) : $(manifest.plist) ;
			Clean $(C.ACTIVE_TOOLCHAIN_CLEAN_TARGET) : $(index.html) ;
			local contents ;
			on $(C.ACTIVE_TOOLCHAIN_TARGET) contents = "
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> <html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
<title>$(CFBundleDisplayName)</title>
<style type="text/css">
body {background:#fff;margin:0;padding:0;font-family:arial,helvetica,sans-serif;text-align:center;padding:10px;color:#333;font-size:16px;}
#container {width:300px;margin:0 auto;}
h1 {margin:0;padding:0;font-size:14px;}
p {font-size:13px;}
.link {background:#ecf5ff;border-top:1px solid #fff;border:1px solid #dfebf8;margin-top:.5em;padding:.3em;}
.link a {text-decoration:none;font-size:15px;display:block;color:#069;}

</style>
</head>
<body>

<div id="container">

<h1>iOS 4.0+ Users:</h1>

<div class="link"><a href="itms-services://?action=download-manifest&url=$(URL)/manifest.plist">Tap Here to Install<br />$(CFBundleDisplayName)<br />On Your Device</a></div>

<p><strong>Link didn't work?</strong><br />
Make sure you're visiting this page on your device, not your computer.</p>

</div>

</body>
</html>
" ;
			CONTENTS on $(index.html) = $(contents) ;
			Always $(index.html) ;
			WriteFile $(index.html) ;
			UseCommandLine $(index.html) : $(contents) ;

			C.ios._WebServer $(archiveTarget) ;
		}
	}
}


actions screenoutput C.ios._WebServer {
	$(JAM_EXECUTABLE_PATH:C) --webserver $(OUTPUT_PATH)
}

if $(NT) {


actions lua C.ios._Archive
{
	local ospath = require 'ospath'
	local filefind = require 'filefind'
	local filelist = {}
	local bundlePath = ospath.remove_slash([[$(BUNDLE_PATH)]])
	local bundleName = ospath.get_filename(bundlePath)
	for entry in filefind.glob(bundlePath .. '/**') do
		filelist[#filelist + 1] = {
			EntryName = 'Payload/' .. bundleName .. '/' .. entry.filename:sub(#bundlePath + 2),
			SourcePath = entry.filename,
		}
	end
	local itunesArtwork = jam_expand('$(C.__JUST_DOLLAR)(ITUNES_ARTWORK:T)')
	if itunesArtwork then
		filelist[#filelist + 1] = { EntryName = 'iTunesArtwork', SourcePath = itunesArtwork }
	end

	local ziparchive = require 'ziparchive'
	local archive = ziparchive.open([[$(1)]], 'a')
	archive:processfilelist(filelist)
	archive:close()
}

} else {

actions C.ios._Archive
{
	export CODESIGN_ALLOCATE=$(COMPILER_BIN_PATH)/codesign_allocate
	/usr/bin/xcrun -sdk iphoneos PackageApplication -v "$(BUNDLE_PATH)" -o "$(1)" --sign "$(SIGNING_IDENTITY)" --embed "$(BUNDLE_PATH)/embedded.mobileprovision"
}

}


} # TARGETINFO_LOCATE


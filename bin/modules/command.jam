REGISTERED_COMMANDS = ;

#LuaString "
#function Command()
#    local name = jam_getvar('NAME')[1]
#    jam_evaluaterule('Always', name)
#    local actionLines = jam_getvar('LINES')
#    local actionLine
#    for index, actionLine in ipairs(actionLines) do
#        jam_action(name .. index, actionLine, { screenoutput = true })
#        jam_evaluaterule(name .. index, name)
#    end
#    jam_evaluaterule('DebugSuppressMakeText')
#end
#" ;
#
#rule Command NAME : LINES {
#    LuaString "Command()" ;
#}

rule Command NAME : LINES : ACTION_MODIFIERS {
    REGISTERED_COMMANDS += $(NAME) ;

    Always $(NAME) ;
    if $(LINES) {
        ACTION_MODIFIERS ?= screenoutput ;
        local actionLine ;
        local index = 1 ;
        for actionLine in $(LINES) {
            parse "actions $(ACTION_MODIFIERS:J=$(SPACE)) $(NAME)-----$(index) { $(actionLine) }" ;
            $(NAME)-----$(index) $(NAME) ;
            index = [ Math $(index) + 1 ] ;
        }
    } else {
        if ! [ ActionExists $(NAME) ] {
            parse "actions $(NAME) { }" ;
        }
        $(NAME) $(NAME) ;
    }
    DebugSuppressMakeText ;
}

rule CommandLua NAME : LINES {
    REGISTERED_COMMANDS += $(NAME) ;

    Always $(NAME) ;
    if $(LINES) {
        local actionLine ;
        local index = 1 ;
        for actionLine in $(LINES) {
            parse "actions lua $(NAME)-----$(index) { $(actionLine) }" ;
            $(NAME)-----$(index) $(NAME) ;
            index = [ Math $(index) + 1 ] ;
        }
    } else {
        if ! [ ActionExists $(NAME) ] {
            parse "actions $(NAME) { }" ;
        }
        $(NAME) $(NAME) ;
    }
    DebugSuppressMakeText ;
}

rule CommandDescription NAME : DESCRIPTION {
    DESCRIPTION on $(NAME) = $(DESCRIPTION) ;
}

actions lua help {
	print('\nAvailable commands:\n')

	local commands = jam_getvar('REGISTERED_COMMANDS')
	table.sort(commands)

	local command
	for _, command in ipairs(commands) do
		print('', command)
	end
}
